// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_db.dart';

// ignore_for_file: type=lint
class $ReligionsTable extends Religions
    with TableInfo<$ReligionsTable, ReligionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReligionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _religion_idMeta = const VerificationMeta(
    'religion_id',
  );
  @override
  late final GeneratedColumn<int> religion_id = GeneratedColumn<int>(
    'religion_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [religion_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'religions';
  @override
  VerificationContext validateIntegrity(
    Insertable<ReligionData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('religion_id')) {
      context.handle(
        _religion_idMeta,
        religion_id.isAcceptableOrUnknown(
          data['religion_id']!,
          _religion_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {religion_id};
  @override
  ReligionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReligionData(
      religion_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}religion_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $ReligionsTable createAlias(String alias) {
    return $ReligionsTable(attachedDatabase, alias);
  }
}

class ReligionData extends DataClass implements Insertable<ReligionData> {
  final int religion_id;
  final String name;
  const ReligionData({required this.religion_id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['religion_id'] = Variable<int>(religion_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  ReligionsCompanion toCompanion(bool nullToAbsent) {
    return ReligionsCompanion(
      religion_id: Value(religion_id),
      name: Value(name),
    );
  }

  factory ReligionData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReligionData(
      religion_id: serializer.fromJson<int>(json['religion_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'religion_id': serializer.toJson<int>(religion_id),
      'name': serializer.toJson<String>(name),
    };
  }

  ReligionData copyWith({int? religion_id, String? name}) => ReligionData(
    religion_id: religion_id ?? this.religion_id,
    name: name ?? this.name,
  );
  ReligionData copyWithCompanion(ReligionsCompanion data) {
    return ReligionData(
      religion_id:
          data.religion_id.present ? data.religion_id.value : this.religion_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReligionData(')
          ..write('religion_id: $religion_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(religion_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReligionData &&
          other.religion_id == this.religion_id &&
          other.name == this.name);
}

class ReligionsCompanion extends UpdateCompanion<ReligionData> {
  final Value<int> religion_id;
  final Value<String> name;
  const ReligionsCompanion({
    this.religion_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  ReligionsCompanion.insert({
    this.religion_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<ReligionData> custom({
    Expression<int>? religion_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (religion_id != null) 'religion_id': religion_id,
      if (name != null) 'name': name,
    });
  }

  ReligionsCompanion copyWith({Value<int>? religion_id, Value<String>? name}) {
    return ReligionsCompanion(
      religion_id: religion_id ?? this.religion_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (religion_id.present) {
      map['religion_id'] = Variable<int>(religion_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReligionsCompanion(')
          ..write('religion_id: $religion_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $NationalitiesTable extends Nationalities
    with TableInfo<$NationalitiesTable, NationalityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NationalitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _nationality_idMeta = const VerificationMeta(
    'nationality_id',
  );
  @override
  late final GeneratedColumn<int> nationality_id = GeneratedColumn<int>(
    'nationality_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [nationality_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'nationalities';
  @override
  VerificationContext validateIntegrity(
    Insertable<NationalityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('nationality_id')) {
      context.handle(
        _nationality_idMeta,
        nationality_id.isAcceptableOrUnknown(
          data['nationality_id']!,
          _nationality_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {nationality_id};
  @override
  NationalityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NationalityData(
      nationality_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}nationality_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $NationalitiesTable createAlias(String alias) {
    return $NationalitiesTable(attachedDatabase, alias);
  }
}

class NationalityData extends DataClass implements Insertable<NationalityData> {
  final int nationality_id;
  final String name;
  const NationalityData({required this.nationality_id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['nationality_id'] = Variable<int>(nationality_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  NationalitiesCompanion toCompanion(bool nullToAbsent) {
    return NationalitiesCompanion(
      nationality_id: Value(nationality_id),
      name: Value(name),
    );
  }

  factory NationalityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NationalityData(
      nationality_id: serializer.fromJson<int>(json['nationality_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'nationality_id': serializer.toJson<int>(nationality_id),
      'name': serializer.toJson<String>(name),
    };
  }

  NationalityData copyWith({int? nationality_id, String? name}) =>
      NationalityData(
        nationality_id: nationality_id ?? this.nationality_id,
        name: name ?? this.name,
      );
  NationalityData copyWithCompanion(NationalitiesCompanion data) {
    return NationalityData(
      nationality_id:
          data.nationality_id.present
              ? data.nationality_id.value
              : this.nationality_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('NationalityData(')
          ..write('nationality_id: $nationality_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(nationality_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NationalityData &&
          other.nationality_id == this.nationality_id &&
          other.name == this.name);
}

class NationalitiesCompanion extends UpdateCompanion<NationalityData> {
  final Value<int> nationality_id;
  final Value<String> name;
  const NationalitiesCompanion({
    this.nationality_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  NationalitiesCompanion.insert({
    this.nationality_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<NationalityData> custom({
    Expression<int>? nationality_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (nationality_id != null) 'nationality_id': nationality_id,
      if (name != null) 'name': name,
    });
  }

  NationalitiesCompanion copyWith({
    Value<int>? nationality_id,
    Value<String>? name,
  }) {
    return NationalitiesCompanion(
      nationality_id: nationality_id ?? this.nationality_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (nationality_id.present) {
      map['nationality_id'] = Variable<int>(nationality_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NationalitiesCompanion(')
          ..write('nationality_id: $nationality_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $EthnicitiesTable extends Ethnicities
    with TableInfo<$EthnicitiesTable, EthnicityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EthnicitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ethnicity_idMeta = const VerificationMeta(
    'ethnicity_id',
  );
  @override
  late final GeneratedColumn<int> ethnicity_id = GeneratedColumn<int>(
    'ethnicity_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [ethnicity_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ethnicities';
  @override
  VerificationContext validateIntegrity(
    Insertable<EthnicityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ethnicity_id')) {
      context.handle(
        _ethnicity_idMeta,
        ethnicity_id.isAcceptableOrUnknown(
          data['ethnicity_id']!,
          _ethnicity_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ethnicity_id};
  @override
  EthnicityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EthnicityData(
      ethnicity_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}ethnicity_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $EthnicitiesTable createAlias(String alias) {
    return $EthnicitiesTable(attachedDatabase, alias);
  }
}

class EthnicityData extends DataClass implements Insertable<EthnicityData> {
  final int ethnicity_id;
  final String name;
  const EthnicityData({required this.ethnicity_id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ethnicity_id'] = Variable<int>(ethnicity_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  EthnicitiesCompanion toCompanion(bool nullToAbsent) {
    return EthnicitiesCompanion(
      ethnicity_id: Value(ethnicity_id),
      name: Value(name),
    );
  }

  factory EthnicityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EthnicityData(
      ethnicity_id: serializer.fromJson<int>(json['ethnicity_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ethnicity_id': serializer.toJson<int>(ethnicity_id),
      'name': serializer.toJson<String>(name),
    };
  }

  EthnicityData copyWith({int? ethnicity_id, String? name}) => EthnicityData(
    ethnicity_id: ethnicity_id ?? this.ethnicity_id,
    name: name ?? this.name,
  );
  EthnicityData copyWithCompanion(EthnicitiesCompanion data) {
    return EthnicityData(
      ethnicity_id:
          data.ethnicity_id.present
              ? data.ethnicity_id.value
              : this.ethnicity_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EthnicityData(')
          ..write('ethnicity_id: $ethnicity_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ethnicity_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EthnicityData &&
          other.ethnicity_id == this.ethnicity_id &&
          other.name == this.name);
}

class EthnicitiesCompanion extends UpdateCompanion<EthnicityData> {
  final Value<int> ethnicity_id;
  final Value<String> name;
  const EthnicitiesCompanion({
    this.ethnicity_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  EthnicitiesCompanion.insert({
    this.ethnicity_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<EthnicityData> custom({
    Expression<int>? ethnicity_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (ethnicity_id != null) 'ethnicity_id': ethnicity_id,
      if (name != null) 'name': name,
    });
  }

  EthnicitiesCompanion copyWith({
    Value<int>? ethnicity_id,
    Value<String>? name,
  }) {
    return EthnicitiesCompanion(
      ethnicity_id: ethnicity_id ?? this.ethnicity_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ethnicity_id.present) {
      map['ethnicity_id'] = Variable<int>(ethnicity_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EthnicitiesCompanion(')
          ..write('ethnicity_id: $ethnicity_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $BloodTypesTable extends BloodTypes
    with TableInfo<$BloodTypesTable, BloodTypeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BloodTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _blood_type_idMeta = const VerificationMeta(
    'blood_type_id',
  );
  @override
  late final GeneratedColumn<int> blood_type_id = GeneratedColumn<int>(
    'blood_type_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [blood_type_id, type];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'blood_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<BloodTypeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('blood_type_id')) {
      context.handle(
        _blood_type_idMeta,
        blood_type_id.isAcceptableOrUnknown(
          data['blood_type_id']!,
          _blood_type_idMeta,
        ),
      );
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {blood_type_id};
  @override
  BloodTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BloodTypeData(
      blood_type_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}blood_type_id'],
          )!,
      type:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}type'],
          )!,
    );
  }

  @override
  $BloodTypesTable createAlias(String alias) {
    return $BloodTypesTable(attachedDatabase, alias);
  }
}

class BloodTypeData extends DataClass implements Insertable<BloodTypeData> {
  final int blood_type_id;
  final String type;
  const BloodTypeData({required this.blood_type_id, required this.type});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['blood_type_id'] = Variable<int>(blood_type_id);
    map['type'] = Variable<String>(type);
    return map;
  }

  BloodTypesCompanion toCompanion(bool nullToAbsent) {
    return BloodTypesCompanion(
      blood_type_id: Value(blood_type_id),
      type: Value(type),
    );
  }

  factory BloodTypeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BloodTypeData(
      blood_type_id: serializer.fromJson<int>(json['blood_type_id']),
      type: serializer.fromJson<String>(json['type']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'blood_type_id': serializer.toJson<int>(blood_type_id),
      'type': serializer.toJson<String>(type),
    };
  }

  BloodTypeData copyWith({int? blood_type_id, String? type}) => BloodTypeData(
    blood_type_id: blood_type_id ?? this.blood_type_id,
    type: type ?? this.type,
  );
  BloodTypeData copyWithCompanion(BloodTypesCompanion data) {
    return BloodTypeData(
      blood_type_id:
          data.blood_type_id.present
              ? data.blood_type_id.value
              : this.blood_type_id,
      type: data.type.present ? data.type.value : this.type,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BloodTypeData(')
          ..write('blood_type_id: $blood_type_id, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(blood_type_id, type);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BloodTypeData &&
          other.blood_type_id == this.blood_type_id &&
          other.type == this.type);
}

class BloodTypesCompanion extends UpdateCompanion<BloodTypeData> {
  final Value<int> blood_type_id;
  final Value<String> type;
  const BloodTypesCompanion({
    this.blood_type_id = const Value.absent(),
    this.type = const Value.absent(),
  });
  BloodTypesCompanion.insert({
    this.blood_type_id = const Value.absent(),
    required String type,
  }) : type = Value(type);
  static Insertable<BloodTypeData> custom({
    Expression<int>? blood_type_id,
    Expression<String>? type,
  }) {
    return RawValuesInsertable({
      if (blood_type_id != null) 'blood_type_id': blood_type_id,
      if (type != null) 'type': type,
    });
  }

  BloodTypesCompanion copyWith({
    Value<int>? blood_type_id,
    Value<String>? type,
  }) {
    return BloodTypesCompanion(
      blood_type_id: blood_type_id ?? this.blood_type_id,
      type: type ?? this.type,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (blood_type_id.present) {
      map['blood_type_id'] = Variable<int>(blood_type_id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BloodTypesCompanion(')
          ..write('blood_type_id: $blood_type_id, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }
}

class $AddressesTable extends Addresses
    with TableInfo<$AddressesTable, AddressData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AddressesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _address_idMeta = const VerificationMeta(
    'address_id',
  );
  @override
  late final GeneratedColumn<int> address_id = GeneratedColumn<int>(
    'address_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _zoneMeta = const VerificationMeta('zone');
  @override
  late final GeneratedColumn<String> zone = GeneratedColumn<String>(
    'zone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _streetMeta = const VerificationMeta('street');
  @override
  late final GeneratedColumn<String> street = GeneratedColumn<String>(
    'street',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _blockMeta = const VerificationMeta('block');
  @override
  late final GeneratedColumn<String> block = GeneratedColumn<String>(
    'block',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lotMeta = const VerificationMeta('lot');
  @override
  late final GeneratedColumn<String> lot = GeneratedColumn<String>(
    'lot',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [address_id, zone, street, block, lot];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'addresses';
  @override
  VerificationContext validateIntegrity(
    Insertable<AddressData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('address_id')) {
      context.handle(
        _address_idMeta,
        address_id.isAcceptableOrUnknown(data['address_id']!, _address_idMeta),
      );
    }
    if (data.containsKey('zone')) {
      context.handle(
        _zoneMeta,
        zone.isAcceptableOrUnknown(data['zone']!, _zoneMeta),
      );
    }
    if (data.containsKey('street')) {
      context.handle(
        _streetMeta,
        street.isAcceptableOrUnknown(data['street']!, _streetMeta),
      );
    }
    if (data.containsKey('block')) {
      context.handle(
        _blockMeta,
        block.isAcceptableOrUnknown(data['block']!, _blockMeta),
      );
    }
    if (data.containsKey('lot')) {
      context.handle(
        _lotMeta,
        lot.isAcceptableOrUnknown(data['lot']!, _lotMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {address_id};
  @override
  AddressData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AddressData(
      address_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}address_id'],
          )!,
      zone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}zone'],
      ),
      street: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}street'],
      ),
      block: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}block'],
      ),
      lot: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}lot'],
      ),
    );
  }

  @override
  $AddressesTable createAlias(String alias) {
    return $AddressesTable(attachedDatabase, alias);
  }
}

class AddressData extends DataClass implements Insertable<AddressData> {
  final int address_id;
  final String? zone;
  final String? street;
  final String? block;
  final String? lot;
  const AddressData({
    required this.address_id,
    this.zone,
    this.street,
    this.block,
    this.lot,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['address_id'] = Variable<int>(address_id);
    if (!nullToAbsent || zone != null) {
      map['zone'] = Variable<String>(zone);
    }
    if (!nullToAbsent || street != null) {
      map['street'] = Variable<String>(street);
    }
    if (!nullToAbsent || block != null) {
      map['block'] = Variable<String>(block);
    }
    if (!nullToAbsent || lot != null) {
      map['lot'] = Variable<String>(lot);
    }
    return map;
  }

  AddressesCompanion toCompanion(bool nullToAbsent) {
    return AddressesCompanion(
      address_id: Value(address_id),
      zone: zone == null && nullToAbsent ? const Value.absent() : Value(zone),
      street:
          street == null && nullToAbsent ? const Value.absent() : Value(street),
      block:
          block == null && nullToAbsent ? const Value.absent() : Value(block),
      lot: lot == null && nullToAbsent ? const Value.absent() : Value(lot),
    );
  }

  factory AddressData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AddressData(
      address_id: serializer.fromJson<int>(json['address_id']),
      zone: serializer.fromJson<String?>(json['zone']),
      street: serializer.fromJson<String?>(json['street']),
      block: serializer.fromJson<String?>(json['block']),
      lot: serializer.fromJson<String?>(json['lot']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'address_id': serializer.toJson<int>(address_id),
      'zone': serializer.toJson<String?>(zone),
      'street': serializer.toJson<String?>(street),
      'block': serializer.toJson<String?>(block),
      'lot': serializer.toJson<String?>(lot),
    };
  }

  AddressData copyWith({
    int? address_id,
    Value<String?> zone = const Value.absent(),
    Value<String?> street = const Value.absent(),
    Value<String?> block = const Value.absent(),
    Value<String?> lot = const Value.absent(),
  }) => AddressData(
    address_id: address_id ?? this.address_id,
    zone: zone.present ? zone.value : this.zone,
    street: street.present ? street.value : this.street,
    block: block.present ? block.value : this.block,
    lot: lot.present ? lot.value : this.lot,
  );
  AddressData copyWithCompanion(AddressesCompanion data) {
    return AddressData(
      address_id:
          data.address_id.present ? data.address_id.value : this.address_id,
      zone: data.zone.present ? data.zone.value : this.zone,
      street: data.street.present ? data.street.value : this.street,
      block: data.block.present ? data.block.value : this.block,
      lot: data.lot.present ? data.lot.value : this.lot,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AddressData(')
          ..write('address_id: $address_id, ')
          ..write('zone: $zone, ')
          ..write('street: $street, ')
          ..write('block: $block, ')
          ..write('lot: $lot')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(address_id, zone, street, block, lot);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AddressData &&
          other.address_id == this.address_id &&
          other.zone == this.zone &&
          other.street == this.street &&
          other.block == this.block &&
          other.lot == this.lot);
}

class AddressesCompanion extends UpdateCompanion<AddressData> {
  final Value<int> address_id;
  final Value<String?> zone;
  final Value<String?> street;
  final Value<String?> block;
  final Value<String?> lot;
  const AddressesCompanion({
    this.address_id = const Value.absent(),
    this.zone = const Value.absent(),
    this.street = const Value.absent(),
    this.block = const Value.absent(),
    this.lot = const Value.absent(),
  });
  AddressesCompanion.insert({
    this.address_id = const Value.absent(),
    this.zone = const Value.absent(),
    this.street = const Value.absent(),
    this.block = const Value.absent(),
    this.lot = const Value.absent(),
  });
  static Insertable<AddressData> custom({
    Expression<int>? address_id,
    Expression<String>? zone,
    Expression<String>? street,
    Expression<String>? block,
    Expression<String>? lot,
  }) {
    return RawValuesInsertable({
      if (address_id != null) 'address_id': address_id,
      if (zone != null) 'zone': zone,
      if (street != null) 'street': street,
      if (block != null) 'block': block,
      if (lot != null) 'lot': lot,
    });
  }

  AddressesCompanion copyWith({
    Value<int>? address_id,
    Value<String?>? zone,
    Value<String?>? street,
    Value<String?>? block,
    Value<String?>? lot,
  }) {
    return AddressesCompanion(
      address_id: address_id ?? this.address_id,
      zone: zone ?? this.zone,
      street: street ?? this.street,
      block: block ?? this.block,
      lot: lot ?? this.lot,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (address_id.present) {
      map['address_id'] = Variable<int>(address_id.value);
    }
    if (zone.present) {
      map['zone'] = Variable<String>(zone.value);
    }
    if (street.present) {
      map['street'] = Variable<String>(street.value);
    }
    if (block.present) {
      map['block'] = Variable<String>(block.value);
    }
    if (lot.present) {
      map['lot'] = Variable<String>(lot.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AddressesCompanion(')
          ..write('address_id: $address_id, ')
          ..write('zone: $zone, ')
          ..write('street: $street, ')
          ..write('block: $block, ')
          ..write('lot: $lot')
          ..write(')'))
        .toString();
  }
}

class $BuildingTypesTable extends BuildingTypes
    with TableInfo<$BuildingTypesTable, BuildingTypeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BuildingTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _building_type_idMeta = const VerificationMeta(
    'building_type_id',
  );
  @override
  late final GeneratedColumn<int> building_type_id = GeneratedColumn<int>(
    'building_type_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [building_type_id, type];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'building_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<BuildingTypeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('building_type_id')) {
      context.handle(
        _building_type_idMeta,
        building_type_id.isAcceptableOrUnknown(
          data['building_type_id']!,
          _building_type_idMeta,
        ),
      );
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {building_type_id};
  @override
  BuildingTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BuildingTypeData(
      building_type_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}building_type_id'],
          )!,
      type:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}type'],
          )!,
    );
  }

  @override
  $BuildingTypesTable createAlias(String alias) {
    return $BuildingTypesTable(attachedDatabase, alias);
  }
}

class BuildingTypeData extends DataClass
    implements Insertable<BuildingTypeData> {
  final int building_type_id;
  final String type;
  const BuildingTypeData({required this.building_type_id, required this.type});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['building_type_id'] = Variable<int>(building_type_id);
    map['type'] = Variable<String>(type);
    return map;
  }

  BuildingTypesCompanion toCompanion(bool nullToAbsent) {
    return BuildingTypesCompanion(
      building_type_id: Value(building_type_id),
      type: Value(type),
    );
  }

  factory BuildingTypeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BuildingTypeData(
      building_type_id: serializer.fromJson<int>(json['building_type_id']),
      type: serializer.fromJson<String>(json['type']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'building_type_id': serializer.toJson<int>(building_type_id),
      'type': serializer.toJson<String>(type),
    };
  }

  BuildingTypeData copyWith({int? building_type_id, String? type}) =>
      BuildingTypeData(
        building_type_id: building_type_id ?? this.building_type_id,
        type: type ?? this.type,
      );
  BuildingTypeData copyWithCompanion(BuildingTypesCompanion data) {
    return BuildingTypeData(
      building_type_id:
          data.building_type_id.present
              ? data.building_type_id.value
              : this.building_type_id,
      type: data.type.present ? data.type.value : this.type,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BuildingTypeData(')
          ..write('building_type_id: $building_type_id, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(building_type_id, type);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BuildingTypeData &&
          other.building_type_id == this.building_type_id &&
          other.type == this.type);
}

class BuildingTypesCompanion extends UpdateCompanion<BuildingTypeData> {
  final Value<int> building_type_id;
  final Value<String> type;
  const BuildingTypesCompanion({
    this.building_type_id = const Value.absent(),
    this.type = const Value.absent(),
  });
  BuildingTypesCompanion.insert({
    this.building_type_id = const Value.absent(),
    required String type,
  }) : type = Value(type);
  static Insertable<BuildingTypeData> custom({
    Expression<int>? building_type_id,
    Expression<String>? type,
  }) {
    return RawValuesInsertable({
      if (building_type_id != null) 'building_type_id': building_type_id,
      if (type != null) 'type': type,
    });
  }

  BuildingTypesCompanion copyWith({
    Value<int>? building_type_id,
    Value<String>? type,
  }) {
    return BuildingTypesCompanion(
      building_type_id: building_type_id ?? this.building_type_id,
      type: type ?? this.type,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (building_type_id.present) {
      map['building_type_id'] = Variable<int>(building_type_id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BuildingTypesCompanion(')
          ..write('building_type_id: $building_type_id, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }
}

class $HouseholdsTable extends Households
    with TableInfo<$HouseholdsTable, HouseholdData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _headMeta = const VerificationMeta('head');
  @override
  late final GeneratedColumn<String> head = GeneratedColumn<String>(
    'head',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _address_idMeta = const VerificationMeta(
    'address_id',
  );
  @override
  late final GeneratedColumn<int> address_id = GeneratedColumn<int>(
    'address_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES addresses (address_id) ON DELETE RESTRICT',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<HouseholdTypes?, String>
  household_type_id = GeneratedColumn<String>(
    'household_type_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<HouseholdTypes?>(
    $HouseholdsTable.$converterhousehold_type_idn,
  );
  static const VerificationMeta _building_type_idMeta = const VerificationMeta(
    'building_type_id',
  );
  @override
  late final GeneratedColumn<int> building_type_id = GeneratedColumn<int>(
    'building_type_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES building_types (building_type_id) ON DELETE RESTRICT',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<OwnershipTypes?, String>
  ownership_type_id = GeneratedColumn<String>(
    'ownership_type_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<OwnershipTypes?>(
    $HouseholdsTable.$converterownership_type_idn,
  );
  static const VerificationMeta _household_members_numMeta =
      const VerificationMeta('household_members_num');
  @override
  late final GeneratedColumn<int> household_members_num = GeneratedColumn<int>(
    'household_members_num',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _female_mortalityMeta = const VerificationMeta(
    'female_mortality',
  );
  @override
  late final GeneratedColumn<bool> female_mortality = GeneratedColumn<bool>(
    'female_mortality',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("female_mortality" IN (0, 1))',
    ),
  );
  static const VerificationMeta _child_mortalityMeta = const VerificationMeta(
    'child_mortality',
  );
  @override
  late final GeneratedColumn<bool> child_mortality = GeneratedColumn<bool>(
    'child_mortality',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("child_mortality" IN (0, 1))',
    ),
  );
  static const VerificationMeta _registration_dateMeta = const VerificationMeta(
    'registration_date',
  );
  @override
  late final GeneratedColumn<DateTime> registration_date =
      GeneratedColumn<DateTime>(
        'registration_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  late final GeneratedColumnWithTypeConverter<RegistrationStatus, String>
  registration_status = GeneratedColumn<String>(
    'registration_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  ).withConverter<RegistrationStatus>(
    $HouseholdsTable.$converterregistration_status,
  );
  @override
  List<GeneratedColumn> get $columns => [
    household_id,
    head,
    address_id,
    household_type_id,
    building_type_id,
    ownership_type_id,
    household_members_num,
    female_mortality,
    child_mortality,
    registration_date,
    registration_status,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'households';
  @override
  VerificationContext validateIntegrity(
    Insertable<HouseholdData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    }
    if (data.containsKey('head')) {
      context.handle(
        _headMeta,
        head.isAcceptableOrUnknown(data['head']!, _headMeta),
      );
    }
    if (data.containsKey('address_id')) {
      context.handle(
        _address_idMeta,
        address_id.isAcceptableOrUnknown(data['address_id']!, _address_idMeta),
      );
    }
    if (data.containsKey('building_type_id')) {
      context.handle(
        _building_type_idMeta,
        building_type_id.isAcceptableOrUnknown(
          data['building_type_id']!,
          _building_type_idMeta,
        ),
      );
    }
    if (data.containsKey('household_members_num')) {
      context.handle(
        _household_members_numMeta,
        household_members_num.isAcceptableOrUnknown(
          data['household_members_num']!,
          _household_members_numMeta,
        ),
      );
    }
    if (data.containsKey('female_mortality')) {
      context.handle(
        _female_mortalityMeta,
        female_mortality.isAcceptableOrUnknown(
          data['female_mortality']!,
          _female_mortalityMeta,
        ),
      );
    }
    if (data.containsKey('child_mortality')) {
      context.handle(
        _child_mortalityMeta,
        child_mortality.isAcceptableOrUnknown(
          data['child_mortality']!,
          _child_mortalityMeta,
        ),
      );
    }
    if (data.containsKey('registration_date')) {
      context.handle(
        _registration_dateMeta,
        registration_date.isAcceptableOrUnknown(
          data['registration_date']!,
          _registration_dateMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {household_id};
  @override
  HouseholdData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdData(
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      head: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}head'],
      ),
      address_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}address_id'],
      ),
      household_type_id: $HouseholdsTable.$converterhousehold_type_idn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}household_type_id'],
        ),
      ),
      building_type_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}building_type_id'],
      ),
      ownership_type_id: $HouseholdsTable.$converterownership_type_idn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}ownership_type_id'],
        ),
      ),
      household_members_num: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}household_members_num'],
      ),
      female_mortality: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}female_mortality'],
      ),
      child_mortality: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}child_mortality'],
      ),
      registration_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}registration_date'],
      ),
      registration_status: $HouseholdsTable.$converterregistration_status
          .fromSql(
            attachedDatabase.typeMapping.read(
              DriftSqlType.string,
              data['${effectivePrefix}registration_status'],
            )!,
          ),
    );
  }

  @override
  $HouseholdsTable createAlias(String alias) {
    return $HouseholdsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<HouseholdTypes, String, String>
  $converterhousehold_type_id = const EnumNameConverter<HouseholdTypes>(
    HouseholdTypes.values,
  );
  static JsonTypeConverter2<HouseholdTypes?, String?, String?>
  $converterhousehold_type_idn = JsonTypeConverter2.asNullable(
    $converterhousehold_type_id,
  );
  static JsonTypeConverter2<OwnershipTypes, String, String>
  $converterownership_type_id = const EnumNameConverter<OwnershipTypes>(
    OwnershipTypes.values,
  );
  static JsonTypeConverter2<OwnershipTypes?, String?, String?>
  $converterownership_type_idn = JsonTypeConverter2.asNullable(
    $converterownership_type_id,
  );
  static JsonTypeConverter2<RegistrationStatus, String, String>
  $converterregistration_status = const EnumNameConverter<RegistrationStatus>(
    RegistrationStatus.values,
  );
}

class HouseholdData extends DataClass implements Insertable<HouseholdData> {
  final int household_id;
  final String? head;
  final int? address_id;
  final HouseholdTypes? household_type_id;
  final int? building_type_id;
  final OwnershipTypes? ownership_type_id;
  final int? household_members_num;
  final bool? female_mortality;
  final bool? child_mortality;
  final DateTime? registration_date;
  final RegistrationStatus registration_status;
  const HouseholdData({
    required this.household_id,
    this.head,
    this.address_id,
    this.household_type_id,
    this.building_type_id,
    this.ownership_type_id,
    this.household_members_num,
    this.female_mortality,
    this.child_mortality,
    this.registration_date,
    required this.registration_status,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || head != null) {
      map['head'] = Variable<String>(head);
    }
    if (!nullToAbsent || address_id != null) {
      map['address_id'] = Variable<int>(address_id);
    }
    if (!nullToAbsent || household_type_id != null) {
      map['household_type_id'] = Variable<String>(
        $HouseholdsTable.$converterhousehold_type_idn.toSql(household_type_id),
      );
    }
    if (!nullToAbsent || building_type_id != null) {
      map['building_type_id'] = Variable<int>(building_type_id);
    }
    if (!nullToAbsent || ownership_type_id != null) {
      map['ownership_type_id'] = Variable<String>(
        $HouseholdsTable.$converterownership_type_idn.toSql(ownership_type_id),
      );
    }
    if (!nullToAbsent || household_members_num != null) {
      map['household_members_num'] = Variable<int>(household_members_num);
    }
    if (!nullToAbsent || female_mortality != null) {
      map['female_mortality'] = Variable<bool>(female_mortality);
    }
    if (!nullToAbsent || child_mortality != null) {
      map['child_mortality'] = Variable<bool>(child_mortality);
    }
    if (!nullToAbsent || registration_date != null) {
      map['registration_date'] = Variable<DateTime>(registration_date);
    }
    {
      map['registration_status'] = Variable<String>(
        $HouseholdsTable.$converterregistration_status.toSql(
          registration_status,
        ),
      );
    }
    return map;
  }

  HouseholdsCompanion toCompanion(bool nullToAbsent) {
    return HouseholdsCompanion(
      household_id: Value(household_id),
      head: head == null && nullToAbsent ? const Value.absent() : Value(head),
      address_id:
          address_id == null && nullToAbsent
              ? const Value.absent()
              : Value(address_id),
      household_type_id:
          household_type_id == null && nullToAbsent
              ? const Value.absent()
              : Value(household_type_id),
      building_type_id:
          building_type_id == null && nullToAbsent
              ? const Value.absent()
              : Value(building_type_id),
      ownership_type_id:
          ownership_type_id == null && nullToAbsent
              ? const Value.absent()
              : Value(ownership_type_id),
      household_members_num:
          household_members_num == null && nullToAbsent
              ? const Value.absent()
              : Value(household_members_num),
      female_mortality:
          female_mortality == null && nullToAbsent
              ? const Value.absent()
              : Value(female_mortality),
      child_mortality:
          child_mortality == null && nullToAbsent
              ? const Value.absent()
              : Value(child_mortality),
      registration_date:
          registration_date == null && nullToAbsent
              ? const Value.absent()
              : Value(registration_date),
      registration_status: Value(registration_status),
    );
  }

  factory HouseholdData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdData(
      household_id: serializer.fromJson<int>(json['household_id']),
      head: serializer.fromJson<String?>(json['head']),
      address_id: serializer.fromJson<int?>(json['address_id']),
      household_type_id: $HouseholdsTable.$converterhousehold_type_idn.fromJson(
        serializer.fromJson<String?>(json['household_type_id']),
      ),
      building_type_id: serializer.fromJson<int?>(json['building_type_id']),
      ownership_type_id: $HouseholdsTable.$converterownership_type_idn.fromJson(
        serializer.fromJson<String?>(json['ownership_type_id']),
      ),
      household_members_num: serializer.fromJson<int?>(
        json['household_members_num'],
      ),
      female_mortality: serializer.fromJson<bool?>(json['female_mortality']),
      child_mortality: serializer.fromJson<bool?>(json['child_mortality']),
      registration_date: serializer.fromJson<DateTime?>(
        json['registration_date'],
      ),
      registration_status: $HouseholdsTable.$converterregistration_status
          .fromJson(serializer.fromJson<String>(json['registration_status'])),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'household_id': serializer.toJson<int>(household_id),
      'head': serializer.toJson<String?>(head),
      'address_id': serializer.toJson<int?>(address_id),
      'household_type_id': serializer.toJson<String?>(
        $HouseholdsTable.$converterhousehold_type_idn.toJson(household_type_id),
      ),
      'building_type_id': serializer.toJson<int?>(building_type_id),
      'ownership_type_id': serializer.toJson<String?>(
        $HouseholdsTable.$converterownership_type_idn.toJson(ownership_type_id),
      ),
      'household_members_num': serializer.toJson<int?>(household_members_num),
      'female_mortality': serializer.toJson<bool?>(female_mortality),
      'child_mortality': serializer.toJson<bool?>(child_mortality),
      'registration_date': serializer.toJson<DateTime?>(registration_date),
      'registration_status': serializer.toJson<String>(
        $HouseholdsTable.$converterregistration_status.toJson(
          registration_status,
        ),
      ),
    };
  }

  HouseholdData copyWith({
    int? household_id,
    Value<String?> head = const Value.absent(),
    Value<int?> address_id = const Value.absent(),
    Value<HouseholdTypes?> household_type_id = const Value.absent(),
    Value<int?> building_type_id = const Value.absent(),
    Value<OwnershipTypes?> ownership_type_id = const Value.absent(),
    Value<int?> household_members_num = const Value.absent(),
    Value<bool?> female_mortality = const Value.absent(),
    Value<bool?> child_mortality = const Value.absent(),
    Value<DateTime?> registration_date = const Value.absent(),
    RegistrationStatus? registration_status,
  }) => HouseholdData(
    household_id: household_id ?? this.household_id,
    head: head.present ? head.value : this.head,
    address_id: address_id.present ? address_id.value : this.address_id,
    household_type_id:
        household_type_id.present
            ? household_type_id.value
            : this.household_type_id,
    building_type_id:
        building_type_id.present
            ? building_type_id.value
            : this.building_type_id,
    ownership_type_id:
        ownership_type_id.present
            ? ownership_type_id.value
            : this.ownership_type_id,
    household_members_num:
        household_members_num.present
            ? household_members_num.value
            : this.household_members_num,
    female_mortality:
        female_mortality.present
            ? female_mortality.value
            : this.female_mortality,
    child_mortality:
        child_mortality.present ? child_mortality.value : this.child_mortality,
    registration_date:
        registration_date.present
            ? registration_date.value
            : this.registration_date,
    registration_status: registration_status ?? this.registration_status,
  );
  HouseholdData copyWithCompanion(HouseholdsCompanion data) {
    return HouseholdData(
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      head: data.head.present ? data.head.value : this.head,
      address_id:
          data.address_id.present ? data.address_id.value : this.address_id,
      household_type_id:
          data.household_type_id.present
              ? data.household_type_id.value
              : this.household_type_id,
      building_type_id:
          data.building_type_id.present
              ? data.building_type_id.value
              : this.building_type_id,
      ownership_type_id:
          data.ownership_type_id.present
              ? data.ownership_type_id.value
              : this.ownership_type_id,
      household_members_num:
          data.household_members_num.present
              ? data.household_members_num.value
              : this.household_members_num,
      female_mortality:
          data.female_mortality.present
              ? data.female_mortality.value
              : this.female_mortality,
      child_mortality:
          data.child_mortality.present
              ? data.child_mortality.value
              : this.child_mortality,
      registration_date:
          data.registration_date.present
              ? data.registration_date.value
              : this.registration_date,
      registration_status:
          data.registration_status.present
              ? data.registration_status.value
              : this.registration_status,
    );
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdData(')
          ..write('household_id: $household_id, ')
          ..write('head: $head, ')
          ..write('address_id: $address_id, ')
          ..write('household_type_id: $household_type_id, ')
          ..write('building_type_id: $building_type_id, ')
          ..write('ownership_type_id: $ownership_type_id, ')
          ..write('household_members_num: $household_members_num, ')
          ..write('female_mortality: $female_mortality, ')
          ..write('child_mortality: $child_mortality, ')
          ..write('registration_date: $registration_date, ')
          ..write('registration_status: $registration_status')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    household_id,
    head,
    address_id,
    household_type_id,
    building_type_id,
    ownership_type_id,
    household_members_num,
    female_mortality,
    child_mortality,
    registration_date,
    registration_status,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdData &&
          other.household_id == this.household_id &&
          other.head == this.head &&
          other.address_id == this.address_id &&
          other.household_type_id == this.household_type_id &&
          other.building_type_id == this.building_type_id &&
          other.ownership_type_id == this.ownership_type_id &&
          other.household_members_num == this.household_members_num &&
          other.female_mortality == this.female_mortality &&
          other.child_mortality == this.child_mortality &&
          other.registration_date == this.registration_date &&
          other.registration_status == this.registration_status);
}

class HouseholdsCompanion extends UpdateCompanion<HouseholdData> {
  final Value<int> household_id;
  final Value<String?> head;
  final Value<int?> address_id;
  final Value<HouseholdTypes?> household_type_id;
  final Value<int?> building_type_id;
  final Value<OwnershipTypes?> ownership_type_id;
  final Value<int?> household_members_num;
  final Value<bool?> female_mortality;
  final Value<bool?> child_mortality;
  final Value<DateTime?> registration_date;
  final Value<RegistrationStatus> registration_status;
  const HouseholdsCompanion({
    this.household_id = const Value.absent(),
    this.head = const Value.absent(),
    this.address_id = const Value.absent(),
    this.household_type_id = const Value.absent(),
    this.building_type_id = const Value.absent(),
    this.ownership_type_id = const Value.absent(),
    this.household_members_num = const Value.absent(),
    this.female_mortality = const Value.absent(),
    this.child_mortality = const Value.absent(),
    this.registration_date = const Value.absent(),
    this.registration_status = const Value.absent(),
  });
  HouseholdsCompanion.insert({
    this.household_id = const Value.absent(),
    this.head = const Value.absent(),
    this.address_id = const Value.absent(),
    this.household_type_id = const Value.absent(),
    this.building_type_id = const Value.absent(),
    this.ownership_type_id = const Value.absent(),
    this.household_members_num = const Value.absent(),
    this.female_mortality = const Value.absent(),
    this.child_mortality = const Value.absent(),
    this.registration_date = const Value.absent(),
    required RegistrationStatus registration_status,
  }) : registration_status = Value(registration_status);
  static Insertable<HouseholdData> custom({
    Expression<int>? household_id,
    Expression<String>? head,
    Expression<int>? address_id,
    Expression<String>? household_type_id,
    Expression<int>? building_type_id,
    Expression<String>? ownership_type_id,
    Expression<int>? household_members_num,
    Expression<bool>? female_mortality,
    Expression<bool>? child_mortality,
    Expression<DateTime>? registration_date,
    Expression<String>? registration_status,
  }) {
    return RawValuesInsertable({
      if (household_id != null) 'household_id': household_id,
      if (head != null) 'head': head,
      if (address_id != null) 'address_id': address_id,
      if (household_type_id != null) 'household_type_id': household_type_id,
      if (building_type_id != null) 'building_type_id': building_type_id,
      if (ownership_type_id != null) 'ownership_type_id': ownership_type_id,
      if (household_members_num != null)
        'household_members_num': household_members_num,
      if (female_mortality != null) 'female_mortality': female_mortality,
      if (child_mortality != null) 'child_mortality': child_mortality,
      if (registration_date != null) 'registration_date': registration_date,
      if (registration_status != null)
        'registration_status': registration_status,
    });
  }

  HouseholdsCompanion copyWith({
    Value<int>? household_id,
    Value<String?>? head,
    Value<int?>? address_id,
    Value<HouseholdTypes?>? household_type_id,
    Value<int?>? building_type_id,
    Value<OwnershipTypes?>? ownership_type_id,
    Value<int?>? household_members_num,
    Value<bool?>? female_mortality,
    Value<bool?>? child_mortality,
    Value<DateTime?>? registration_date,
    Value<RegistrationStatus>? registration_status,
  }) {
    return HouseholdsCompanion(
      household_id: household_id ?? this.household_id,
      head: head ?? this.head,
      address_id: address_id ?? this.address_id,
      household_type_id: household_type_id ?? this.household_type_id,
      building_type_id: building_type_id ?? this.building_type_id,
      ownership_type_id: ownership_type_id ?? this.ownership_type_id,
      household_members_num:
          household_members_num ?? this.household_members_num,
      female_mortality: female_mortality ?? this.female_mortality,
      child_mortality: child_mortality ?? this.child_mortality,
      registration_date: registration_date ?? this.registration_date,
      registration_status: registration_status ?? this.registration_status,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (head.present) {
      map['head'] = Variable<String>(head.value);
    }
    if (address_id.present) {
      map['address_id'] = Variable<int>(address_id.value);
    }
    if (household_type_id.present) {
      map['household_type_id'] = Variable<String>(
        $HouseholdsTable.$converterhousehold_type_idn.toSql(
          household_type_id.value,
        ),
      );
    }
    if (building_type_id.present) {
      map['building_type_id'] = Variable<int>(building_type_id.value);
    }
    if (ownership_type_id.present) {
      map['ownership_type_id'] = Variable<String>(
        $HouseholdsTable.$converterownership_type_idn.toSql(
          ownership_type_id.value,
        ),
      );
    }
    if (household_members_num.present) {
      map['household_members_num'] = Variable<int>(household_members_num.value);
    }
    if (female_mortality.present) {
      map['female_mortality'] = Variable<bool>(female_mortality.value);
    }
    if (child_mortality.present) {
      map['child_mortality'] = Variable<bool>(child_mortality.value);
    }
    if (registration_date.present) {
      map['registration_date'] = Variable<DateTime>(registration_date.value);
    }
    if (registration_status.present) {
      map['registration_status'] = Variable<String>(
        $HouseholdsTable.$converterregistration_status.toSql(
          registration_status.value,
        ),
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdsCompanion(')
          ..write('household_id: $household_id, ')
          ..write('head: $head, ')
          ..write('address_id: $address_id, ')
          ..write('household_type_id: $household_type_id, ')
          ..write('building_type_id: $building_type_id, ')
          ..write('ownership_type_id: $ownership_type_id, ')
          ..write('household_members_num: $household_members_num, ')
          ..write('female_mortality: $female_mortality, ')
          ..write('child_mortality: $child_mortality, ')
          ..write('registration_date: $registration_date, ')
          ..write('registration_status: $registration_status')
          ..write(')'))
        .toString();
  }
}

class $MonthlyIncomesTable extends MonthlyIncomes
    with TableInfo<$MonthlyIncomesTable, MonthlyIncomeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MonthlyIncomesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _monthly_income_idMeta = const VerificationMeta(
    'monthly_income_id',
  );
  @override
  late final GeneratedColumn<int> monthly_income_id = GeneratedColumn<int>(
    'monthly_income_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _rangeMeta = const VerificationMeta('range');
  @override
  late final GeneratedColumn<String> range = GeneratedColumn<String>(
    'range',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [monthly_income_id, range];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'monthly_incomes';
  @override
  VerificationContext validateIntegrity(
    Insertable<MonthlyIncomeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('monthly_income_id')) {
      context.handle(
        _monthly_income_idMeta,
        monthly_income_id.isAcceptableOrUnknown(
          data['monthly_income_id']!,
          _monthly_income_idMeta,
        ),
      );
    }
    if (data.containsKey('range')) {
      context.handle(
        _rangeMeta,
        range.isAcceptableOrUnknown(data['range']!, _rangeMeta),
      );
    } else if (isInserting) {
      context.missing(_rangeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {monthly_income_id};
  @override
  MonthlyIncomeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MonthlyIncomeData(
      monthly_income_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}monthly_income_id'],
          )!,
      range:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}range'],
          )!,
    );
  }

  @override
  $MonthlyIncomesTable createAlias(String alias) {
    return $MonthlyIncomesTable(attachedDatabase, alias);
  }
}

class MonthlyIncomeData extends DataClass
    implements Insertable<MonthlyIncomeData> {
  final int monthly_income_id;
  final String range;
  const MonthlyIncomeData({
    required this.monthly_income_id,
    required this.range,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['monthly_income_id'] = Variable<int>(monthly_income_id);
    map['range'] = Variable<String>(range);
    return map;
  }

  MonthlyIncomesCompanion toCompanion(bool nullToAbsent) {
    return MonthlyIncomesCompanion(
      monthly_income_id: Value(monthly_income_id),
      range: Value(range),
    );
  }

  factory MonthlyIncomeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MonthlyIncomeData(
      monthly_income_id: serializer.fromJson<int>(json['monthly_income_id']),
      range: serializer.fromJson<String>(json['range']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'monthly_income_id': serializer.toJson<int>(monthly_income_id),
      'range': serializer.toJson<String>(range),
    };
  }

  MonthlyIncomeData copyWith({int? monthly_income_id, String? range}) =>
      MonthlyIncomeData(
        monthly_income_id: monthly_income_id ?? this.monthly_income_id,
        range: range ?? this.range,
      );
  MonthlyIncomeData copyWithCompanion(MonthlyIncomesCompanion data) {
    return MonthlyIncomeData(
      monthly_income_id:
          data.monthly_income_id.present
              ? data.monthly_income_id.value
              : this.monthly_income_id,
      range: data.range.present ? data.range.value : this.range,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MonthlyIncomeData(')
          ..write('monthly_income_id: $monthly_income_id, ')
          ..write('range: $range')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(monthly_income_id, range);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MonthlyIncomeData &&
          other.monthly_income_id == this.monthly_income_id &&
          other.range == this.range);
}

class MonthlyIncomesCompanion extends UpdateCompanion<MonthlyIncomeData> {
  final Value<int> monthly_income_id;
  final Value<String> range;
  const MonthlyIncomesCompanion({
    this.monthly_income_id = const Value.absent(),
    this.range = const Value.absent(),
  });
  MonthlyIncomesCompanion.insert({
    this.monthly_income_id = const Value.absent(),
    required String range,
  }) : range = Value(range);
  static Insertable<MonthlyIncomeData> custom({
    Expression<int>? monthly_income_id,
    Expression<String>? range,
  }) {
    return RawValuesInsertable({
      if (monthly_income_id != null) 'monthly_income_id': monthly_income_id,
      if (range != null) 'range': range,
    });
  }

  MonthlyIncomesCompanion copyWith({
    Value<int>? monthly_income_id,
    Value<String>? range,
  }) {
    return MonthlyIncomesCompanion(
      monthly_income_id: monthly_income_id ?? this.monthly_income_id,
      range: range ?? this.range,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (monthly_income_id.present) {
      map['monthly_income_id'] = Variable<int>(monthly_income_id.value);
    }
    if (range.present) {
      map['range'] = Variable<String>(range.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MonthlyIncomesCompanion(')
          ..write('monthly_income_id: $monthly_income_id, ')
          ..write('range: $range')
          ..write(')'))
        .toString();
  }
}

class $DailyIncomesTable extends DailyIncomes
    with TableInfo<$DailyIncomesTable, DailyIncomeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DailyIncomesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _daily_income_idMeta = const VerificationMeta(
    'daily_income_id',
  );
  @override
  late final GeneratedColumn<int> daily_income_id = GeneratedColumn<int>(
    'daily_income_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _rangeMeta = const VerificationMeta('range');
  @override
  late final GeneratedColumn<String> range = GeneratedColumn<String>(
    'range',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [daily_income_id, range];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'daily_incomes';
  @override
  VerificationContext validateIntegrity(
    Insertable<DailyIncomeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('daily_income_id')) {
      context.handle(
        _daily_income_idMeta,
        daily_income_id.isAcceptableOrUnknown(
          data['daily_income_id']!,
          _daily_income_idMeta,
        ),
      );
    }
    if (data.containsKey('range')) {
      context.handle(
        _rangeMeta,
        range.isAcceptableOrUnknown(data['range']!, _rangeMeta),
      );
    } else if (isInserting) {
      context.missing(_rangeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {daily_income_id};
  @override
  DailyIncomeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DailyIncomeData(
      daily_income_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}daily_income_id'],
          )!,
      range:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}range'],
          )!,
    );
  }

  @override
  $DailyIncomesTable createAlias(String alias) {
    return $DailyIncomesTable(attachedDatabase, alias);
  }
}

class DailyIncomeData extends DataClass implements Insertable<DailyIncomeData> {
  final int daily_income_id;
  final String range;
  const DailyIncomeData({required this.daily_income_id, required this.range});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['daily_income_id'] = Variable<int>(daily_income_id);
    map['range'] = Variable<String>(range);
    return map;
  }

  DailyIncomesCompanion toCompanion(bool nullToAbsent) {
    return DailyIncomesCompanion(
      daily_income_id: Value(daily_income_id),
      range: Value(range),
    );
  }

  factory DailyIncomeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DailyIncomeData(
      daily_income_id: serializer.fromJson<int>(json['daily_income_id']),
      range: serializer.fromJson<String>(json['range']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'daily_income_id': serializer.toJson<int>(daily_income_id),
      'range': serializer.toJson<String>(range),
    };
  }

  DailyIncomeData copyWith({int? daily_income_id, String? range}) =>
      DailyIncomeData(
        daily_income_id: daily_income_id ?? this.daily_income_id,
        range: range ?? this.range,
      );
  DailyIncomeData copyWithCompanion(DailyIncomesCompanion data) {
    return DailyIncomeData(
      daily_income_id:
          data.daily_income_id.present
              ? data.daily_income_id.value
              : this.daily_income_id,
      range: data.range.present ? data.range.value : this.range,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DailyIncomeData(')
          ..write('daily_income_id: $daily_income_id, ')
          ..write('range: $range')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(daily_income_id, range);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DailyIncomeData &&
          other.daily_income_id == this.daily_income_id &&
          other.range == this.range);
}

class DailyIncomesCompanion extends UpdateCompanion<DailyIncomeData> {
  final Value<int> daily_income_id;
  final Value<String> range;
  const DailyIncomesCompanion({
    this.daily_income_id = const Value.absent(),
    this.range = const Value.absent(),
  });
  DailyIncomesCompanion.insert({
    this.daily_income_id = const Value.absent(),
    required String range,
  }) : range = Value(range);
  static Insertable<DailyIncomeData> custom({
    Expression<int>? daily_income_id,
    Expression<String>? range,
  }) {
    return RawValuesInsertable({
      if (daily_income_id != null) 'daily_income_id': daily_income_id,
      if (range != null) 'range': range,
    });
  }

  DailyIncomesCompanion copyWith({
    Value<int>? daily_income_id,
    Value<String>? range,
  }) {
    return DailyIncomesCompanion(
      daily_income_id: daily_income_id ?? this.daily_income_id,
      range: range ?? this.range,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (daily_income_id.present) {
      map['daily_income_id'] = Variable<int>(daily_income_id.value);
    }
    if (range.present) {
      map['range'] = Variable<String>(range.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DailyIncomesCompanion(')
          ..write('daily_income_id: $daily_income_id, ')
          ..write('range: $range')
          ..write(')'))
        .toString();
  }
}

class $EducationTable extends Education
    with TableInfo<$EducationTable, EducationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EducationTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _education_idMeta = const VerificationMeta(
    'education_id',
  );
  @override
  late final GeneratedColumn<int> education_id = GeneratedColumn<int>(
    'education_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _levelMeta = const VerificationMeta('level');
  @override
  late final GeneratedColumn<String> level = GeneratedColumn<String>(
    'level',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [education_id, level];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'education';
  @override
  VerificationContext validateIntegrity(
    Insertable<EducationData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('education_id')) {
      context.handle(
        _education_idMeta,
        education_id.isAcceptableOrUnknown(
          data['education_id']!,
          _education_idMeta,
        ),
      );
    }
    if (data.containsKey('level')) {
      context.handle(
        _levelMeta,
        level.isAcceptableOrUnknown(data['level']!, _levelMeta),
      );
    } else if (isInserting) {
      context.missing(_levelMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {education_id};
  @override
  EducationData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EducationData(
      education_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}education_id'],
          )!,
      level:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}level'],
          )!,
    );
  }

  @override
  $EducationTable createAlias(String alias) {
    return $EducationTable(attachedDatabase, alias);
  }
}

class EducationData extends DataClass implements Insertable<EducationData> {
  final int education_id;
  final String level;
  const EducationData({required this.education_id, required this.level});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['education_id'] = Variable<int>(education_id);
    map['level'] = Variable<String>(level);
    return map;
  }

  EducationCompanion toCompanion(bool nullToAbsent) {
    return EducationCompanion(
      education_id: Value(education_id),
      level: Value(level),
    );
  }

  factory EducationData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EducationData(
      education_id: serializer.fromJson<int>(json['education_id']),
      level: serializer.fromJson<String>(json['level']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'education_id': serializer.toJson<int>(education_id),
      'level': serializer.toJson<String>(level),
    };
  }

  EducationData copyWith({int? education_id, String? level}) => EducationData(
    education_id: education_id ?? this.education_id,
    level: level ?? this.level,
  );
  EducationData copyWithCompanion(EducationCompanion data) {
    return EducationData(
      education_id:
          data.education_id.present
              ? data.education_id.value
              : this.education_id,
      level: data.level.present ? data.level.value : this.level,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EducationData(')
          ..write('education_id: $education_id, ')
          ..write('level: $level')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(education_id, level);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EducationData &&
          other.education_id == this.education_id &&
          other.level == this.level);
}

class EducationCompanion extends UpdateCompanion<EducationData> {
  final Value<int> education_id;
  final Value<String> level;
  const EducationCompanion({
    this.education_id = const Value.absent(),
    this.level = const Value.absent(),
  });
  EducationCompanion.insert({
    this.education_id = const Value.absent(),
    required String level,
  }) : level = Value(level);
  static Insertable<EducationData> custom({
    Expression<int>? education_id,
    Expression<String>? level,
  }) {
    return RawValuesInsertable({
      if (education_id != null) 'education_id': education_id,
      if (level != null) 'level': level,
    });
  }

  EducationCompanion copyWith({
    Value<int>? education_id,
    Value<String>? level,
  }) {
    return EducationCompanion(
      education_id: education_id ?? this.education_id,
      level: level ?? this.level,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (education_id.present) {
      map['education_id'] = Variable<int>(education_id.value);
    }
    if (level.present) {
      map['level'] = Variable<String>(level.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EducationCompanion(')
          ..write('education_id: $education_id, ')
          ..write('level: $level')
          ..write(')'))
        .toString();
  }
}

class $PersonsTable extends Persons with TableInfo<$PersonsTable, PersonData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PersonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _last_nameMeta = const VerificationMeta(
    'last_name',
  );
  @override
  late final GeneratedColumn<String> last_name = GeneratedColumn<String>(
    'last_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _first_nameMeta = const VerificationMeta(
    'first_name',
  );
  @override
  late final GeneratedColumn<String> first_name = GeneratedColumn<String>(
    'first_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _middle_nameMeta = const VerificationMeta(
    'middle_name',
  );
  @override
  late final GeneratedColumn<String> middle_name = GeneratedColumn<String>(
    'middle_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _suffixMeta = const VerificationMeta('suffix');
  @override
  late final GeneratedColumn<String> suffix = GeneratedColumn<String>(
    'suffix',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Sex?, String> sex =
      GeneratedColumn<String>(
        'sex',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Sex?>($PersonsTable.$convertersexn);
  static const VerificationMeta _ageMeta = const VerificationMeta('age');
  @override
  late final GeneratedColumn<int> age = GeneratedColumn<int>(
    'age',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _birth_dateMeta = const VerificationMeta(
    'birth_date',
  );
  @override
  late final GeneratedColumn<DateTime> birth_date = GeneratedColumn<DateTime>(
    'birth_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _birth_placeMeta = const VerificationMeta(
    'birth_place',
  );
  @override
  late final GeneratedColumn<String> birth_place = GeneratedColumn<String>(
    'birth_place',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<CivilStatus?, String>
  civil_status = GeneratedColumn<String>(
    'civil_status',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<CivilStatus?>($PersonsTable.$convertercivil_statusn);
  static const VerificationMeta _religion_idMeta = const VerificationMeta(
    'religion_id',
  );
  @override
  late final GeneratedColumn<int> religion_id = GeneratedColumn<int>(
    'religion_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES religions (religion_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _nationality_idMeta = const VerificationMeta(
    'nationality_id',
  );
  @override
  late final GeneratedColumn<int> nationality_id = GeneratedColumn<int>(
    'nationality_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES nationalities (nationality_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _ethnicity_idMeta = const VerificationMeta(
    'ethnicity_id',
  );
  @override
  late final GeneratedColumn<int> ethnicity_id = GeneratedColumn<int>(
    'ethnicity_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES ethnicities (ethnicity_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _blood_type_idMeta = const VerificationMeta(
    'blood_type_id',
  );
  @override
  late final GeneratedColumn<int> blood_type_id = GeneratedColumn<int>(
    'blood_type_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES blood_types (blood_type_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _address_idMeta = const VerificationMeta(
    'address_id',
  );
  @override
  late final GeneratedColumn<int> address_id = GeneratedColumn<int>(
    'address_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES addresses (address_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _registration_placeMeta =
      const VerificationMeta('registration_place');
  @override
  late final GeneratedColumn<String> registration_place =
      GeneratedColumn<String>(
        'registration_place',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  late final GeneratedColumnWithTypeConverter<Residency?, String> residency =
      GeneratedColumn<String>(
        'residency',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Residency?>($PersonsTable.$converterresidencyn);
  static const VerificationMeta _years_of_residencyMeta =
      const VerificationMeta('years_of_residency');
  @override
  late final GeneratedColumn<int> years_of_residency = GeneratedColumn<int>(
    'years_of_residency',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Transient?, String>
  transient_type = GeneratedColumn<String>(
    'transient_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Transient?>($PersonsTable.$convertertransient_typen);
  static const VerificationMeta _monthly_income_idMeta = const VerificationMeta(
    'monthly_income_id',
  );
  @override
  late final GeneratedColumn<int> monthly_income_id = GeneratedColumn<int>(
    'monthly_income_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES monthly_incomes (monthly_income_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _daily_income_idMeta = const VerificationMeta(
    'daily_income_id',
  );
  @override
  late final GeneratedColumn<int> daily_income_id = GeneratedColumn<int>(
    'daily_income_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES daily_incomes (daily_income_id) ON DELETE RESTRICT',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<SoloParent?, String> solo_parent =
      GeneratedColumn<String>(
        'solo_parent',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<SoloParent?>($PersonsTable.$convertersolo_parentn);
  static const VerificationMeta _ofwMeta = const VerificationMeta('ofw');
  @override
  late final GeneratedColumn<bool> ofw = GeneratedColumn<bool>(
    'ofw',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("ofw" IN (0, 1))',
    ),
  );
  static const VerificationMeta _literateMeta = const VerificationMeta(
    'literate',
  );
  @override
  late final GeneratedColumn<bool> literate = GeneratedColumn<bool>(
    'literate',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("literate" IN (0, 1))',
    ),
  );
  static const VerificationMeta _pwdMeta = const VerificationMeta('pwd');
  @override
  late final GeneratedColumn<bool> pwd = GeneratedColumn<bool>(
    'pwd',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("pwd" IN (0, 1))',
    ),
  );
  static const VerificationMeta _registered_voterMeta = const VerificationMeta(
    'registered_voter',
  );
  @override
  late final GeneratedColumn<bool> registered_voter = GeneratedColumn<bool>(
    'registered_voter',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("registered_voter" IN (0, 1))',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<CurrentlyEnrolled?, String>
  currently_enrolled = GeneratedColumn<String>(
    'currently_enrolled',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<CurrentlyEnrolled?>(
    $PersonsTable.$convertercurrently_enrolledn,
  );
  static const VerificationMeta _education_idMeta = const VerificationMeta(
    'education_id',
  );
  @override
  late final GeneratedColumn<int> education_id = GeneratedColumn<int>(
    'education_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES education (education_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _deceasedMeta = const VerificationMeta(
    'deceased',
  );
  @override
  late final GeneratedColumn<bool> deceased = GeneratedColumn<bool>(
    'deceased',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("deceased" IN (0, 1))',
    ),
  );
  static const VerificationMeta _death_dateMeta = const VerificationMeta(
    'death_date',
  );
  @override
  late final GeneratedColumn<DateTime> death_date = GeneratedColumn<DateTime>(
    'death_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _registration_dateMeta = const VerificationMeta(
    'registration_date',
  );
  @override
  late final GeneratedColumn<DateTime> registration_date =
      GeneratedColumn<DateTime>(
        'registration_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  late final GeneratedColumnWithTypeConverter<RegistrationStatus, String>
  registration_status = GeneratedColumn<String>(
    'registration_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  ).withConverter<RegistrationStatus>(
    $PersonsTable.$converterregistration_status,
  );
  @override
  List<GeneratedColumn> get $columns => [
    person_id,
    last_name,
    first_name,
    middle_name,
    suffix,
    sex,
    age,
    birth_date,
    birth_place,
    civil_status,
    religion_id,
    nationality_id,
    ethnicity_id,
    blood_type_id,
    household_id,
    address_id,
    registration_place,
    residency,
    years_of_residency,
    transient_type,
    monthly_income_id,
    daily_income_id,
    solo_parent,
    ofw,
    literate,
    pwd,
    registered_voter,
    currently_enrolled,
    education_id,
    deceased,
    death_date,
    registration_date,
    registration_status,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'persons';
  @override
  VerificationContext validateIntegrity(
    Insertable<PersonData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    }
    if (data.containsKey('last_name')) {
      context.handle(
        _last_nameMeta,
        last_name.isAcceptableOrUnknown(data['last_name']!, _last_nameMeta),
      );
    } else if (isInserting) {
      context.missing(_last_nameMeta);
    }
    if (data.containsKey('first_name')) {
      context.handle(
        _first_nameMeta,
        first_name.isAcceptableOrUnknown(data['first_name']!, _first_nameMeta),
      );
    } else if (isInserting) {
      context.missing(_first_nameMeta);
    }
    if (data.containsKey('middle_name')) {
      context.handle(
        _middle_nameMeta,
        middle_name.isAcceptableOrUnknown(
          data['middle_name']!,
          _middle_nameMeta,
        ),
      );
    }
    if (data.containsKey('suffix')) {
      context.handle(
        _suffixMeta,
        suffix.isAcceptableOrUnknown(data['suffix']!, _suffixMeta),
      );
    }
    if (data.containsKey('age')) {
      context.handle(
        _ageMeta,
        age.isAcceptableOrUnknown(data['age']!, _ageMeta),
      );
    }
    if (data.containsKey('birth_date')) {
      context.handle(
        _birth_dateMeta,
        birth_date.isAcceptableOrUnknown(data['birth_date']!, _birth_dateMeta),
      );
    }
    if (data.containsKey('birth_place')) {
      context.handle(
        _birth_placeMeta,
        birth_place.isAcceptableOrUnknown(
          data['birth_place']!,
          _birth_placeMeta,
        ),
      );
    }
    if (data.containsKey('religion_id')) {
      context.handle(
        _religion_idMeta,
        religion_id.isAcceptableOrUnknown(
          data['religion_id']!,
          _religion_idMeta,
        ),
      );
    }
    if (data.containsKey('nationality_id')) {
      context.handle(
        _nationality_idMeta,
        nationality_id.isAcceptableOrUnknown(
          data['nationality_id']!,
          _nationality_idMeta,
        ),
      );
    }
    if (data.containsKey('ethnicity_id')) {
      context.handle(
        _ethnicity_idMeta,
        ethnicity_id.isAcceptableOrUnknown(
          data['ethnicity_id']!,
          _ethnicity_idMeta,
        ),
      );
    }
    if (data.containsKey('blood_type_id')) {
      context.handle(
        _blood_type_idMeta,
        blood_type_id.isAcceptableOrUnknown(
          data['blood_type_id']!,
          _blood_type_idMeta,
        ),
      );
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    }
    if (data.containsKey('address_id')) {
      context.handle(
        _address_idMeta,
        address_id.isAcceptableOrUnknown(data['address_id']!, _address_idMeta),
      );
    }
    if (data.containsKey('registration_place')) {
      context.handle(
        _registration_placeMeta,
        registration_place.isAcceptableOrUnknown(
          data['registration_place']!,
          _registration_placeMeta,
        ),
      );
    }
    if (data.containsKey('years_of_residency')) {
      context.handle(
        _years_of_residencyMeta,
        years_of_residency.isAcceptableOrUnknown(
          data['years_of_residency']!,
          _years_of_residencyMeta,
        ),
      );
    }
    if (data.containsKey('monthly_income_id')) {
      context.handle(
        _monthly_income_idMeta,
        monthly_income_id.isAcceptableOrUnknown(
          data['monthly_income_id']!,
          _monthly_income_idMeta,
        ),
      );
    }
    if (data.containsKey('daily_income_id')) {
      context.handle(
        _daily_income_idMeta,
        daily_income_id.isAcceptableOrUnknown(
          data['daily_income_id']!,
          _daily_income_idMeta,
        ),
      );
    }
    if (data.containsKey('ofw')) {
      context.handle(
        _ofwMeta,
        ofw.isAcceptableOrUnknown(data['ofw']!, _ofwMeta),
      );
    }
    if (data.containsKey('literate')) {
      context.handle(
        _literateMeta,
        literate.isAcceptableOrUnknown(data['literate']!, _literateMeta),
      );
    }
    if (data.containsKey('pwd')) {
      context.handle(
        _pwdMeta,
        pwd.isAcceptableOrUnknown(data['pwd']!, _pwdMeta),
      );
    }
    if (data.containsKey('registered_voter')) {
      context.handle(
        _registered_voterMeta,
        registered_voter.isAcceptableOrUnknown(
          data['registered_voter']!,
          _registered_voterMeta,
        ),
      );
    }
    if (data.containsKey('education_id')) {
      context.handle(
        _education_idMeta,
        education_id.isAcceptableOrUnknown(
          data['education_id']!,
          _education_idMeta,
        ),
      );
    }
    if (data.containsKey('deceased')) {
      context.handle(
        _deceasedMeta,
        deceased.isAcceptableOrUnknown(data['deceased']!, _deceasedMeta),
      );
    }
    if (data.containsKey('death_date')) {
      context.handle(
        _death_dateMeta,
        death_date.isAcceptableOrUnknown(data['death_date']!, _death_dateMeta),
      );
    }
    if (data.containsKey('registration_date')) {
      context.handle(
        _registration_dateMeta,
        registration_date.isAcceptableOrUnknown(
          data['registration_date']!,
          _registration_dateMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {person_id};
  @override
  PersonData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PersonData(
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      last_name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}last_name'],
          )!,
      first_name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}first_name'],
          )!,
      middle_name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}middle_name'],
      ),
      suffix: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}suffix'],
      ),
      sex: $PersonsTable.$convertersexn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}sex'],
        ),
      ),
      age: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}age'],
      ),
      birth_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}birth_date'],
      ),
      birth_place: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}birth_place'],
      ),
      civil_status: $PersonsTable.$convertercivil_statusn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}civil_status'],
        ),
      ),
      religion_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}religion_id'],
      ),
      nationality_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}nationality_id'],
      ),
      ethnicity_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}ethnicity_id'],
      ),
      blood_type_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}blood_type_id'],
      ),
      household_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}household_id'],
      ),
      address_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}address_id'],
      ),
      registration_place: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}registration_place'],
      ),
      residency: $PersonsTable.$converterresidencyn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}residency'],
        ),
      ),
      years_of_residency: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}years_of_residency'],
      ),
      transient_type: $PersonsTable.$convertertransient_typen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}transient_type'],
        ),
      ),
      monthly_income_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}monthly_income_id'],
      ),
      daily_income_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}daily_income_id'],
      ),
      solo_parent: $PersonsTable.$convertersolo_parentn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}solo_parent'],
        ),
      ),
      ofw: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}ofw'],
      ),
      literate: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}literate'],
      ),
      pwd: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}pwd'],
      ),
      registered_voter: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}registered_voter'],
      ),
      currently_enrolled: $PersonsTable.$convertercurrently_enrolledn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}currently_enrolled'],
        ),
      ),
      education_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}education_id'],
      ),
      deceased: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}deceased'],
      ),
      death_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}death_date'],
      ),
      registration_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}registration_date'],
      ),
      registration_status: $PersonsTable.$converterregistration_status.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}registration_status'],
        )!,
      ),
    );
  }

  @override
  $PersonsTable createAlias(String alias) {
    return $PersonsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<Sex, String, String> $convertersex =
      const EnumNameConverter<Sex>(Sex.values);
  static JsonTypeConverter2<Sex?, String?, String?> $convertersexn =
      JsonTypeConverter2.asNullable($convertersex);
  static JsonTypeConverter2<CivilStatus, String, String>
  $convertercivil_status = const EnumNameConverter<CivilStatus>(
    CivilStatus.values,
  );
  static JsonTypeConverter2<CivilStatus?, String?, String?>
  $convertercivil_statusn = JsonTypeConverter2.asNullable(
    $convertercivil_status,
  );
  static JsonTypeConverter2<Residency, String, String> $converterresidency =
      const EnumNameConverter<Residency>(Residency.values);
  static JsonTypeConverter2<Residency?, String?, String?> $converterresidencyn =
      JsonTypeConverter2.asNullable($converterresidency);
  static JsonTypeConverter2<Transient, String, String>
  $convertertransient_type = const EnumNameConverter<Transient>(
    Transient.values,
  );
  static JsonTypeConverter2<Transient?, String?, String?>
  $convertertransient_typen = JsonTypeConverter2.asNullable(
    $convertertransient_type,
  );
  static JsonTypeConverter2<SoloParent, String, String> $convertersolo_parent =
      const EnumNameConverter<SoloParent>(SoloParent.values);
  static JsonTypeConverter2<SoloParent?, String?, String?>
  $convertersolo_parentn = JsonTypeConverter2.asNullable($convertersolo_parent);
  static JsonTypeConverter2<CurrentlyEnrolled, String, String>
  $convertercurrently_enrolled = const EnumNameConverter<CurrentlyEnrolled>(
    CurrentlyEnrolled.values,
  );
  static JsonTypeConverter2<CurrentlyEnrolled?, String?, String?>
  $convertercurrently_enrolledn = JsonTypeConverter2.asNullable(
    $convertercurrently_enrolled,
  );
  static JsonTypeConverter2<RegistrationStatus, String, String>
  $converterregistration_status = const EnumNameConverter<RegistrationStatus>(
    RegistrationStatus.values,
  );
}

class PersonData extends DataClass implements Insertable<PersonData> {
  final int person_id;
  final String last_name;
  final String first_name;
  final String? middle_name;
  final String? suffix;
  final Sex? sex;
  final int? age;
  final DateTime? birth_date;
  final String? birth_place;
  final CivilStatus? civil_status;
  final int? religion_id;
  final int? nationality_id;
  final int? ethnicity_id;
  final int? blood_type_id;
  final int? household_id;
  final int? address_id;
  final String? registration_place;
  final Residency? residency;
  final int? years_of_residency;
  final Transient? transient_type;
  final int? monthly_income_id;
  final int? daily_income_id;
  final SoloParent? solo_parent;
  final bool? ofw;
  final bool? literate;
  final bool? pwd;
  final bool? registered_voter;
  final CurrentlyEnrolled? currently_enrolled;
  final int? education_id;
  final bool? deceased;
  final DateTime? death_date;
  final DateTime? registration_date;
  final RegistrationStatus registration_status;
  const PersonData({
    required this.person_id,
    required this.last_name,
    required this.first_name,
    this.middle_name,
    this.suffix,
    this.sex,
    this.age,
    this.birth_date,
    this.birth_place,
    this.civil_status,
    this.religion_id,
    this.nationality_id,
    this.ethnicity_id,
    this.blood_type_id,
    this.household_id,
    this.address_id,
    this.registration_place,
    this.residency,
    this.years_of_residency,
    this.transient_type,
    this.monthly_income_id,
    this.daily_income_id,
    this.solo_parent,
    this.ofw,
    this.literate,
    this.pwd,
    this.registered_voter,
    this.currently_enrolled,
    this.education_id,
    this.deceased,
    this.death_date,
    this.registration_date,
    required this.registration_status,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['person_id'] = Variable<int>(person_id);
    map['last_name'] = Variable<String>(last_name);
    map['first_name'] = Variable<String>(first_name);
    if (!nullToAbsent || middle_name != null) {
      map['middle_name'] = Variable<String>(middle_name);
    }
    if (!nullToAbsent || suffix != null) {
      map['suffix'] = Variable<String>(suffix);
    }
    if (!nullToAbsent || sex != null) {
      map['sex'] = Variable<String>($PersonsTable.$convertersexn.toSql(sex));
    }
    if (!nullToAbsent || age != null) {
      map['age'] = Variable<int>(age);
    }
    if (!nullToAbsent || birth_date != null) {
      map['birth_date'] = Variable<DateTime>(birth_date);
    }
    if (!nullToAbsent || birth_place != null) {
      map['birth_place'] = Variable<String>(birth_place);
    }
    if (!nullToAbsent || civil_status != null) {
      map['civil_status'] = Variable<String>(
        $PersonsTable.$convertercivil_statusn.toSql(civil_status),
      );
    }
    if (!nullToAbsent || religion_id != null) {
      map['religion_id'] = Variable<int>(religion_id);
    }
    if (!nullToAbsent || nationality_id != null) {
      map['nationality_id'] = Variable<int>(nationality_id);
    }
    if (!nullToAbsent || ethnicity_id != null) {
      map['ethnicity_id'] = Variable<int>(ethnicity_id);
    }
    if (!nullToAbsent || blood_type_id != null) {
      map['blood_type_id'] = Variable<int>(blood_type_id);
    }
    if (!nullToAbsent || household_id != null) {
      map['household_id'] = Variable<int>(household_id);
    }
    if (!nullToAbsent || address_id != null) {
      map['address_id'] = Variable<int>(address_id);
    }
    if (!nullToAbsent || registration_place != null) {
      map['registration_place'] = Variable<String>(registration_place);
    }
    if (!nullToAbsent || residency != null) {
      map['residency'] = Variable<String>(
        $PersonsTable.$converterresidencyn.toSql(residency),
      );
    }
    if (!nullToAbsent || years_of_residency != null) {
      map['years_of_residency'] = Variable<int>(years_of_residency);
    }
    if (!nullToAbsent || transient_type != null) {
      map['transient_type'] = Variable<String>(
        $PersonsTable.$convertertransient_typen.toSql(transient_type),
      );
    }
    if (!nullToAbsent || monthly_income_id != null) {
      map['monthly_income_id'] = Variable<int>(monthly_income_id);
    }
    if (!nullToAbsent || daily_income_id != null) {
      map['daily_income_id'] = Variable<int>(daily_income_id);
    }
    if (!nullToAbsent || solo_parent != null) {
      map['solo_parent'] = Variable<String>(
        $PersonsTable.$convertersolo_parentn.toSql(solo_parent),
      );
    }
    if (!nullToAbsent || ofw != null) {
      map['ofw'] = Variable<bool>(ofw);
    }
    if (!nullToAbsent || literate != null) {
      map['literate'] = Variable<bool>(literate);
    }
    if (!nullToAbsent || pwd != null) {
      map['pwd'] = Variable<bool>(pwd);
    }
    if (!nullToAbsent || registered_voter != null) {
      map['registered_voter'] = Variable<bool>(registered_voter);
    }
    if (!nullToAbsent || currently_enrolled != null) {
      map['currently_enrolled'] = Variable<String>(
        $PersonsTable.$convertercurrently_enrolledn.toSql(currently_enrolled),
      );
    }
    if (!nullToAbsent || education_id != null) {
      map['education_id'] = Variable<int>(education_id);
    }
    if (!nullToAbsent || deceased != null) {
      map['deceased'] = Variable<bool>(deceased);
    }
    if (!nullToAbsent || death_date != null) {
      map['death_date'] = Variable<DateTime>(death_date);
    }
    if (!nullToAbsent || registration_date != null) {
      map['registration_date'] = Variable<DateTime>(registration_date);
    }
    {
      map['registration_status'] = Variable<String>(
        $PersonsTable.$converterregistration_status.toSql(registration_status),
      );
    }
    return map;
  }

  PersonsCompanion toCompanion(bool nullToAbsent) {
    return PersonsCompanion(
      person_id: Value(person_id),
      last_name: Value(last_name),
      first_name: Value(first_name),
      middle_name:
          middle_name == null && nullToAbsent
              ? const Value.absent()
              : Value(middle_name),
      suffix:
          suffix == null && nullToAbsent ? const Value.absent() : Value(suffix),
      sex: sex == null && nullToAbsent ? const Value.absent() : Value(sex),
      age: age == null && nullToAbsent ? const Value.absent() : Value(age),
      birth_date:
          birth_date == null && nullToAbsent
              ? const Value.absent()
              : Value(birth_date),
      birth_place:
          birth_place == null && nullToAbsent
              ? const Value.absent()
              : Value(birth_place),
      civil_status:
          civil_status == null && nullToAbsent
              ? const Value.absent()
              : Value(civil_status),
      religion_id:
          religion_id == null && nullToAbsent
              ? const Value.absent()
              : Value(religion_id),
      nationality_id:
          nationality_id == null && nullToAbsent
              ? const Value.absent()
              : Value(nationality_id),
      ethnicity_id:
          ethnicity_id == null && nullToAbsent
              ? const Value.absent()
              : Value(ethnicity_id),
      blood_type_id:
          blood_type_id == null && nullToAbsent
              ? const Value.absent()
              : Value(blood_type_id),
      household_id:
          household_id == null && nullToAbsent
              ? const Value.absent()
              : Value(household_id),
      address_id:
          address_id == null && nullToAbsent
              ? const Value.absent()
              : Value(address_id),
      registration_place:
          registration_place == null && nullToAbsent
              ? const Value.absent()
              : Value(registration_place),
      residency:
          residency == null && nullToAbsent
              ? const Value.absent()
              : Value(residency),
      years_of_residency:
          years_of_residency == null && nullToAbsent
              ? const Value.absent()
              : Value(years_of_residency),
      transient_type:
          transient_type == null && nullToAbsent
              ? const Value.absent()
              : Value(transient_type),
      monthly_income_id:
          monthly_income_id == null && nullToAbsent
              ? const Value.absent()
              : Value(monthly_income_id),
      daily_income_id:
          daily_income_id == null && nullToAbsent
              ? const Value.absent()
              : Value(daily_income_id),
      solo_parent:
          solo_parent == null && nullToAbsent
              ? const Value.absent()
              : Value(solo_parent),
      ofw: ofw == null && nullToAbsent ? const Value.absent() : Value(ofw),
      literate:
          literate == null && nullToAbsent
              ? const Value.absent()
              : Value(literate),
      pwd: pwd == null && nullToAbsent ? const Value.absent() : Value(pwd),
      registered_voter:
          registered_voter == null && nullToAbsent
              ? const Value.absent()
              : Value(registered_voter),
      currently_enrolled:
          currently_enrolled == null && nullToAbsent
              ? const Value.absent()
              : Value(currently_enrolled),
      education_id:
          education_id == null && nullToAbsent
              ? const Value.absent()
              : Value(education_id),
      deceased:
          deceased == null && nullToAbsent
              ? const Value.absent()
              : Value(deceased),
      death_date:
          death_date == null && nullToAbsent
              ? const Value.absent()
              : Value(death_date),
      registration_date:
          registration_date == null && nullToAbsent
              ? const Value.absent()
              : Value(registration_date),
      registration_status: Value(registration_status),
    );
  }

  factory PersonData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PersonData(
      person_id: serializer.fromJson<int>(json['person_id']),
      last_name: serializer.fromJson<String>(json['last_name']),
      first_name: serializer.fromJson<String>(json['first_name']),
      middle_name: serializer.fromJson<String?>(json['middle_name']),
      suffix: serializer.fromJson<String?>(json['suffix']),
      sex: $PersonsTable.$convertersexn.fromJson(
        serializer.fromJson<String?>(json['sex']),
      ),
      age: serializer.fromJson<int?>(json['age']),
      birth_date: serializer.fromJson<DateTime?>(json['birth_date']),
      birth_place: serializer.fromJson<String?>(json['birth_place']),
      civil_status: $PersonsTable.$convertercivil_statusn.fromJson(
        serializer.fromJson<String?>(json['civil_status']),
      ),
      religion_id: serializer.fromJson<int?>(json['religion_id']),
      nationality_id: serializer.fromJson<int?>(json['nationality_id']),
      ethnicity_id: serializer.fromJson<int?>(json['ethnicity_id']),
      blood_type_id: serializer.fromJson<int?>(json['blood_type_id']),
      household_id: serializer.fromJson<int?>(json['household_id']),
      address_id: serializer.fromJson<int?>(json['address_id']),
      registration_place: serializer.fromJson<String?>(
        json['registration_place'],
      ),
      residency: $PersonsTable.$converterresidencyn.fromJson(
        serializer.fromJson<String?>(json['residency']),
      ),
      years_of_residency: serializer.fromJson<int?>(json['years_of_residency']),
      transient_type: $PersonsTable.$convertertransient_typen.fromJson(
        serializer.fromJson<String?>(json['transient_type']),
      ),
      monthly_income_id: serializer.fromJson<int?>(json['monthly_income_id']),
      daily_income_id: serializer.fromJson<int?>(json['daily_income_id']),
      solo_parent: $PersonsTable.$convertersolo_parentn.fromJson(
        serializer.fromJson<String?>(json['solo_parent']),
      ),
      ofw: serializer.fromJson<bool?>(json['ofw']),
      literate: serializer.fromJson<bool?>(json['literate']),
      pwd: serializer.fromJson<bool?>(json['pwd']),
      registered_voter: serializer.fromJson<bool?>(json['registered_voter']),
      currently_enrolled: $PersonsTable.$convertercurrently_enrolledn.fromJson(
        serializer.fromJson<String?>(json['currently_enrolled']),
      ),
      education_id: serializer.fromJson<int?>(json['education_id']),
      deceased: serializer.fromJson<bool?>(json['deceased']),
      death_date: serializer.fromJson<DateTime?>(json['death_date']),
      registration_date: serializer.fromJson<DateTime?>(
        json['registration_date'],
      ),
      registration_status: $PersonsTable.$converterregistration_status.fromJson(
        serializer.fromJson<String>(json['registration_status']),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'person_id': serializer.toJson<int>(person_id),
      'last_name': serializer.toJson<String>(last_name),
      'first_name': serializer.toJson<String>(first_name),
      'middle_name': serializer.toJson<String?>(middle_name),
      'suffix': serializer.toJson<String?>(suffix),
      'sex': serializer.toJson<String?>(
        $PersonsTable.$convertersexn.toJson(sex),
      ),
      'age': serializer.toJson<int?>(age),
      'birth_date': serializer.toJson<DateTime?>(birth_date),
      'birth_place': serializer.toJson<String?>(birth_place),
      'civil_status': serializer.toJson<String?>(
        $PersonsTable.$convertercivil_statusn.toJson(civil_status),
      ),
      'religion_id': serializer.toJson<int?>(religion_id),
      'nationality_id': serializer.toJson<int?>(nationality_id),
      'ethnicity_id': serializer.toJson<int?>(ethnicity_id),
      'blood_type_id': serializer.toJson<int?>(blood_type_id),
      'household_id': serializer.toJson<int?>(household_id),
      'address_id': serializer.toJson<int?>(address_id),
      'registration_place': serializer.toJson<String?>(registration_place),
      'residency': serializer.toJson<String?>(
        $PersonsTable.$converterresidencyn.toJson(residency),
      ),
      'years_of_residency': serializer.toJson<int?>(years_of_residency),
      'transient_type': serializer.toJson<String?>(
        $PersonsTable.$convertertransient_typen.toJson(transient_type),
      ),
      'monthly_income_id': serializer.toJson<int?>(monthly_income_id),
      'daily_income_id': serializer.toJson<int?>(daily_income_id),
      'solo_parent': serializer.toJson<String?>(
        $PersonsTable.$convertersolo_parentn.toJson(solo_parent),
      ),
      'ofw': serializer.toJson<bool?>(ofw),
      'literate': serializer.toJson<bool?>(literate),
      'pwd': serializer.toJson<bool?>(pwd),
      'registered_voter': serializer.toJson<bool?>(registered_voter),
      'currently_enrolled': serializer.toJson<String?>(
        $PersonsTable.$convertercurrently_enrolledn.toJson(currently_enrolled),
      ),
      'education_id': serializer.toJson<int?>(education_id),
      'deceased': serializer.toJson<bool?>(deceased),
      'death_date': serializer.toJson<DateTime?>(death_date),
      'registration_date': serializer.toJson<DateTime?>(registration_date),
      'registration_status': serializer.toJson<String>(
        $PersonsTable.$converterregistration_status.toJson(registration_status),
      ),
    };
  }

  PersonData copyWith({
    int? person_id,
    String? last_name,
    String? first_name,
    Value<String?> middle_name = const Value.absent(),
    Value<String?> suffix = const Value.absent(),
    Value<Sex?> sex = const Value.absent(),
    Value<int?> age = const Value.absent(),
    Value<DateTime?> birth_date = const Value.absent(),
    Value<String?> birth_place = const Value.absent(),
    Value<CivilStatus?> civil_status = const Value.absent(),
    Value<int?> religion_id = const Value.absent(),
    Value<int?> nationality_id = const Value.absent(),
    Value<int?> ethnicity_id = const Value.absent(),
    Value<int?> blood_type_id = const Value.absent(),
    Value<int?> household_id = const Value.absent(),
    Value<int?> address_id = const Value.absent(),
    Value<String?> registration_place = const Value.absent(),
    Value<Residency?> residency = const Value.absent(),
    Value<int?> years_of_residency = const Value.absent(),
    Value<Transient?> transient_type = const Value.absent(),
    Value<int?> monthly_income_id = const Value.absent(),
    Value<int?> daily_income_id = const Value.absent(),
    Value<SoloParent?> solo_parent = const Value.absent(),
    Value<bool?> ofw = const Value.absent(),
    Value<bool?> literate = const Value.absent(),
    Value<bool?> pwd = const Value.absent(),
    Value<bool?> registered_voter = const Value.absent(),
    Value<CurrentlyEnrolled?> currently_enrolled = const Value.absent(),
    Value<int?> education_id = const Value.absent(),
    Value<bool?> deceased = const Value.absent(),
    Value<DateTime?> death_date = const Value.absent(),
    Value<DateTime?> registration_date = const Value.absent(),
    RegistrationStatus? registration_status,
  }) => PersonData(
    person_id: person_id ?? this.person_id,
    last_name: last_name ?? this.last_name,
    first_name: first_name ?? this.first_name,
    middle_name: middle_name.present ? middle_name.value : this.middle_name,
    suffix: suffix.present ? suffix.value : this.suffix,
    sex: sex.present ? sex.value : this.sex,
    age: age.present ? age.value : this.age,
    birth_date: birth_date.present ? birth_date.value : this.birth_date,
    birth_place: birth_place.present ? birth_place.value : this.birth_place,
    civil_status: civil_status.present ? civil_status.value : this.civil_status,
    religion_id: religion_id.present ? religion_id.value : this.religion_id,
    nationality_id:
        nationality_id.present ? nationality_id.value : this.nationality_id,
    ethnicity_id: ethnicity_id.present ? ethnicity_id.value : this.ethnicity_id,
    blood_type_id:
        blood_type_id.present ? blood_type_id.value : this.blood_type_id,
    household_id: household_id.present ? household_id.value : this.household_id,
    address_id: address_id.present ? address_id.value : this.address_id,
    registration_place:
        registration_place.present
            ? registration_place.value
            : this.registration_place,
    residency: residency.present ? residency.value : this.residency,
    years_of_residency:
        years_of_residency.present
            ? years_of_residency.value
            : this.years_of_residency,
    transient_type:
        transient_type.present ? transient_type.value : this.transient_type,
    monthly_income_id:
        monthly_income_id.present
            ? monthly_income_id.value
            : this.monthly_income_id,
    daily_income_id:
        daily_income_id.present ? daily_income_id.value : this.daily_income_id,
    solo_parent: solo_parent.present ? solo_parent.value : this.solo_parent,
    ofw: ofw.present ? ofw.value : this.ofw,
    literate: literate.present ? literate.value : this.literate,
    pwd: pwd.present ? pwd.value : this.pwd,
    registered_voter:
        registered_voter.present
            ? registered_voter.value
            : this.registered_voter,
    currently_enrolled:
        currently_enrolled.present
            ? currently_enrolled.value
            : this.currently_enrolled,
    education_id: education_id.present ? education_id.value : this.education_id,
    deceased: deceased.present ? deceased.value : this.deceased,
    death_date: death_date.present ? death_date.value : this.death_date,
    registration_date:
        registration_date.present
            ? registration_date.value
            : this.registration_date,
    registration_status: registration_status ?? this.registration_status,
  );
  PersonData copyWithCompanion(PersonsCompanion data) {
    return PersonData(
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      last_name: data.last_name.present ? data.last_name.value : this.last_name,
      first_name:
          data.first_name.present ? data.first_name.value : this.first_name,
      middle_name:
          data.middle_name.present ? data.middle_name.value : this.middle_name,
      suffix: data.suffix.present ? data.suffix.value : this.suffix,
      sex: data.sex.present ? data.sex.value : this.sex,
      age: data.age.present ? data.age.value : this.age,
      birth_date:
          data.birth_date.present ? data.birth_date.value : this.birth_date,
      birth_place:
          data.birth_place.present ? data.birth_place.value : this.birth_place,
      civil_status:
          data.civil_status.present
              ? data.civil_status.value
              : this.civil_status,
      religion_id:
          data.religion_id.present ? data.religion_id.value : this.religion_id,
      nationality_id:
          data.nationality_id.present
              ? data.nationality_id.value
              : this.nationality_id,
      ethnicity_id:
          data.ethnicity_id.present
              ? data.ethnicity_id.value
              : this.ethnicity_id,
      blood_type_id:
          data.blood_type_id.present
              ? data.blood_type_id.value
              : this.blood_type_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      address_id:
          data.address_id.present ? data.address_id.value : this.address_id,
      registration_place:
          data.registration_place.present
              ? data.registration_place.value
              : this.registration_place,
      residency: data.residency.present ? data.residency.value : this.residency,
      years_of_residency:
          data.years_of_residency.present
              ? data.years_of_residency.value
              : this.years_of_residency,
      transient_type:
          data.transient_type.present
              ? data.transient_type.value
              : this.transient_type,
      monthly_income_id:
          data.monthly_income_id.present
              ? data.monthly_income_id.value
              : this.monthly_income_id,
      daily_income_id:
          data.daily_income_id.present
              ? data.daily_income_id.value
              : this.daily_income_id,
      solo_parent:
          data.solo_parent.present ? data.solo_parent.value : this.solo_parent,
      ofw: data.ofw.present ? data.ofw.value : this.ofw,
      literate: data.literate.present ? data.literate.value : this.literate,
      pwd: data.pwd.present ? data.pwd.value : this.pwd,
      registered_voter:
          data.registered_voter.present
              ? data.registered_voter.value
              : this.registered_voter,
      currently_enrolled:
          data.currently_enrolled.present
              ? data.currently_enrolled.value
              : this.currently_enrolled,
      education_id:
          data.education_id.present
              ? data.education_id.value
              : this.education_id,
      deceased: data.deceased.present ? data.deceased.value : this.deceased,
      death_date:
          data.death_date.present ? data.death_date.value : this.death_date,
      registration_date:
          data.registration_date.present
              ? data.registration_date.value
              : this.registration_date,
      registration_status:
          data.registration_status.present
              ? data.registration_status.value
              : this.registration_status,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PersonData(')
          ..write('person_id: $person_id, ')
          ..write('last_name: $last_name, ')
          ..write('first_name: $first_name, ')
          ..write('middle_name: $middle_name, ')
          ..write('suffix: $suffix, ')
          ..write('sex: $sex, ')
          ..write('age: $age, ')
          ..write('birth_date: $birth_date, ')
          ..write('birth_place: $birth_place, ')
          ..write('civil_status: $civil_status, ')
          ..write('religion_id: $religion_id, ')
          ..write('nationality_id: $nationality_id, ')
          ..write('ethnicity_id: $ethnicity_id, ')
          ..write('blood_type_id: $blood_type_id, ')
          ..write('household_id: $household_id, ')
          ..write('address_id: $address_id, ')
          ..write('registration_place: $registration_place, ')
          ..write('residency: $residency, ')
          ..write('years_of_residency: $years_of_residency, ')
          ..write('transient_type: $transient_type, ')
          ..write('monthly_income_id: $monthly_income_id, ')
          ..write('daily_income_id: $daily_income_id, ')
          ..write('solo_parent: $solo_parent, ')
          ..write('ofw: $ofw, ')
          ..write('literate: $literate, ')
          ..write('pwd: $pwd, ')
          ..write('registered_voter: $registered_voter, ')
          ..write('currently_enrolled: $currently_enrolled, ')
          ..write('education_id: $education_id, ')
          ..write('deceased: $deceased, ')
          ..write('death_date: $death_date, ')
          ..write('registration_date: $registration_date, ')
          ..write('registration_status: $registration_status')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    person_id,
    last_name,
    first_name,
    middle_name,
    suffix,
    sex,
    age,
    birth_date,
    birth_place,
    civil_status,
    religion_id,
    nationality_id,
    ethnicity_id,
    blood_type_id,
    household_id,
    address_id,
    registration_place,
    residency,
    years_of_residency,
    transient_type,
    monthly_income_id,
    daily_income_id,
    solo_parent,
    ofw,
    literate,
    pwd,
    registered_voter,
    currently_enrolled,
    education_id,
    deceased,
    death_date,
    registration_date,
    registration_status,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PersonData &&
          other.person_id == this.person_id &&
          other.last_name == this.last_name &&
          other.first_name == this.first_name &&
          other.middle_name == this.middle_name &&
          other.suffix == this.suffix &&
          other.sex == this.sex &&
          other.age == this.age &&
          other.birth_date == this.birth_date &&
          other.birth_place == this.birth_place &&
          other.civil_status == this.civil_status &&
          other.religion_id == this.religion_id &&
          other.nationality_id == this.nationality_id &&
          other.ethnicity_id == this.ethnicity_id &&
          other.blood_type_id == this.blood_type_id &&
          other.household_id == this.household_id &&
          other.address_id == this.address_id &&
          other.registration_place == this.registration_place &&
          other.residency == this.residency &&
          other.years_of_residency == this.years_of_residency &&
          other.transient_type == this.transient_type &&
          other.monthly_income_id == this.monthly_income_id &&
          other.daily_income_id == this.daily_income_id &&
          other.solo_parent == this.solo_parent &&
          other.ofw == this.ofw &&
          other.literate == this.literate &&
          other.pwd == this.pwd &&
          other.registered_voter == this.registered_voter &&
          other.currently_enrolled == this.currently_enrolled &&
          other.education_id == this.education_id &&
          other.deceased == this.deceased &&
          other.death_date == this.death_date &&
          other.registration_date == this.registration_date &&
          other.registration_status == this.registration_status);
}

class PersonsCompanion extends UpdateCompanion<PersonData> {
  final Value<int> person_id;
  final Value<String> last_name;
  final Value<String> first_name;
  final Value<String?> middle_name;
  final Value<String?> suffix;
  final Value<Sex?> sex;
  final Value<int?> age;
  final Value<DateTime?> birth_date;
  final Value<String?> birth_place;
  final Value<CivilStatus?> civil_status;
  final Value<int?> religion_id;
  final Value<int?> nationality_id;
  final Value<int?> ethnicity_id;
  final Value<int?> blood_type_id;
  final Value<int?> household_id;
  final Value<int?> address_id;
  final Value<String?> registration_place;
  final Value<Residency?> residency;
  final Value<int?> years_of_residency;
  final Value<Transient?> transient_type;
  final Value<int?> monthly_income_id;
  final Value<int?> daily_income_id;
  final Value<SoloParent?> solo_parent;
  final Value<bool?> ofw;
  final Value<bool?> literate;
  final Value<bool?> pwd;
  final Value<bool?> registered_voter;
  final Value<CurrentlyEnrolled?> currently_enrolled;
  final Value<int?> education_id;
  final Value<bool?> deceased;
  final Value<DateTime?> death_date;
  final Value<DateTime?> registration_date;
  final Value<RegistrationStatus> registration_status;
  const PersonsCompanion({
    this.person_id = const Value.absent(),
    this.last_name = const Value.absent(),
    this.first_name = const Value.absent(),
    this.middle_name = const Value.absent(),
    this.suffix = const Value.absent(),
    this.sex = const Value.absent(),
    this.age = const Value.absent(),
    this.birth_date = const Value.absent(),
    this.birth_place = const Value.absent(),
    this.civil_status = const Value.absent(),
    this.religion_id = const Value.absent(),
    this.nationality_id = const Value.absent(),
    this.ethnicity_id = const Value.absent(),
    this.blood_type_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.address_id = const Value.absent(),
    this.registration_place = const Value.absent(),
    this.residency = const Value.absent(),
    this.years_of_residency = const Value.absent(),
    this.transient_type = const Value.absent(),
    this.monthly_income_id = const Value.absent(),
    this.daily_income_id = const Value.absent(),
    this.solo_parent = const Value.absent(),
    this.ofw = const Value.absent(),
    this.literate = const Value.absent(),
    this.pwd = const Value.absent(),
    this.registered_voter = const Value.absent(),
    this.currently_enrolled = const Value.absent(),
    this.education_id = const Value.absent(),
    this.deceased = const Value.absent(),
    this.death_date = const Value.absent(),
    this.registration_date = const Value.absent(),
    this.registration_status = const Value.absent(),
  });
  PersonsCompanion.insert({
    this.person_id = const Value.absent(),
    required String last_name,
    required String first_name,
    this.middle_name = const Value.absent(),
    this.suffix = const Value.absent(),
    this.sex = const Value.absent(),
    this.age = const Value.absent(),
    this.birth_date = const Value.absent(),
    this.birth_place = const Value.absent(),
    this.civil_status = const Value.absent(),
    this.religion_id = const Value.absent(),
    this.nationality_id = const Value.absent(),
    this.ethnicity_id = const Value.absent(),
    this.blood_type_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.address_id = const Value.absent(),
    this.registration_place = const Value.absent(),
    this.residency = const Value.absent(),
    this.years_of_residency = const Value.absent(),
    this.transient_type = const Value.absent(),
    this.monthly_income_id = const Value.absent(),
    this.daily_income_id = const Value.absent(),
    this.solo_parent = const Value.absent(),
    this.ofw = const Value.absent(),
    this.literate = const Value.absent(),
    this.pwd = const Value.absent(),
    this.registered_voter = const Value.absent(),
    this.currently_enrolled = const Value.absent(),
    this.education_id = const Value.absent(),
    this.deceased = const Value.absent(),
    this.death_date = const Value.absent(),
    this.registration_date = const Value.absent(),
    required RegistrationStatus registration_status,
  }) : last_name = Value(last_name),
       first_name = Value(first_name),
       registration_status = Value(registration_status);
  static Insertable<PersonData> custom({
    Expression<int>? person_id,
    Expression<String>? last_name,
    Expression<String>? first_name,
    Expression<String>? middle_name,
    Expression<String>? suffix,
    Expression<String>? sex,
    Expression<int>? age,
    Expression<DateTime>? birth_date,
    Expression<String>? birth_place,
    Expression<String>? civil_status,
    Expression<int>? religion_id,
    Expression<int>? nationality_id,
    Expression<int>? ethnicity_id,
    Expression<int>? blood_type_id,
    Expression<int>? household_id,
    Expression<int>? address_id,
    Expression<String>? registration_place,
    Expression<String>? residency,
    Expression<int>? years_of_residency,
    Expression<String>? transient_type,
    Expression<int>? monthly_income_id,
    Expression<int>? daily_income_id,
    Expression<String>? solo_parent,
    Expression<bool>? ofw,
    Expression<bool>? literate,
    Expression<bool>? pwd,
    Expression<bool>? registered_voter,
    Expression<String>? currently_enrolled,
    Expression<int>? education_id,
    Expression<bool>? deceased,
    Expression<DateTime>? death_date,
    Expression<DateTime>? registration_date,
    Expression<String>? registration_status,
  }) {
    return RawValuesInsertable({
      if (person_id != null) 'person_id': person_id,
      if (last_name != null) 'last_name': last_name,
      if (first_name != null) 'first_name': first_name,
      if (middle_name != null) 'middle_name': middle_name,
      if (suffix != null) 'suffix': suffix,
      if (sex != null) 'sex': sex,
      if (age != null) 'age': age,
      if (birth_date != null) 'birth_date': birth_date,
      if (birth_place != null) 'birth_place': birth_place,
      if (civil_status != null) 'civil_status': civil_status,
      if (religion_id != null) 'religion_id': religion_id,
      if (nationality_id != null) 'nationality_id': nationality_id,
      if (ethnicity_id != null) 'ethnicity_id': ethnicity_id,
      if (blood_type_id != null) 'blood_type_id': blood_type_id,
      if (household_id != null) 'household_id': household_id,
      if (address_id != null) 'address_id': address_id,
      if (registration_place != null) 'registration_place': registration_place,
      if (residency != null) 'residency': residency,
      if (years_of_residency != null) 'years_of_residency': years_of_residency,
      if (transient_type != null) 'transient_type': transient_type,
      if (monthly_income_id != null) 'monthly_income_id': monthly_income_id,
      if (daily_income_id != null) 'daily_income_id': daily_income_id,
      if (solo_parent != null) 'solo_parent': solo_parent,
      if (ofw != null) 'ofw': ofw,
      if (literate != null) 'literate': literate,
      if (pwd != null) 'pwd': pwd,
      if (registered_voter != null) 'registered_voter': registered_voter,
      if (currently_enrolled != null) 'currently_enrolled': currently_enrolled,
      if (education_id != null) 'education_id': education_id,
      if (deceased != null) 'deceased': deceased,
      if (death_date != null) 'death_date': death_date,
      if (registration_date != null) 'registration_date': registration_date,
      if (registration_status != null)
        'registration_status': registration_status,
    });
  }

  PersonsCompanion copyWith({
    Value<int>? person_id,
    Value<String>? last_name,
    Value<String>? first_name,
    Value<String?>? middle_name,
    Value<String?>? suffix,
    Value<Sex?>? sex,
    Value<int?>? age,
    Value<DateTime?>? birth_date,
    Value<String?>? birth_place,
    Value<CivilStatus?>? civil_status,
    Value<int?>? religion_id,
    Value<int?>? nationality_id,
    Value<int?>? ethnicity_id,
    Value<int?>? blood_type_id,
    Value<int?>? household_id,
    Value<int?>? address_id,
    Value<String?>? registration_place,
    Value<Residency?>? residency,
    Value<int?>? years_of_residency,
    Value<Transient?>? transient_type,
    Value<int?>? monthly_income_id,
    Value<int?>? daily_income_id,
    Value<SoloParent?>? solo_parent,
    Value<bool?>? ofw,
    Value<bool?>? literate,
    Value<bool?>? pwd,
    Value<bool?>? registered_voter,
    Value<CurrentlyEnrolled?>? currently_enrolled,
    Value<int?>? education_id,
    Value<bool?>? deceased,
    Value<DateTime?>? death_date,
    Value<DateTime?>? registration_date,
    Value<RegistrationStatus>? registration_status,
  }) {
    return PersonsCompanion(
      person_id: person_id ?? this.person_id,
      last_name: last_name ?? this.last_name,
      first_name: first_name ?? this.first_name,
      middle_name: middle_name ?? this.middle_name,
      suffix: suffix ?? this.suffix,
      sex: sex ?? this.sex,
      age: age ?? this.age,
      birth_date: birth_date ?? this.birth_date,
      birth_place: birth_place ?? this.birth_place,
      civil_status: civil_status ?? this.civil_status,
      religion_id: religion_id ?? this.religion_id,
      nationality_id: nationality_id ?? this.nationality_id,
      ethnicity_id: ethnicity_id ?? this.ethnicity_id,
      blood_type_id: blood_type_id ?? this.blood_type_id,
      household_id: household_id ?? this.household_id,
      address_id: address_id ?? this.address_id,
      registration_place: registration_place ?? this.registration_place,
      residency: residency ?? this.residency,
      years_of_residency: years_of_residency ?? this.years_of_residency,
      transient_type: transient_type ?? this.transient_type,
      monthly_income_id: monthly_income_id ?? this.monthly_income_id,
      daily_income_id: daily_income_id ?? this.daily_income_id,
      solo_parent: solo_parent ?? this.solo_parent,
      ofw: ofw ?? this.ofw,
      literate: literate ?? this.literate,
      pwd: pwd ?? this.pwd,
      registered_voter: registered_voter ?? this.registered_voter,
      currently_enrolled: currently_enrolled ?? this.currently_enrolled,
      education_id: education_id ?? this.education_id,
      deceased: deceased ?? this.deceased,
      death_date: death_date ?? this.death_date,
      registration_date: registration_date ?? this.registration_date,
      registration_status: registration_status ?? this.registration_status,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (last_name.present) {
      map['last_name'] = Variable<String>(last_name.value);
    }
    if (first_name.present) {
      map['first_name'] = Variable<String>(first_name.value);
    }
    if (middle_name.present) {
      map['middle_name'] = Variable<String>(middle_name.value);
    }
    if (suffix.present) {
      map['suffix'] = Variable<String>(suffix.value);
    }
    if (sex.present) {
      map['sex'] = Variable<String>(
        $PersonsTable.$convertersexn.toSql(sex.value),
      );
    }
    if (age.present) {
      map['age'] = Variable<int>(age.value);
    }
    if (birth_date.present) {
      map['birth_date'] = Variable<DateTime>(birth_date.value);
    }
    if (birth_place.present) {
      map['birth_place'] = Variable<String>(birth_place.value);
    }
    if (civil_status.present) {
      map['civil_status'] = Variable<String>(
        $PersonsTable.$convertercivil_statusn.toSql(civil_status.value),
      );
    }
    if (religion_id.present) {
      map['religion_id'] = Variable<int>(religion_id.value);
    }
    if (nationality_id.present) {
      map['nationality_id'] = Variable<int>(nationality_id.value);
    }
    if (ethnicity_id.present) {
      map['ethnicity_id'] = Variable<int>(ethnicity_id.value);
    }
    if (blood_type_id.present) {
      map['blood_type_id'] = Variable<int>(blood_type_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (address_id.present) {
      map['address_id'] = Variable<int>(address_id.value);
    }
    if (registration_place.present) {
      map['registration_place'] = Variable<String>(registration_place.value);
    }
    if (residency.present) {
      map['residency'] = Variable<String>(
        $PersonsTable.$converterresidencyn.toSql(residency.value),
      );
    }
    if (years_of_residency.present) {
      map['years_of_residency'] = Variable<int>(years_of_residency.value);
    }
    if (transient_type.present) {
      map['transient_type'] = Variable<String>(
        $PersonsTable.$convertertransient_typen.toSql(transient_type.value),
      );
    }
    if (monthly_income_id.present) {
      map['monthly_income_id'] = Variable<int>(monthly_income_id.value);
    }
    if (daily_income_id.present) {
      map['daily_income_id'] = Variable<int>(daily_income_id.value);
    }
    if (solo_parent.present) {
      map['solo_parent'] = Variable<String>(
        $PersonsTable.$convertersolo_parentn.toSql(solo_parent.value),
      );
    }
    if (ofw.present) {
      map['ofw'] = Variable<bool>(ofw.value);
    }
    if (literate.present) {
      map['literate'] = Variable<bool>(literate.value);
    }
    if (pwd.present) {
      map['pwd'] = Variable<bool>(pwd.value);
    }
    if (registered_voter.present) {
      map['registered_voter'] = Variable<bool>(registered_voter.value);
    }
    if (currently_enrolled.present) {
      map['currently_enrolled'] = Variable<String>(
        $PersonsTable.$convertercurrently_enrolledn.toSql(
          currently_enrolled.value,
        ),
      );
    }
    if (education_id.present) {
      map['education_id'] = Variable<int>(education_id.value);
    }
    if (deceased.present) {
      map['deceased'] = Variable<bool>(deceased.value);
    }
    if (death_date.present) {
      map['death_date'] = Variable<DateTime>(death_date.value);
    }
    if (registration_date.present) {
      map['registration_date'] = Variable<DateTime>(registration_date.value);
    }
    if (registration_status.present) {
      map['registration_status'] = Variable<String>(
        $PersonsTable.$converterregistration_status.toSql(
          registration_status.value,
        ),
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PersonsCompanion(')
          ..write('person_id: $person_id, ')
          ..write('last_name: $last_name, ')
          ..write('first_name: $first_name, ')
          ..write('middle_name: $middle_name, ')
          ..write('suffix: $suffix, ')
          ..write('sex: $sex, ')
          ..write('age: $age, ')
          ..write('birth_date: $birth_date, ')
          ..write('birth_place: $birth_place, ')
          ..write('civil_status: $civil_status, ')
          ..write('religion_id: $religion_id, ')
          ..write('nationality_id: $nationality_id, ')
          ..write('ethnicity_id: $ethnicity_id, ')
          ..write('blood_type_id: $blood_type_id, ')
          ..write('household_id: $household_id, ')
          ..write('address_id: $address_id, ')
          ..write('registration_place: $registration_place, ')
          ..write('residency: $residency, ')
          ..write('years_of_residency: $years_of_residency, ')
          ..write('transient_type: $transient_type, ')
          ..write('monthly_income_id: $monthly_income_id, ')
          ..write('daily_income_id: $daily_income_id, ')
          ..write('solo_parent: $solo_parent, ')
          ..write('ofw: $ofw, ')
          ..write('literate: $literate, ')
          ..write('pwd: $pwd, ')
          ..write('registered_voter: $registered_voter, ')
          ..write('currently_enrolled: $currently_enrolled, ')
          ..write('education_id: $education_id, ')
          ..write('deceased: $deceased, ')
          ..write('death_date: $death_date, ')
          ..write('registration_date: $registration_date, ')
          ..write('registration_status: $registration_status')
          ..write(')'))
        .toString();
  }
}

class $OccupationsTable extends Occupations
    with TableInfo<$OccupationsTable, OccupationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OccupationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _occupation_idMeta = const VerificationMeta(
    'occupation_id',
  );
  @override
  late final GeneratedColumn<int> occupation_id = GeneratedColumn<int>(
    'occupation_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _occupationMeta = const VerificationMeta(
    'occupation',
  );
  @override
  late final GeneratedColumn<String> occupation = GeneratedColumn<String>(
    'occupation',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<OccupationType?, String>
  occupation_type = GeneratedColumn<String>(
    'occupation_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<OccupationType?>(
    $OccupationsTable.$converteroccupation_typen,
  );
  @override
  late final GeneratedColumnWithTypeConverter<OccupationStatus?, String>
  occupation_status = GeneratedColumn<String>(
    'occupation_status',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<OccupationStatus?>(
    $OccupationsTable.$converteroccupation_statusn,
  );
  static const VerificationMeta _placeMeta = const VerificationMeta('place');
  @override
  late final GeneratedColumn<String> place = GeneratedColumn<String>(
    'place',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    occupation_id,
    person_id,
    occupation,
    occupation_type,
    occupation_status,
    place,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'occupations';
  @override
  VerificationContext validateIntegrity(
    Insertable<OccupationData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('occupation_id')) {
      context.handle(
        _occupation_idMeta,
        occupation_id.isAcceptableOrUnknown(
          data['occupation_id']!,
          _occupation_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('occupation')) {
      context.handle(
        _occupationMeta,
        occupation.isAcceptableOrUnknown(data['occupation']!, _occupationMeta),
      );
    } else if (isInserting) {
      context.missing(_occupationMeta);
    }
    if (data.containsKey('place')) {
      context.handle(
        _placeMeta,
        place.isAcceptableOrUnknown(data['place']!, _placeMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {occupation_id};
  @override
  OccupationData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OccupationData(
      occupation_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}occupation_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      occupation:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}occupation'],
          )!,
      occupation_type: $OccupationsTable.$converteroccupation_typen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}occupation_type'],
        ),
      ),
      occupation_status: $OccupationsTable.$converteroccupation_statusn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}occupation_status'],
        ),
      ),
      place: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}place'],
      ),
    );
  }

  @override
  $OccupationsTable createAlias(String alias) {
    return $OccupationsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<OccupationType, String, String>
  $converteroccupation_type = const EnumNameConverter<OccupationType>(
    OccupationType.values,
  );
  static JsonTypeConverter2<OccupationType?, String?, String?>
  $converteroccupation_typen = JsonTypeConverter2.asNullable(
    $converteroccupation_type,
  );
  static JsonTypeConverter2<OccupationStatus, String, String>
  $converteroccupation_status = const EnumNameConverter<OccupationStatus>(
    OccupationStatus.values,
  );
  static JsonTypeConverter2<OccupationStatus?, String?, String?>
  $converteroccupation_statusn = JsonTypeConverter2.asNullable(
    $converteroccupation_status,
  );
}

class OccupationData extends DataClass implements Insertable<OccupationData> {
  final int occupation_id;
  final int person_id;
  final String occupation;
  final OccupationType? occupation_type;
  final OccupationStatus? occupation_status;
  final String? place;
  const OccupationData({
    required this.occupation_id,
    required this.person_id,
    required this.occupation,
    this.occupation_type,
    this.occupation_status,
    this.place,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['occupation_id'] = Variable<int>(occupation_id);
    map['person_id'] = Variable<int>(person_id);
    map['occupation'] = Variable<String>(occupation);
    if (!nullToAbsent || occupation_type != null) {
      map['occupation_type'] = Variable<String>(
        $OccupationsTable.$converteroccupation_typen.toSql(occupation_type),
      );
    }
    if (!nullToAbsent || occupation_status != null) {
      map['occupation_status'] = Variable<String>(
        $OccupationsTable.$converteroccupation_statusn.toSql(occupation_status),
      );
    }
    if (!nullToAbsent || place != null) {
      map['place'] = Variable<String>(place);
    }
    return map;
  }

  OccupationsCompanion toCompanion(bool nullToAbsent) {
    return OccupationsCompanion(
      occupation_id: Value(occupation_id),
      person_id: Value(person_id),
      occupation: Value(occupation),
      occupation_type:
          occupation_type == null && nullToAbsent
              ? const Value.absent()
              : Value(occupation_type),
      occupation_status:
          occupation_status == null && nullToAbsent
              ? const Value.absent()
              : Value(occupation_status),
      place:
          place == null && nullToAbsent ? const Value.absent() : Value(place),
    );
  }

  factory OccupationData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OccupationData(
      occupation_id: serializer.fromJson<int>(json['occupation_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      occupation: serializer.fromJson<String>(json['occupation']),
      occupation_type: $OccupationsTable.$converteroccupation_typen.fromJson(
        serializer.fromJson<String?>(json['occupation_type']),
      ),
      occupation_status: $OccupationsTable.$converteroccupation_statusn
          .fromJson(serializer.fromJson<String?>(json['occupation_status'])),
      place: serializer.fromJson<String?>(json['place']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'occupation_id': serializer.toJson<int>(occupation_id),
      'person_id': serializer.toJson<int>(person_id),
      'occupation': serializer.toJson<String>(occupation),
      'occupation_type': serializer.toJson<String?>(
        $OccupationsTable.$converteroccupation_typen.toJson(occupation_type),
      ),
      'occupation_status': serializer.toJson<String?>(
        $OccupationsTable.$converteroccupation_statusn.toJson(
          occupation_status,
        ),
      ),
      'place': serializer.toJson<String?>(place),
    };
  }

  OccupationData copyWith({
    int? occupation_id,
    int? person_id,
    String? occupation,
    Value<OccupationType?> occupation_type = const Value.absent(),
    Value<OccupationStatus?> occupation_status = const Value.absent(),
    Value<String?> place = const Value.absent(),
  }) => OccupationData(
    occupation_id: occupation_id ?? this.occupation_id,
    person_id: person_id ?? this.person_id,
    occupation: occupation ?? this.occupation,
    occupation_type:
        occupation_type.present ? occupation_type.value : this.occupation_type,
    occupation_status:
        occupation_status.present
            ? occupation_status.value
            : this.occupation_status,
    place: place.present ? place.value : this.place,
  );
  OccupationData copyWithCompanion(OccupationsCompanion data) {
    return OccupationData(
      occupation_id:
          data.occupation_id.present
              ? data.occupation_id.value
              : this.occupation_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      occupation:
          data.occupation.present ? data.occupation.value : this.occupation,
      occupation_type:
          data.occupation_type.present
              ? data.occupation_type.value
              : this.occupation_type,
      occupation_status:
          data.occupation_status.present
              ? data.occupation_status.value
              : this.occupation_status,
      place: data.place.present ? data.place.value : this.place,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OccupationData(')
          ..write('occupation_id: $occupation_id, ')
          ..write('person_id: $person_id, ')
          ..write('occupation: $occupation, ')
          ..write('occupation_type: $occupation_type, ')
          ..write('occupation_status: $occupation_status, ')
          ..write('place: $place')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    occupation_id,
    person_id,
    occupation,
    occupation_type,
    occupation_status,
    place,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OccupationData &&
          other.occupation_id == this.occupation_id &&
          other.person_id == this.person_id &&
          other.occupation == this.occupation &&
          other.occupation_type == this.occupation_type &&
          other.occupation_status == this.occupation_status &&
          other.place == this.place);
}

class OccupationsCompanion extends UpdateCompanion<OccupationData> {
  final Value<int> occupation_id;
  final Value<int> person_id;
  final Value<String> occupation;
  final Value<OccupationType?> occupation_type;
  final Value<OccupationStatus?> occupation_status;
  final Value<String?> place;
  const OccupationsCompanion({
    this.occupation_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.occupation = const Value.absent(),
    this.occupation_type = const Value.absent(),
    this.occupation_status = const Value.absent(),
    this.place = const Value.absent(),
  });
  OccupationsCompanion.insert({
    this.occupation_id = const Value.absent(),
    required int person_id,
    required String occupation,
    this.occupation_type = const Value.absent(),
    this.occupation_status = const Value.absent(),
    this.place = const Value.absent(),
  }) : person_id = Value(person_id),
       occupation = Value(occupation);
  static Insertable<OccupationData> custom({
    Expression<int>? occupation_id,
    Expression<int>? person_id,
    Expression<String>? occupation,
    Expression<String>? occupation_type,
    Expression<String>? occupation_status,
    Expression<String>? place,
  }) {
    return RawValuesInsertable({
      if (occupation_id != null) 'occupation_id': occupation_id,
      if (person_id != null) 'person_id': person_id,
      if (occupation != null) 'occupation': occupation,
      if (occupation_type != null) 'occupation_type': occupation_type,
      if (occupation_status != null) 'occupation_status': occupation_status,
      if (place != null) 'place': place,
    });
  }

  OccupationsCompanion copyWith({
    Value<int>? occupation_id,
    Value<int>? person_id,
    Value<String>? occupation,
    Value<OccupationType?>? occupation_type,
    Value<OccupationStatus?>? occupation_status,
    Value<String?>? place,
  }) {
    return OccupationsCompanion(
      occupation_id: occupation_id ?? this.occupation_id,
      person_id: person_id ?? this.person_id,
      occupation: occupation ?? this.occupation,
      occupation_type: occupation_type ?? this.occupation_type,
      occupation_status: occupation_status ?? this.occupation_status,
      place: place ?? this.place,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (occupation_id.present) {
      map['occupation_id'] = Variable<int>(occupation_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (occupation.present) {
      map['occupation'] = Variable<String>(occupation.value);
    }
    if (occupation_type.present) {
      map['occupation_type'] = Variable<String>(
        $OccupationsTable.$converteroccupation_typen.toSql(
          occupation_type.value,
        ),
      );
    }
    if (occupation_status.present) {
      map['occupation_status'] = Variable<String>(
        $OccupationsTable.$converteroccupation_statusn.toSql(
          occupation_status.value,
        ),
      );
    }
    if (place.present) {
      map['place'] = Variable<String>(place.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OccupationsCompanion(')
          ..write('occupation_id: $occupation_id, ')
          ..write('person_id: $person_id, ')
          ..write('occupation: $occupation, ')
          ..write('occupation_type: $occupation_type, ')
          ..write('occupation_status: $occupation_status, ')
          ..write('place: $place')
          ..write(')'))
        .toString();
  }
}

class $EmailsTable extends Emails with TableInfo<$EmailsTable, EmailData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EmailsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _email_idMeta = const VerificationMeta(
    'email_id',
  );
  @override
  late final GeneratedColumn<int> email_id = GeneratedColumn<int>(
    'email_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _email_addressMeta = const VerificationMeta(
    'email_address',
  );
  @override
  late final GeneratedColumn<String> email_address = GeneratedColumn<String>(
    'email_address',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  @override
  List<GeneratedColumn> get $columns => [email_id, person_id, email_address];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'emails';
  @override
  VerificationContext validateIntegrity(
    Insertable<EmailData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('email_id')) {
      context.handle(
        _email_idMeta,
        email_id.isAcceptableOrUnknown(data['email_id']!, _email_idMeta),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('email_address')) {
      context.handle(
        _email_addressMeta,
        email_address.isAcceptableOrUnknown(
          data['email_address']!,
          _email_addressMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_email_addressMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {email_id};
  @override
  EmailData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EmailData(
      email_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}email_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      email_address:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}email_address'],
          )!,
    );
  }

  @override
  $EmailsTable createAlias(String alias) {
    return $EmailsTable(attachedDatabase, alias);
  }
}

class EmailData extends DataClass implements Insertable<EmailData> {
  final int email_id;
  final int person_id;
  final String email_address;
  const EmailData({
    required this.email_id,
    required this.person_id,
    required this.email_address,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['email_id'] = Variable<int>(email_id);
    map['person_id'] = Variable<int>(person_id);
    map['email_address'] = Variable<String>(email_address);
    return map;
  }

  EmailsCompanion toCompanion(bool nullToAbsent) {
    return EmailsCompanion(
      email_id: Value(email_id),
      person_id: Value(person_id),
      email_address: Value(email_address),
    );
  }

  factory EmailData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EmailData(
      email_id: serializer.fromJson<int>(json['email_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      email_address: serializer.fromJson<String>(json['email_address']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'email_id': serializer.toJson<int>(email_id),
      'person_id': serializer.toJson<int>(person_id),
      'email_address': serializer.toJson<String>(email_address),
    };
  }

  EmailData copyWith({int? email_id, int? person_id, String? email_address}) =>
      EmailData(
        email_id: email_id ?? this.email_id,
        person_id: person_id ?? this.person_id,
        email_address: email_address ?? this.email_address,
      );
  EmailData copyWithCompanion(EmailsCompanion data) {
    return EmailData(
      email_id: data.email_id.present ? data.email_id.value : this.email_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      email_address:
          data.email_address.present
              ? data.email_address.value
              : this.email_address,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EmailData(')
          ..write('email_id: $email_id, ')
          ..write('person_id: $person_id, ')
          ..write('email_address: $email_address')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(email_id, person_id, email_address);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EmailData &&
          other.email_id == this.email_id &&
          other.person_id == this.person_id &&
          other.email_address == this.email_address);
}

class EmailsCompanion extends UpdateCompanion<EmailData> {
  final Value<int> email_id;
  final Value<int> person_id;
  final Value<String> email_address;
  const EmailsCompanion({
    this.email_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.email_address = const Value.absent(),
  });
  EmailsCompanion.insert({
    this.email_id = const Value.absent(),
    required int person_id,
    required String email_address,
  }) : person_id = Value(person_id),
       email_address = Value(email_address);
  static Insertable<EmailData> custom({
    Expression<int>? email_id,
    Expression<int>? person_id,
    Expression<String>? email_address,
  }) {
    return RawValuesInsertable({
      if (email_id != null) 'email_id': email_id,
      if (person_id != null) 'person_id': person_id,
      if (email_address != null) 'email_address': email_address,
    });
  }

  EmailsCompanion copyWith({
    Value<int>? email_id,
    Value<int>? person_id,
    Value<String>? email_address,
  }) {
    return EmailsCompanion(
      email_id: email_id ?? this.email_id,
      person_id: person_id ?? this.person_id,
      email_address: email_address ?? this.email_address,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (email_id.present) {
      map['email_id'] = Variable<int>(email_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (email_address.present) {
      map['email_address'] = Variable<String>(email_address.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EmailsCompanion(')
          ..write('email_id: $email_id, ')
          ..write('person_id: $person_id, ')
          ..write('email_address: $email_address')
          ..write(')'))
        .toString();
  }
}

class $PhoneNumbersTable extends PhoneNumbers
    with TableInfo<$PhoneNumbersTable, PhoneNumberData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PhoneNumbersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _phone_number_idMeta = const VerificationMeta(
    'phone_number_id',
  );
  @override
  late final GeneratedColumn<int> phone_number_id = GeneratedColumn<int>(
    'phone_number_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _phone_numMeta = const VerificationMeta(
    'phone_num',
  );
  @override
  late final GeneratedColumn<int> phone_num = GeneratedColumn<int>(
    'phone_num',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  @override
  List<GeneratedColumn> get $columns => [phone_number_id, person_id, phone_num];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'phone_numbers';
  @override
  VerificationContext validateIntegrity(
    Insertable<PhoneNumberData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('phone_number_id')) {
      context.handle(
        _phone_number_idMeta,
        phone_number_id.isAcceptableOrUnknown(
          data['phone_number_id']!,
          _phone_number_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('phone_num')) {
      context.handle(
        _phone_numMeta,
        phone_num.isAcceptableOrUnknown(data['phone_num']!, _phone_numMeta),
      );
    } else if (isInserting) {
      context.missing(_phone_numMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {phone_number_id};
  @override
  PhoneNumberData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PhoneNumberData(
      phone_number_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}phone_number_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      phone_num:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}phone_num'],
          )!,
    );
  }

  @override
  $PhoneNumbersTable createAlias(String alias) {
    return $PhoneNumbersTable(attachedDatabase, alias);
  }
}

class PhoneNumberData extends DataClass implements Insertable<PhoneNumberData> {
  final int phone_number_id;
  final int person_id;
  final int phone_num;
  const PhoneNumberData({
    required this.phone_number_id,
    required this.person_id,
    required this.phone_num,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['phone_number_id'] = Variable<int>(phone_number_id);
    map['person_id'] = Variable<int>(person_id);
    map['phone_num'] = Variable<int>(phone_num);
    return map;
  }

  PhoneNumbersCompanion toCompanion(bool nullToAbsent) {
    return PhoneNumbersCompanion(
      phone_number_id: Value(phone_number_id),
      person_id: Value(person_id),
      phone_num: Value(phone_num),
    );
  }

  factory PhoneNumberData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PhoneNumberData(
      phone_number_id: serializer.fromJson<int>(json['phone_number_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      phone_num: serializer.fromJson<int>(json['phone_num']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'phone_number_id': serializer.toJson<int>(phone_number_id),
      'person_id': serializer.toJson<int>(person_id),
      'phone_num': serializer.toJson<int>(phone_num),
    };
  }

  PhoneNumberData copyWith({
    int? phone_number_id,
    int? person_id,
    int? phone_num,
  }) => PhoneNumberData(
    phone_number_id: phone_number_id ?? this.phone_number_id,
    person_id: person_id ?? this.person_id,
    phone_num: phone_num ?? this.phone_num,
  );
  PhoneNumberData copyWithCompanion(PhoneNumbersCompanion data) {
    return PhoneNumberData(
      phone_number_id:
          data.phone_number_id.present
              ? data.phone_number_id.value
              : this.phone_number_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      phone_num: data.phone_num.present ? data.phone_num.value : this.phone_num,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PhoneNumberData(')
          ..write('phone_number_id: $phone_number_id, ')
          ..write('person_id: $person_id, ')
          ..write('phone_num: $phone_num')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(phone_number_id, person_id, phone_num);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PhoneNumberData &&
          other.phone_number_id == this.phone_number_id &&
          other.person_id == this.person_id &&
          other.phone_num == this.phone_num);
}

class PhoneNumbersCompanion extends UpdateCompanion<PhoneNumberData> {
  final Value<int> phone_number_id;
  final Value<int> person_id;
  final Value<int> phone_num;
  const PhoneNumbersCompanion({
    this.phone_number_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.phone_num = const Value.absent(),
  });
  PhoneNumbersCompanion.insert({
    this.phone_number_id = const Value.absent(),
    required int person_id,
    required int phone_num,
  }) : person_id = Value(person_id),
       phone_num = Value(phone_num);
  static Insertable<PhoneNumberData> custom({
    Expression<int>? phone_number_id,
    Expression<int>? person_id,
    Expression<int>? phone_num,
  }) {
    return RawValuesInsertable({
      if (phone_number_id != null) 'phone_number_id': phone_number_id,
      if (person_id != null) 'person_id': person_id,
      if (phone_num != null) 'phone_num': phone_num,
    });
  }

  PhoneNumbersCompanion copyWith({
    Value<int>? phone_number_id,
    Value<int>? person_id,
    Value<int>? phone_num,
  }) {
    return PhoneNumbersCompanion(
      phone_number_id: phone_number_id ?? this.phone_number_id,
      person_id: person_id ?? this.person_id,
      phone_num: phone_num ?? this.phone_num,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (phone_number_id.present) {
      map['phone_number_id'] = Variable<int>(phone_number_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (phone_num.present) {
      map['phone_num'] = Variable<int>(phone_num.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PhoneNumbersCompanion(')
          ..write('phone_number_id: $phone_number_id, ')
          ..write('person_id: $person_id, ')
          ..write('phone_num: $phone_num')
          ..write(')'))
        .toString();
  }
}

class $GadgetsTable extends Gadgets with TableInfo<$GadgetsTable, GadgetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GadgetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _gadget_idMeta = const VerificationMeta(
    'gadget_id',
  );
  @override
  late final GeneratedColumn<int> gadget_id = GeneratedColumn<int>(
    'gadget_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Gadget?, String> gadget =
      GeneratedColumn<String>(
        'gadget',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Gadget?>($GadgetsTable.$convertergadgetn);
  @override
  List<GeneratedColumn> get $columns => [gadget_id, person_id, gadget];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gadgets';
  @override
  VerificationContext validateIntegrity(
    Insertable<GadgetData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('gadget_id')) {
      context.handle(
        _gadget_idMeta,
        gadget_id.isAcceptableOrUnknown(data['gadget_id']!, _gadget_idMeta),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {gadget_id};
  @override
  GadgetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GadgetData(
      gadget_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}gadget_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      gadget: $GadgetsTable.$convertergadgetn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}gadget'],
        ),
      ),
    );
  }

  @override
  $GadgetsTable createAlias(String alias) {
    return $GadgetsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<Gadget, String, String> $convertergadget =
      const EnumNameConverter<Gadget>(Gadget.values);
  static JsonTypeConverter2<Gadget?, String?, String?> $convertergadgetn =
      JsonTypeConverter2.asNullable($convertergadget);
}

class GadgetData extends DataClass implements Insertable<GadgetData> {
  final int gadget_id;
  final int person_id;
  final Gadget? gadget;
  const GadgetData({
    required this.gadget_id,
    required this.person_id,
    this.gadget,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['gadget_id'] = Variable<int>(gadget_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || gadget != null) {
      map['gadget'] = Variable<String>(
        $GadgetsTable.$convertergadgetn.toSql(gadget),
      );
    }
    return map;
  }

  GadgetsCompanion toCompanion(bool nullToAbsent) {
    return GadgetsCompanion(
      gadget_id: Value(gadget_id),
      person_id: Value(person_id),
      gadget:
          gadget == null && nullToAbsent ? const Value.absent() : Value(gadget),
    );
  }

  factory GadgetData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GadgetData(
      gadget_id: serializer.fromJson<int>(json['gadget_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      gadget: $GadgetsTable.$convertergadgetn.fromJson(
        serializer.fromJson<String?>(json['gadget']),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'gadget_id': serializer.toJson<int>(gadget_id),
      'person_id': serializer.toJson<int>(person_id),
      'gadget': serializer.toJson<String?>(
        $GadgetsTable.$convertergadgetn.toJson(gadget),
      ),
    };
  }

  GadgetData copyWith({
    int? gadget_id,
    int? person_id,
    Value<Gadget?> gadget = const Value.absent(),
  }) => GadgetData(
    gadget_id: gadget_id ?? this.gadget_id,
    person_id: person_id ?? this.person_id,
    gadget: gadget.present ? gadget.value : this.gadget,
  );
  GadgetData copyWithCompanion(GadgetsCompanion data) {
    return GadgetData(
      gadget_id: data.gadget_id.present ? data.gadget_id.value : this.gadget_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      gadget: data.gadget.present ? data.gadget.value : this.gadget,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GadgetData(')
          ..write('gadget_id: $gadget_id, ')
          ..write('person_id: $person_id, ')
          ..write('gadget: $gadget')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(gadget_id, person_id, gadget);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GadgetData &&
          other.gadget_id == this.gadget_id &&
          other.person_id == this.person_id &&
          other.gadget == this.gadget);
}

class GadgetsCompanion extends UpdateCompanion<GadgetData> {
  final Value<int> gadget_id;
  final Value<int> person_id;
  final Value<Gadget?> gadget;
  const GadgetsCompanion({
    this.gadget_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.gadget = const Value.absent(),
  });
  GadgetsCompanion.insert({
    this.gadget_id = const Value.absent(),
    required int person_id,
    this.gadget = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<GadgetData> custom({
    Expression<int>? gadget_id,
    Expression<int>? person_id,
    Expression<String>? gadget,
  }) {
    return RawValuesInsertable({
      if (gadget_id != null) 'gadget_id': gadget_id,
      if (person_id != null) 'person_id': person_id,
      if (gadget != null) 'gadget': gadget,
    });
  }

  GadgetsCompanion copyWith({
    Value<int>? gadget_id,
    Value<int>? person_id,
    Value<Gadget?>? gadget,
  }) {
    return GadgetsCompanion(
      gadget_id: gadget_id ?? this.gadget_id,
      person_id: person_id ?? this.person_id,
      gadget: gadget ?? this.gadget,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (gadget_id.present) {
      map['gadget_id'] = Variable<int>(gadget_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (gadget.present) {
      map['gadget'] = Variable<String>(
        $GadgetsTable.$convertergadgetn.toSql(gadget.value),
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GadgetsCompanion(')
          ..write('gadget_id: $gadget_id, ')
          ..write('person_id: $person_id, ')
          ..write('gadget: $gadget')
          ..write(')'))
        .toString();
  }
}

class $GovermentProgramsTable extends GovermentPrograms
    with TableInfo<$GovermentProgramsTable, GovernmentProgramData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GovermentProgramsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _government_program_idMeta =
      const VerificationMeta('government_program_id');
  @override
  late final GeneratedColumn<int> government_program_id = GeneratedColumn<int>(
    'government_program_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    government_program_id,
    person_id,
    name,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goverment_programs';
  @override
  VerificationContext validateIntegrity(
    Insertable<GovernmentProgramData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('government_program_id')) {
      context.handle(
        _government_program_idMeta,
        government_program_id.isAcceptableOrUnknown(
          data['government_program_id']!,
          _government_program_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {government_program_id};
  @override
  GovernmentProgramData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GovernmentProgramData(
      government_program_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}government_program_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $GovermentProgramsTable createAlias(String alias) {
    return $GovermentProgramsTable(attachedDatabase, alias);
  }
}

class GovernmentProgramData extends DataClass
    implements Insertable<GovernmentProgramData> {
  final int government_program_id;
  final int person_id;
  final String name;
  const GovernmentProgramData({
    required this.government_program_id,
    required this.person_id,
    required this.name,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['government_program_id'] = Variable<int>(government_program_id);
    map['person_id'] = Variable<int>(person_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  GovermentProgramsCompanion toCompanion(bool nullToAbsent) {
    return GovermentProgramsCompanion(
      government_program_id: Value(government_program_id),
      person_id: Value(person_id),
      name: Value(name),
    );
  }

  factory GovernmentProgramData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GovernmentProgramData(
      government_program_id: serializer.fromJson<int>(
        json['government_program_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'government_program_id': serializer.toJson<int>(government_program_id),
      'person_id': serializer.toJson<int>(person_id),
      'name': serializer.toJson<String>(name),
    };
  }

  GovernmentProgramData copyWith({
    int? government_program_id,
    int? person_id,
    String? name,
  }) => GovernmentProgramData(
    government_program_id: government_program_id ?? this.government_program_id,
    person_id: person_id ?? this.person_id,
    name: name ?? this.name,
  );
  GovernmentProgramData copyWithCompanion(GovermentProgramsCompanion data) {
    return GovernmentProgramData(
      government_program_id:
          data.government_program_id.present
              ? data.government_program_id.value
              : this.government_program_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GovernmentProgramData(')
          ..write('government_program_id: $government_program_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(government_program_id, person_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GovernmentProgramData &&
          other.government_program_id == this.government_program_id &&
          other.person_id == this.person_id &&
          other.name == this.name);
}

class GovermentProgramsCompanion
    extends UpdateCompanion<GovernmentProgramData> {
  final Value<int> government_program_id;
  final Value<int> person_id;
  final Value<String> name;
  const GovermentProgramsCompanion({
    this.government_program_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  GovermentProgramsCompanion.insert({
    this.government_program_id = const Value.absent(),
    required int person_id,
    required String name,
  }) : person_id = Value(person_id),
       name = Value(name);
  static Insertable<GovernmentProgramData> custom({
    Expression<int>? government_program_id,
    Expression<int>? person_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (government_program_id != null)
        'government_program_id': government_program_id,
      if (person_id != null) 'person_id': person_id,
      if (name != null) 'name': name,
    });
  }

  GovermentProgramsCompanion copyWith({
    Value<int>? government_program_id,
    Value<int>? person_id,
    Value<String>? name,
  }) {
    return GovermentProgramsCompanion(
      government_program_id:
          government_program_id ?? this.government_program_id,
      person_id: person_id ?? this.person_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (government_program_id.present) {
      map['government_program_id'] = Variable<int>(government_program_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GovermentProgramsCompanion(')
          ..write('government_program_id: $government_program_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $VoterRegistriesTable extends VoterRegistries
    with TableInfo<$VoterRegistriesTable, VoterRegistryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VoterRegistriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _voter_registry_idMeta = const VerificationMeta(
    'voter_registry_id',
  );
  @override
  late final GeneratedColumn<int> voter_registry_id = GeneratedColumn<int>(
    'voter_registry_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _place_of_vote_registryMeta =
      const VerificationMeta('place_of_vote_registry');
  @override
  late final GeneratedColumn<String> place_of_vote_registry =
      GeneratedColumn<String>(
        'place_of_vote_registry',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
      );
  @override
  List<GeneratedColumn> get $columns => [
    voter_registry_id,
    person_id,
    place_of_vote_registry,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'voter_registries';
  @override
  VerificationContext validateIntegrity(
    Insertable<VoterRegistryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('voter_registry_id')) {
      context.handle(
        _voter_registry_idMeta,
        voter_registry_id.isAcceptableOrUnknown(
          data['voter_registry_id']!,
          _voter_registry_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('place_of_vote_registry')) {
      context.handle(
        _place_of_vote_registryMeta,
        place_of_vote_registry.isAcceptableOrUnknown(
          data['place_of_vote_registry']!,
          _place_of_vote_registryMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_place_of_vote_registryMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {voter_registry_id};
  @override
  VoterRegistryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VoterRegistryData(
      voter_registry_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}voter_registry_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      place_of_vote_registry:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}place_of_vote_registry'],
          )!,
    );
  }

  @override
  $VoterRegistriesTable createAlias(String alias) {
    return $VoterRegistriesTable(attachedDatabase, alias);
  }
}

class VoterRegistryData extends DataClass
    implements Insertable<VoterRegistryData> {
  final int voter_registry_id;
  final int person_id;
  final String place_of_vote_registry;
  const VoterRegistryData({
    required this.voter_registry_id,
    required this.person_id,
    required this.place_of_vote_registry,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['voter_registry_id'] = Variable<int>(voter_registry_id);
    map['person_id'] = Variable<int>(person_id);
    map['place_of_vote_registry'] = Variable<String>(place_of_vote_registry);
    return map;
  }

  VoterRegistriesCompanion toCompanion(bool nullToAbsent) {
    return VoterRegistriesCompanion(
      voter_registry_id: Value(voter_registry_id),
      person_id: Value(person_id),
      place_of_vote_registry: Value(place_of_vote_registry),
    );
  }

  factory VoterRegistryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VoterRegistryData(
      voter_registry_id: serializer.fromJson<int>(json['voter_registry_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      place_of_vote_registry: serializer.fromJson<String>(
        json['place_of_vote_registry'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'voter_registry_id': serializer.toJson<int>(voter_registry_id),
      'person_id': serializer.toJson<int>(person_id),
      'place_of_vote_registry': serializer.toJson<String>(
        place_of_vote_registry,
      ),
    };
  }

  VoterRegistryData copyWith({
    int? voter_registry_id,
    int? person_id,
    String? place_of_vote_registry,
  }) => VoterRegistryData(
    voter_registry_id: voter_registry_id ?? this.voter_registry_id,
    person_id: person_id ?? this.person_id,
    place_of_vote_registry:
        place_of_vote_registry ?? this.place_of_vote_registry,
  );
  VoterRegistryData copyWithCompanion(VoterRegistriesCompanion data) {
    return VoterRegistryData(
      voter_registry_id:
          data.voter_registry_id.present
              ? data.voter_registry_id.value
              : this.voter_registry_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      place_of_vote_registry:
          data.place_of_vote_registry.present
              ? data.place_of_vote_registry.value
              : this.place_of_vote_registry,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VoterRegistryData(')
          ..write('voter_registry_id: $voter_registry_id, ')
          ..write('person_id: $person_id, ')
          ..write('place_of_vote_registry: $place_of_vote_registry')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(voter_registry_id, person_id, place_of_vote_registry);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VoterRegistryData &&
          other.voter_registry_id == this.voter_registry_id &&
          other.person_id == this.person_id &&
          other.place_of_vote_registry == this.place_of_vote_registry);
}

class VoterRegistriesCompanion extends UpdateCompanion<VoterRegistryData> {
  final Value<int> voter_registry_id;
  final Value<int> person_id;
  final Value<String> place_of_vote_registry;
  const VoterRegistriesCompanion({
    this.voter_registry_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.place_of_vote_registry = const Value.absent(),
  });
  VoterRegistriesCompanion.insert({
    this.voter_registry_id = const Value.absent(),
    required int person_id,
    required String place_of_vote_registry,
  }) : person_id = Value(person_id),
       place_of_vote_registry = Value(place_of_vote_registry);
  static Insertable<VoterRegistryData> custom({
    Expression<int>? voter_registry_id,
    Expression<int>? person_id,
    Expression<String>? place_of_vote_registry,
  }) {
    return RawValuesInsertable({
      if (voter_registry_id != null) 'voter_registry_id': voter_registry_id,
      if (person_id != null) 'person_id': person_id,
      if (place_of_vote_registry != null)
        'place_of_vote_registry': place_of_vote_registry,
    });
  }

  VoterRegistriesCompanion copyWith({
    Value<int>? voter_registry_id,
    Value<int>? person_id,
    Value<String>? place_of_vote_registry,
  }) {
    return VoterRegistriesCompanion(
      voter_registry_id: voter_registry_id ?? this.voter_registry_id,
      person_id: person_id ?? this.person_id,
      place_of_vote_registry:
          place_of_vote_registry ?? this.place_of_vote_registry,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (voter_registry_id.present) {
      map['voter_registry_id'] = Variable<int>(voter_registry_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (place_of_vote_registry.present) {
      map['place_of_vote_registry'] = Variable<String>(
        place_of_vote_registry.value,
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VoterRegistriesCompanion(')
          ..write('voter_registry_id: $voter_registry_id, ')
          ..write('person_id: $person_id, ')
          ..write('place_of_vote_registry: $place_of_vote_registry')
          ..write(')'))
        .toString();
  }
}

class $RegisteredSeniorsTable extends RegisteredSeniors
    with TableInfo<$RegisteredSeniorsTable, RegisteredSeniorData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RegisteredSeniorsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _registered_senior_idMeta =
      const VerificationMeta('registered_senior_id');
  @override
  late final GeneratedColumn<int> registered_senior_id = GeneratedColumn<int>(
    'registered_senior_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [registered_senior_id, person_id];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'registered_seniors';
  @override
  VerificationContext validateIntegrity(
    Insertable<RegisteredSeniorData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('registered_senior_id')) {
      context.handle(
        _registered_senior_idMeta,
        registered_senior_id.isAcceptableOrUnknown(
          data['registered_senior_id']!,
          _registered_senior_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {registered_senior_id};
  @override
  RegisteredSeniorData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RegisteredSeniorData(
      registered_senior_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}registered_senior_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
    );
  }

  @override
  $RegisteredSeniorsTable createAlias(String alias) {
    return $RegisteredSeniorsTable(attachedDatabase, alias);
  }
}

class RegisteredSeniorData extends DataClass
    implements Insertable<RegisteredSeniorData> {
  final int registered_senior_id;
  final int person_id;
  const RegisteredSeniorData({
    required this.registered_senior_id,
    required this.person_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['registered_senior_id'] = Variable<int>(registered_senior_id);
    map['person_id'] = Variable<int>(person_id);
    return map;
  }

  RegisteredSeniorsCompanion toCompanion(bool nullToAbsent) {
    return RegisteredSeniorsCompanion(
      registered_senior_id: Value(registered_senior_id),
      person_id: Value(person_id),
    );
  }

  factory RegisteredSeniorData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RegisteredSeniorData(
      registered_senior_id: serializer.fromJson<int>(
        json['registered_senior_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'registered_senior_id': serializer.toJson<int>(registered_senior_id),
      'person_id': serializer.toJson<int>(person_id),
    };
  }

  RegisteredSeniorData copyWith({int? registered_senior_id, int? person_id}) =>
      RegisteredSeniorData(
        registered_senior_id: registered_senior_id ?? this.registered_senior_id,
        person_id: person_id ?? this.person_id,
      );
  RegisteredSeniorData copyWithCompanion(RegisteredSeniorsCompanion data) {
    return RegisteredSeniorData(
      registered_senior_id:
          data.registered_senior_id.present
              ? data.registered_senior_id.value
              : this.registered_senior_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredSeniorData(')
          ..write('registered_senior_id: $registered_senior_id, ')
          ..write('person_id: $person_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(registered_senior_id, person_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RegisteredSeniorData &&
          other.registered_senior_id == this.registered_senior_id &&
          other.person_id == this.person_id);
}

class RegisteredSeniorsCompanion extends UpdateCompanion<RegisteredSeniorData> {
  final Value<int> registered_senior_id;
  final Value<int> person_id;
  const RegisteredSeniorsCompanion({
    this.registered_senior_id = const Value.absent(),
    this.person_id = const Value.absent(),
  });
  RegisteredSeniorsCompanion.insert({
    this.registered_senior_id = const Value.absent(),
    required int person_id,
  }) : person_id = Value(person_id);
  static Insertable<RegisteredSeniorData> custom({
    Expression<int>? registered_senior_id,
    Expression<int>? person_id,
  }) {
    return RawValuesInsertable({
      if (registered_senior_id != null)
        'registered_senior_id': registered_senior_id,
      if (person_id != null) 'person_id': person_id,
    });
  }

  RegisteredSeniorsCompanion copyWith({
    Value<int>? registered_senior_id,
    Value<int>? person_id,
  }) {
    return RegisteredSeniorsCompanion(
      registered_senior_id: registered_senior_id ?? this.registered_senior_id,
      person_id: person_id ?? this.person_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (registered_senior_id.present) {
      map['registered_senior_id'] = Variable<int>(registered_senior_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RegisteredSeniorsCompanion(')
          ..write('registered_senior_id: $registered_senior_id, ')
          ..write('person_id: $person_id')
          ..write(')'))
        .toString();
  }
}

class $DisabilitiesTable extends Disabilities
    with TableInfo<$DisabilitiesTable, DisabilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DisabilitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _disability_idMeta = const VerificationMeta(
    'disability_id',
  );
  @override
  late final GeneratedColumn<int> disability_id = GeneratedColumn<int>(
    'disability_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [disability_id, person_id, name, type];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'disabilities';
  @override
  VerificationContext validateIntegrity(
    Insertable<DisabilityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('disability_id')) {
      context.handle(
        _disability_idMeta,
        disability_id.isAcceptableOrUnknown(
          data['disability_id']!,
          _disability_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {disability_id};
  @override
  DisabilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DisabilityData(
      disability_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}disability_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      ),
    );
  }

  @override
  $DisabilitiesTable createAlias(String alias) {
    return $DisabilitiesTable(attachedDatabase, alias);
  }
}

class DisabilityData extends DataClass implements Insertable<DisabilityData> {
  final int disability_id;
  final int person_id;
  final String name;
  final String? type;
  const DisabilityData({
    required this.disability_id,
    required this.person_id,
    required this.name,
    this.type,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['disability_id'] = Variable<int>(disability_id);
    map['person_id'] = Variable<int>(person_id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    return map;
  }

  DisabilitiesCompanion toCompanion(bool nullToAbsent) {
    return DisabilitiesCompanion(
      disability_id: Value(disability_id),
      person_id: Value(person_id),
      name: Value(name),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
    );
  }

  factory DisabilityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DisabilityData(
      disability_id: serializer.fromJson<int>(json['disability_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      name: serializer.fromJson<String>(json['name']),
      type: serializer.fromJson<String?>(json['type']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'disability_id': serializer.toJson<int>(disability_id),
      'person_id': serializer.toJson<int>(person_id),
      'name': serializer.toJson<String>(name),
      'type': serializer.toJson<String?>(type),
    };
  }

  DisabilityData copyWith({
    int? disability_id,
    int? person_id,
    String? name,
    Value<String?> type = const Value.absent(),
  }) => DisabilityData(
    disability_id: disability_id ?? this.disability_id,
    person_id: person_id ?? this.person_id,
    name: name ?? this.name,
    type: type.present ? type.value : this.type,
  );
  DisabilityData copyWithCompanion(DisabilitiesCompanion data) {
    return DisabilityData(
      disability_id:
          data.disability_id.present
              ? data.disability_id.value
              : this.disability_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      name: data.name.present ? data.name.value : this.name,
      type: data.type.present ? data.type.value : this.type,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DisabilityData(')
          ..write('disability_id: $disability_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(disability_id, person_id, name, type);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DisabilityData &&
          other.disability_id == this.disability_id &&
          other.person_id == this.person_id &&
          other.name == this.name &&
          other.type == this.type);
}

class DisabilitiesCompanion extends UpdateCompanion<DisabilityData> {
  final Value<int> disability_id;
  final Value<int> person_id;
  final Value<String> name;
  final Value<String?> type;
  const DisabilitiesCompanion({
    this.disability_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
  });
  DisabilitiesCompanion.insert({
    this.disability_id = const Value.absent(),
    required int person_id,
    required String name,
    this.type = const Value.absent(),
  }) : person_id = Value(person_id),
       name = Value(name);
  static Insertable<DisabilityData> custom({
    Expression<int>? disability_id,
    Expression<int>? person_id,
    Expression<String>? name,
    Expression<String>? type,
  }) {
    return RawValuesInsertable({
      if (disability_id != null) 'disability_id': disability_id,
      if (person_id != null) 'person_id': person_id,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
    });
  }

  DisabilitiesCompanion copyWith({
    Value<int>? disability_id,
    Value<int>? person_id,
    Value<String>? name,
    Value<String?>? type,
  }) {
    return DisabilitiesCompanion(
      disability_id: disability_id ?? this.disability_id,
      person_id: person_id ?? this.person_id,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (disability_id.present) {
      map['disability_id'] = Variable<int>(disability_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DisabilitiesCompanion(')
          ..write('disability_id: $disability_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name, ')
          ..write('type: $type')
          ..write(')'))
        .toString();
  }
}

class $EnrolledTable extends Enrolled
    with TableInfo<$EnrolledTable, EnrolledData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EnrolledTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _enrolled_idMeta = const VerificationMeta(
    'enrolled_id',
  );
  @override
  late final GeneratedColumn<int> enrolled_id = GeneratedColumn<int>(
    'enrolled_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _schoolMeta = const VerificationMeta('school');
  @override
  late final GeneratedColumn<String> school = GeneratedColumn<String>(
    'school',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _education_idMeta = const VerificationMeta(
    'education_id',
  );
  @override
  late final GeneratedColumn<int> education_id = GeneratedColumn<int>(
    'education_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES education (education_id) ON DELETE CASCADE',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    enrolled_id,
    person_id,
    school,
    education_id,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'enrolled';
  @override
  VerificationContext validateIntegrity(
    Insertable<EnrolledData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('enrolled_id')) {
      context.handle(
        _enrolled_idMeta,
        enrolled_id.isAcceptableOrUnknown(
          data['enrolled_id']!,
          _enrolled_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('school')) {
      context.handle(
        _schoolMeta,
        school.isAcceptableOrUnknown(data['school']!, _schoolMeta),
      );
    } else if (isInserting) {
      context.missing(_schoolMeta);
    }
    if (data.containsKey('education_id')) {
      context.handle(
        _education_idMeta,
        education_id.isAcceptableOrUnknown(
          data['education_id']!,
          _education_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_education_idMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {enrolled_id};
  @override
  EnrolledData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EnrolledData(
      enrolled_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}enrolled_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      school:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}school'],
          )!,
      education_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}education_id'],
          )!,
    );
  }

  @override
  $EnrolledTable createAlias(String alias) {
    return $EnrolledTable(attachedDatabase, alias);
  }
}

class EnrolledData extends DataClass implements Insertable<EnrolledData> {
  final int enrolled_id;
  final int person_id;
  final String school;
  final int education_id;
  const EnrolledData({
    required this.enrolled_id,
    required this.person_id,
    required this.school,
    required this.education_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['enrolled_id'] = Variable<int>(enrolled_id);
    map['person_id'] = Variable<int>(person_id);
    map['school'] = Variable<String>(school);
    map['education_id'] = Variable<int>(education_id);
    return map;
  }

  EnrolledCompanion toCompanion(bool nullToAbsent) {
    return EnrolledCompanion(
      enrolled_id: Value(enrolled_id),
      person_id: Value(person_id),
      school: Value(school),
      education_id: Value(education_id),
    );
  }

  factory EnrolledData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EnrolledData(
      enrolled_id: serializer.fromJson<int>(json['enrolled_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      school: serializer.fromJson<String>(json['school']),
      education_id: serializer.fromJson<int>(json['education_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'enrolled_id': serializer.toJson<int>(enrolled_id),
      'person_id': serializer.toJson<int>(person_id),
      'school': serializer.toJson<String>(school),
      'education_id': serializer.toJson<int>(education_id),
    };
  }

  EnrolledData copyWith({
    int? enrolled_id,
    int? person_id,
    String? school,
    int? education_id,
  }) => EnrolledData(
    enrolled_id: enrolled_id ?? this.enrolled_id,
    person_id: person_id ?? this.person_id,
    school: school ?? this.school,
    education_id: education_id ?? this.education_id,
  );
  EnrolledData copyWithCompanion(EnrolledCompanion data) {
    return EnrolledData(
      enrolled_id:
          data.enrolled_id.present ? data.enrolled_id.value : this.enrolled_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      school: data.school.present ? data.school.value : this.school,
      education_id:
          data.education_id.present
              ? data.education_id.value
              : this.education_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EnrolledData(')
          ..write('enrolled_id: $enrolled_id, ')
          ..write('person_id: $person_id, ')
          ..write('school: $school, ')
          ..write('education_id: $education_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(enrolled_id, person_id, school, education_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EnrolledData &&
          other.enrolled_id == this.enrolled_id &&
          other.person_id == this.person_id &&
          other.school == this.school &&
          other.education_id == this.education_id);
}

class EnrolledCompanion extends UpdateCompanion<EnrolledData> {
  final Value<int> enrolled_id;
  final Value<int> person_id;
  final Value<String> school;
  final Value<int> education_id;
  const EnrolledCompanion({
    this.enrolled_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.school = const Value.absent(),
    this.education_id = const Value.absent(),
  });
  EnrolledCompanion.insert({
    this.enrolled_id = const Value.absent(),
    required int person_id,
    required String school,
    required int education_id,
  }) : person_id = Value(person_id),
       school = Value(school),
       education_id = Value(education_id);
  static Insertable<EnrolledData> custom({
    Expression<int>? enrolled_id,
    Expression<int>? person_id,
    Expression<String>? school,
    Expression<int>? education_id,
  }) {
    return RawValuesInsertable({
      if (enrolled_id != null) 'enrolled_id': enrolled_id,
      if (person_id != null) 'person_id': person_id,
      if (school != null) 'school': school,
      if (education_id != null) 'education_id': education_id,
    });
  }

  EnrolledCompanion copyWith({
    Value<int>? enrolled_id,
    Value<int>? person_id,
    Value<String>? school,
    Value<int>? education_id,
  }) {
    return EnrolledCompanion(
      enrolled_id: enrolled_id ?? this.enrolled_id,
      person_id: person_id ?? this.person_id,
      school: school ?? this.school,
      education_id: education_id ?? this.education_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (enrolled_id.present) {
      map['enrolled_id'] = Variable<int>(enrolled_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (school.present) {
      map['school'] = Variable<String>(school.value);
    }
    if (education_id.present) {
      map['education_id'] = Variable<int>(education_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EnrolledCompanion(')
          ..write('enrolled_id: $enrolled_id, ')
          ..write('person_id: $person_id, ')
          ..write('school: $school, ')
          ..write('education_id: $education_id')
          ..write(')'))
        .toString();
  }
}

class $CTCRecordsTable extends CTCRecords
    with TableInfo<$CTCRecordsTable, CTCRecordData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CTCRecordsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ctc_record_idMeta = const VerificationMeta(
    'ctc_record_id',
  );
  @override
  late final GeneratedColumn<int> ctc_record_id = GeneratedColumn<int>(
    'ctc_record_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _issue_numMeta = const VerificationMeta(
    'issue_num',
  );
  @override
  late final GeneratedColumn<int> issue_num = GeneratedColumn<int>(
    'issue_num',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _place_of_issueMeta = const VerificationMeta(
    'place_of_issue',
  );
  @override
  late final GeneratedColumn<String> place_of_issue = GeneratedColumn<String>(
    'place_of_issue',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _date_of_issueMeta = const VerificationMeta(
    'date_of_issue',
  );
  @override
  late final GeneratedColumn<DateTime> date_of_issue =
      GeneratedColumn<DateTime>(
        'date_of_issue',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    ctc_record_id,
    person_id,
    issue_num,
    place_of_issue,
    date_of_issue,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'c_t_c_records';
  @override
  VerificationContext validateIntegrity(
    Insertable<CTCRecordData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ctc_record_id')) {
      context.handle(
        _ctc_record_idMeta,
        ctc_record_id.isAcceptableOrUnknown(
          data['ctc_record_id']!,
          _ctc_record_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('issue_num')) {
      context.handle(
        _issue_numMeta,
        issue_num.isAcceptableOrUnknown(data['issue_num']!, _issue_numMeta),
      );
    } else if (isInserting) {
      context.missing(_issue_numMeta);
    }
    if (data.containsKey('place_of_issue')) {
      context.handle(
        _place_of_issueMeta,
        place_of_issue.isAcceptableOrUnknown(
          data['place_of_issue']!,
          _place_of_issueMeta,
        ),
      );
    }
    if (data.containsKey('date_of_issue')) {
      context.handle(
        _date_of_issueMeta,
        date_of_issue.isAcceptableOrUnknown(
          data['date_of_issue']!,
          _date_of_issueMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ctc_record_id};
  @override
  CTCRecordData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CTCRecordData(
      ctc_record_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}ctc_record_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      issue_num:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}issue_num'],
          )!,
      place_of_issue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}place_of_issue'],
      ),
      date_of_issue: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date_of_issue'],
      ),
    );
  }

  @override
  $CTCRecordsTable createAlias(String alias) {
    return $CTCRecordsTable(attachedDatabase, alias);
  }
}

class CTCRecordData extends DataClass implements Insertable<CTCRecordData> {
  final int ctc_record_id;
  final int person_id;
  final int issue_num;
  final String? place_of_issue;
  final DateTime? date_of_issue;
  const CTCRecordData({
    required this.ctc_record_id,
    required this.person_id,
    required this.issue_num,
    this.place_of_issue,
    this.date_of_issue,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ctc_record_id'] = Variable<int>(ctc_record_id);
    map['person_id'] = Variable<int>(person_id);
    map['issue_num'] = Variable<int>(issue_num);
    if (!nullToAbsent || place_of_issue != null) {
      map['place_of_issue'] = Variable<String>(place_of_issue);
    }
    if (!nullToAbsent || date_of_issue != null) {
      map['date_of_issue'] = Variable<DateTime>(date_of_issue);
    }
    return map;
  }

  CTCRecordsCompanion toCompanion(bool nullToAbsent) {
    return CTCRecordsCompanion(
      ctc_record_id: Value(ctc_record_id),
      person_id: Value(person_id),
      issue_num: Value(issue_num),
      place_of_issue:
          place_of_issue == null && nullToAbsent
              ? const Value.absent()
              : Value(place_of_issue),
      date_of_issue:
          date_of_issue == null && nullToAbsent
              ? const Value.absent()
              : Value(date_of_issue),
    );
  }

  factory CTCRecordData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CTCRecordData(
      ctc_record_id: serializer.fromJson<int>(json['ctc_record_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      issue_num: serializer.fromJson<int>(json['issue_num']),
      place_of_issue: serializer.fromJson<String?>(json['place_of_issue']),
      date_of_issue: serializer.fromJson<DateTime?>(json['date_of_issue']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ctc_record_id': serializer.toJson<int>(ctc_record_id),
      'person_id': serializer.toJson<int>(person_id),
      'issue_num': serializer.toJson<int>(issue_num),
      'place_of_issue': serializer.toJson<String?>(place_of_issue),
      'date_of_issue': serializer.toJson<DateTime?>(date_of_issue),
    };
  }

  CTCRecordData copyWith({
    int? ctc_record_id,
    int? person_id,
    int? issue_num,
    Value<String?> place_of_issue = const Value.absent(),
    Value<DateTime?> date_of_issue = const Value.absent(),
  }) => CTCRecordData(
    ctc_record_id: ctc_record_id ?? this.ctc_record_id,
    person_id: person_id ?? this.person_id,
    issue_num: issue_num ?? this.issue_num,
    place_of_issue:
        place_of_issue.present ? place_of_issue.value : this.place_of_issue,
    date_of_issue:
        date_of_issue.present ? date_of_issue.value : this.date_of_issue,
  );
  CTCRecordData copyWithCompanion(CTCRecordsCompanion data) {
    return CTCRecordData(
      ctc_record_id:
          data.ctc_record_id.present
              ? data.ctc_record_id.value
              : this.ctc_record_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      issue_num: data.issue_num.present ? data.issue_num.value : this.issue_num,
      place_of_issue:
          data.place_of_issue.present
              ? data.place_of_issue.value
              : this.place_of_issue,
      date_of_issue:
          data.date_of_issue.present
              ? data.date_of_issue.value
              : this.date_of_issue,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CTCRecordData(')
          ..write('ctc_record_id: $ctc_record_id, ')
          ..write('person_id: $person_id, ')
          ..write('issue_num: $issue_num, ')
          ..write('place_of_issue: $place_of_issue, ')
          ..write('date_of_issue: $date_of_issue')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    ctc_record_id,
    person_id,
    issue_num,
    place_of_issue,
    date_of_issue,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CTCRecordData &&
          other.ctc_record_id == this.ctc_record_id &&
          other.person_id == this.person_id &&
          other.issue_num == this.issue_num &&
          other.place_of_issue == this.place_of_issue &&
          other.date_of_issue == this.date_of_issue);
}

class CTCRecordsCompanion extends UpdateCompanion<CTCRecordData> {
  final Value<int> ctc_record_id;
  final Value<int> person_id;
  final Value<int> issue_num;
  final Value<String?> place_of_issue;
  final Value<DateTime?> date_of_issue;
  const CTCRecordsCompanion({
    this.ctc_record_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.issue_num = const Value.absent(),
    this.place_of_issue = const Value.absent(),
    this.date_of_issue = const Value.absent(),
  });
  CTCRecordsCompanion.insert({
    this.ctc_record_id = const Value.absent(),
    required int person_id,
    required int issue_num,
    this.place_of_issue = const Value.absent(),
    this.date_of_issue = const Value.absent(),
  }) : person_id = Value(person_id),
       issue_num = Value(issue_num);
  static Insertable<CTCRecordData> custom({
    Expression<int>? ctc_record_id,
    Expression<int>? person_id,
    Expression<int>? issue_num,
    Expression<String>? place_of_issue,
    Expression<DateTime>? date_of_issue,
  }) {
    return RawValuesInsertable({
      if (ctc_record_id != null) 'ctc_record_id': ctc_record_id,
      if (person_id != null) 'person_id': person_id,
      if (issue_num != null) 'issue_num': issue_num,
      if (place_of_issue != null) 'place_of_issue': place_of_issue,
      if (date_of_issue != null) 'date_of_issue': date_of_issue,
    });
  }

  CTCRecordsCompanion copyWith({
    Value<int>? ctc_record_id,
    Value<int>? person_id,
    Value<int>? issue_num,
    Value<String?>? place_of_issue,
    Value<DateTime?>? date_of_issue,
  }) {
    return CTCRecordsCompanion(
      ctc_record_id: ctc_record_id ?? this.ctc_record_id,
      person_id: person_id ?? this.person_id,
      issue_num: issue_num ?? this.issue_num,
      place_of_issue: place_of_issue ?? this.place_of_issue,
      date_of_issue: date_of_issue ?? this.date_of_issue,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ctc_record_id.present) {
      map['ctc_record_id'] = Variable<int>(ctc_record_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (issue_num.present) {
      map['issue_num'] = Variable<int>(issue_num.value);
    }
    if (place_of_issue.present) {
      map['place_of_issue'] = Variable<String>(place_of_issue.value);
    }
    if (date_of_issue.present) {
      map['date_of_issue'] = Variable<DateTime>(date_of_issue.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CTCRecordsCompanion(')
          ..write('ctc_record_id: $ctc_record_id, ')
          ..write('person_id: $person_id, ')
          ..write('issue_num: $issue_num, ')
          ..write('place_of_issue: $place_of_issue, ')
          ..write('date_of_issue: $date_of_issue')
          ..write(')'))
        .toString();
  }
}

class $BrgyHistoriesTable extends BrgyHistories
    with TableInfo<$BrgyHistoriesTable, BrgyHistoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BrgyHistoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _disability_idMeta = const VerificationMeta(
    'disability_id',
  );
  @override
  late final GeneratedColumn<int> disability_id = GeneratedColumn<int>(
    'disability_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _start_dateMeta = const VerificationMeta(
    'start_date',
  );
  @override
  late final GeneratedColumn<DateTime> start_date = GeneratedColumn<DateTime>(
    'start_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _end_dateMeta = const VerificationMeta(
    'end_date',
  );
  @override
  late final GeneratedColumn<DateTime> end_date = GeneratedColumn<DateTime>(
    'end_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brgyMeta = const VerificationMeta('brgy');
  @override
  late final GeneratedColumn<String> brgy = GeneratedColumn<String>(
    'brgy',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    disability_id,
    person_id,
    start_date,
    end_date,
    brgy,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'brgy_histories';
  @override
  VerificationContext validateIntegrity(
    Insertable<BrgyHistoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('disability_id')) {
      context.handle(
        _disability_idMeta,
        disability_id.isAcceptableOrUnknown(
          data['disability_id']!,
          _disability_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _start_dateMeta,
        start_date.isAcceptableOrUnknown(data['start_date']!, _start_dateMeta),
      );
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _end_dateMeta,
        end_date.isAcceptableOrUnknown(data['end_date']!, _end_dateMeta),
      );
    }
    if (data.containsKey('brgy')) {
      context.handle(
        _brgyMeta,
        brgy.isAcceptableOrUnknown(data['brgy']!, _brgyMeta),
      );
    } else if (isInserting) {
      context.missing(_brgyMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {disability_id};
  @override
  BrgyHistoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BrgyHistoryData(
      disability_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}disability_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      start_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}start_date'],
      ),
      end_date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}end_date'],
      ),
      brgy:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}brgy'],
          )!,
    );
  }

  @override
  $BrgyHistoriesTable createAlias(String alias) {
    return $BrgyHistoriesTable(attachedDatabase, alias);
  }
}

class BrgyHistoryData extends DataClass implements Insertable<BrgyHistoryData> {
  final int disability_id;
  final int person_id;
  final DateTime? start_date;
  final DateTime? end_date;
  final String brgy;
  const BrgyHistoryData({
    required this.disability_id,
    required this.person_id,
    this.start_date,
    this.end_date,
    required this.brgy,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['disability_id'] = Variable<int>(disability_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || start_date != null) {
      map['start_date'] = Variable<DateTime>(start_date);
    }
    if (!nullToAbsent || end_date != null) {
      map['end_date'] = Variable<DateTime>(end_date);
    }
    map['brgy'] = Variable<String>(brgy);
    return map;
  }

  BrgyHistoriesCompanion toCompanion(bool nullToAbsent) {
    return BrgyHistoriesCompanion(
      disability_id: Value(disability_id),
      person_id: Value(person_id),
      start_date:
          start_date == null && nullToAbsent
              ? const Value.absent()
              : Value(start_date),
      end_date:
          end_date == null && nullToAbsent
              ? const Value.absent()
              : Value(end_date),
      brgy: Value(brgy),
    );
  }

  factory BrgyHistoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BrgyHistoryData(
      disability_id: serializer.fromJson<int>(json['disability_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      start_date: serializer.fromJson<DateTime?>(json['start_date']),
      end_date: serializer.fromJson<DateTime?>(json['end_date']),
      brgy: serializer.fromJson<String>(json['brgy']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'disability_id': serializer.toJson<int>(disability_id),
      'person_id': serializer.toJson<int>(person_id),
      'start_date': serializer.toJson<DateTime?>(start_date),
      'end_date': serializer.toJson<DateTime?>(end_date),
      'brgy': serializer.toJson<String>(brgy),
    };
  }

  BrgyHistoryData copyWith({
    int? disability_id,
    int? person_id,
    Value<DateTime?> start_date = const Value.absent(),
    Value<DateTime?> end_date = const Value.absent(),
    String? brgy,
  }) => BrgyHistoryData(
    disability_id: disability_id ?? this.disability_id,
    person_id: person_id ?? this.person_id,
    start_date: start_date.present ? start_date.value : this.start_date,
    end_date: end_date.present ? end_date.value : this.end_date,
    brgy: brgy ?? this.brgy,
  );
  BrgyHistoryData copyWithCompanion(BrgyHistoriesCompanion data) {
    return BrgyHistoryData(
      disability_id:
          data.disability_id.present
              ? data.disability_id.value
              : this.disability_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      start_date:
          data.start_date.present ? data.start_date.value : this.start_date,
      end_date: data.end_date.present ? data.end_date.value : this.end_date,
      brgy: data.brgy.present ? data.brgy.value : this.brgy,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BrgyHistoryData(')
          ..write('disability_id: $disability_id, ')
          ..write('person_id: $person_id, ')
          ..write('start_date: $start_date, ')
          ..write('end_date: $end_date, ')
          ..write('brgy: $brgy')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(disability_id, person_id, start_date, end_date, brgy);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BrgyHistoryData &&
          other.disability_id == this.disability_id &&
          other.person_id == this.person_id &&
          other.start_date == this.start_date &&
          other.end_date == this.end_date &&
          other.brgy == this.brgy);
}

class BrgyHistoriesCompanion extends UpdateCompanion<BrgyHistoryData> {
  final Value<int> disability_id;
  final Value<int> person_id;
  final Value<DateTime?> start_date;
  final Value<DateTime?> end_date;
  final Value<String> brgy;
  const BrgyHistoriesCompanion({
    this.disability_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.start_date = const Value.absent(),
    this.end_date = const Value.absent(),
    this.brgy = const Value.absent(),
  });
  BrgyHistoriesCompanion.insert({
    this.disability_id = const Value.absent(),
    required int person_id,
    this.start_date = const Value.absent(),
    this.end_date = const Value.absent(),
    required String brgy,
  }) : person_id = Value(person_id),
       brgy = Value(brgy);
  static Insertable<BrgyHistoryData> custom({
    Expression<int>? disability_id,
    Expression<int>? person_id,
    Expression<DateTime>? start_date,
    Expression<DateTime>? end_date,
    Expression<String>? brgy,
  }) {
    return RawValuesInsertable({
      if (disability_id != null) 'disability_id': disability_id,
      if (person_id != null) 'person_id': person_id,
      if (start_date != null) 'start_date': start_date,
      if (end_date != null) 'end_date': end_date,
      if (brgy != null) 'brgy': brgy,
    });
  }

  BrgyHistoriesCompanion copyWith({
    Value<int>? disability_id,
    Value<int>? person_id,
    Value<DateTime?>? start_date,
    Value<DateTime?>? end_date,
    Value<String>? brgy,
  }) {
    return BrgyHistoriesCompanion(
      disability_id: disability_id ?? this.disability_id,
      person_id: person_id ?? this.person_id,
      start_date: start_date ?? this.start_date,
      end_date: end_date ?? this.end_date,
      brgy: brgy ?? this.brgy,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (disability_id.present) {
      map['disability_id'] = Variable<int>(disability_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (start_date.present) {
      map['start_date'] = Variable<DateTime>(start_date.value);
    }
    if (end_date.present) {
      map['end_date'] = Variable<DateTime>(end_date.value);
    }
    if (brgy.present) {
      map['brgy'] = Variable<String>(brgy.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BrgyHistoriesCompanion(')
          ..write('disability_id: $disability_id, ')
          ..write('person_id: $person_id, ')
          ..write('start_date: $start_date, ')
          ..write('end_date: $end_date, ')
          ..write('brgy: $brgy')
          ..write(')'))
        .toString();
  }
}

class $MigrantTransientsTable extends MigrantTransients
    with TableInfo<$MigrantTransientsTable, MigrantTransientData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MigrantTransientsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _migrant_transient_idMeta =
      const VerificationMeta('migrant_transient_id');
  @override
  late final GeneratedColumn<int> migrant_transient_id = GeneratedColumn<int>(
    'migrant_transient_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Transient?, String> type =
      GeneratedColumn<String>(
        'type',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Transient?>($MigrantTransientsTable.$convertertypen);
  static const VerificationMeta _reason_of_leavingMeta = const VerificationMeta(
    'reason_of_leaving',
  );
  @override
  late final GeneratedColumn<String> reason_of_leaving =
      GeneratedColumn<String>(
        'reason_of_leaving',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _reason_of_transferMeta =
      const VerificationMeta('reason_of_transfer');
  @override
  late final GeneratedColumn<String> reason_of_transfer =
      GeneratedColumn<String>(
        'reason_of_transfer',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _stay_durationMeta = const VerificationMeta(
    'stay_duration',
  );
  @override
  late final GeneratedColumn<int> stay_duration = GeneratedColumn<int>(
    'stay_duration',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    migrant_transient_id,
    person_id,
    date,
    type,
    reason_of_leaving,
    reason_of_transfer,
    stay_duration,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'migrant_transients';
  @override
  VerificationContext validateIntegrity(
    Insertable<MigrantTransientData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('migrant_transient_id')) {
      context.handle(
        _migrant_transient_idMeta,
        migrant_transient_id.isAcceptableOrUnknown(
          data['migrant_transient_id']!,
          _migrant_transient_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    }
    if (data.containsKey('reason_of_leaving')) {
      context.handle(
        _reason_of_leavingMeta,
        reason_of_leaving.isAcceptableOrUnknown(
          data['reason_of_leaving']!,
          _reason_of_leavingMeta,
        ),
      );
    }
    if (data.containsKey('reason_of_transfer')) {
      context.handle(
        _reason_of_transferMeta,
        reason_of_transfer.isAcceptableOrUnknown(
          data['reason_of_transfer']!,
          _reason_of_transferMeta,
        ),
      );
    }
    if (data.containsKey('stay_duration')) {
      context.handle(
        _stay_durationMeta,
        stay_duration.isAcceptableOrUnknown(
          data['stay_duration']!,
          _stay_durationMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {migrant_transient_id};
  @override
  MigrantTransientData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MigrantTransientData(
      migrant_transient_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}migrant_transient_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      ),
      type: $MigrantTransientsTable.$convertertypen.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}type'],
        ),
      ),
      reason_of_leaving: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason_of_leaving'],
      ),
      reason_of_transfer: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason_of_transfer'],
      ),
      stay_duration: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}stay_duration'],
      ),
    );
  }

  @override
  $MigrantTransientsTable createAlias(String alias) {
    return $MigrantTransientsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<Transient, String, String> $convertertype =
      const EnumNameConverter<Transient>(Transient.values);
  static JsonTypeConverter2<Transient?, String?, String?> $convertertypen =
      JsonTypeConverter2.asNullable($convertertype);
}

class MigrantTransientData extends DataClass
    implements Insertable<MigrantTransientData> {
  final int migrant_transient_id;
  final int person_id;
  final DateTime? date;
  final Transient? type;
  final String? reason_of_leaving;
  final String? reason_of_transfer;
  final int? stay_duration;
  const MigrantTransientData({
    required this.migrant_transient_id,
    required this.person_id,
    this.date,
    this.type,
    this.reason_of_leaving,
    this.reason_of_transfer,
    this.stay_duration,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['migrant_transient_id'] = Variable<int>(migrant_transient_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || date != null) {
      map['date'] = Variable<DateTime>(date);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(
        $MigrantTransientsTable.$convertertypen.toSql(type),
      );
    }
    if (!nullToAbsent || reason_of_leaving != null) {
      map['reason_of_leaving'] = Variable<String>(reason_of_leaving);
    }
    if (!nullToAbsent || reason_of_transfer != null) {
      map['reason_of_transfer'] = Variable<String>(reason_of_transfer);
    }
    if (!nullToAbsent || stay_duration != null) {
      map['stay_duration'] = Variable<int>(stay_duration);
    }
    return map;
  }

  MigrantTransientsCompanion toCompanion(bool nullToAbsent) {
    return MigrantTransientsCompanion(
      migrant_transient_id: Value(migrant_transient_id),
      person_id: Value(person_id),
      date: date == null && nullToAbsent ? const Value.absent() : Value(date),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      reason_of_leaving:
          reason_of_leaving == null && nullToAbsent
              ? const Value.absent()
              : Value(reason_of_leaving),
      reason_of_transfer:
          reason_of_transfer == null && nullToAbsent
              ? const Value.absent()
              : Value(reason_of_transfer),
      stay_duration:
          stay_duration == null && nullToAbsent
              ? const Value.absent()
              : Value(stay_duration),
    );
  }

  factory MigrantTransientData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MigrantTransientData(
      migrant_transient_id: serializer.fromJson<int>(
        json['migrant_transient_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
      date: serializer.fromJson<DateTime?>(json['date']),
      type: $MigrantTransientsTable.$convertertypen.fromJson(
        serializer.fromJson<String?>(json['type']),
      ),
      reason_of_leaving: serializer.fromJson<String?>(
        json['reason_of_leaving'],
      ),
      reason_of_transfer: serializer.fromJson<String?>(
        json['reason_of_transfer'],
      ),
      stay_duration: serializer.fromJson<int?>(json['stay_duration']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'migrant_transient_id': serializer.toJson<int>(migrant_transient_id),
      'person_id': serializer.toJson<int>(person_id),
      'date': serializer.toJson<DateTime?>(date),
      'type': serializer.toJson<String?>(
        $MigrantTransientsTable.$convertertypen.toJson(type),
      ),
      'reason_of_leaving': serializer.toJson<String?>(reason_of_leaving),
      'reason_of_transfer': serializer.toJson<String?>(reason_of_transfer),
      'stay_duration': serializer.toJson<int?>(stay_duration),
    };
  }

  MigrantTransientData copyWith({
    int? migrant_transient_id,
    int? person_id,
    Value<DateTime?> date = const Value.absent(),
    Value<Transient?> type = const Value.absent(),
    Value<String?> reason_of_leaving = const Value.absent(),
    Value<String?> reason_of_transfer = const Value.absent(),
    Value<int?> stay_duration = const Value.absent(),
  }) => MigrantTransientData(
    migrant_transient_id: migrant_transient_id ?? this.migrant_transient_id,
    person_id: person_id ?? this.person_id,
    date: date.present ? date.value : this.date,
    type: type.present ? type.value : this.type,
    reason_of_leaving:
        reason_of_leaving.present
            ? reason_of_leaving.value
            : this.reason_of_leaving,
    reason_of_transfer:
        reason_of_transfer.present
            ? reason_of_transfer.value
            : this.reason_of_transfer,
    stay_duration:
        stay_duration.present ? stay_duration.value : this.stay_duration,
  );
  MigrantTransientData copyWithCompanion(MigrantTransientsCompanion data) {
    return MigrantTransientData(
      migrant_transient_id:
          data.migrant_transient_id.present
              ? data.migrant_transient_id.value
              : this.migrant_transient_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      date: data.date.present ? data.date.value : this.date,
      type: data.type.present ? data.type.value : this.type,
      reason_of_leaving:
          data.reason_of_leaving.present
              ? data.reason_of_leaving.value
              : this.reason_of_leaving,
      reason_of_transfer:
          data.reason_of_transfer.present
              ? data.reason_of_transfer.value
              : this.reason_of_transfer,
      stay_duration:
          data.stay_duration.present
              ? data.stay_duration.value
              : this.stay_duration,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MigrantTransientData(')
          ..write('migrant_transient_id: $migrant_transient_id, ')
          ..write('person_id: $person_id, ')
          ..write('date: $date, ')
          ..write('type: $type, ')
          ..write('reason_of_leaving: $reason_of_leaving, ')
          ..write('reason_of_transfer: $reason_of_transfer, ')
          ..write('stay_duration: $stay_duration')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    migrant_transient_id,
    person_id,
    date,
    type,
    reason_of_leaving,
    reason_of_transfer,
    stay_duration,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MigrantTransientData &&
          other.migrant_transient_id == this.migrant_transient_id &&
          other.person_id == this.person_id &&
          other.date == this.date &&
          other.type == this.type &&
          other.reason_of_leaving == this.reason_of_leaving &&
          other.reason_of_transfer == this.reason_of_transfer &&
          other.stay_duration == this.stay_duration);
}

class MigrantTransientsCompanion extends UpdateCompanion<MigrantTransientData> {
  final Value<int> migrant_transient_id;
  final Value<int> person_id;
  final Value<DateTime?> date;
  final Value<Transient?> type;
  final Value<String?> reason_of_leaving;
  final Value<String?> reason_of_transfer;
  final Value<int?> stay_duration;
  const MigrantTransientsCompanion({
    this.migrant_transient_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.date = const Value.absent(),
    this.type = const Value.absent(),
    this.reason_of_leaving = const Value.absent(),
    this.reason_of_transfer = const Value.absent(),
    this.stay_duration = const Value.absent(),
  });
  MigrantTransientsCompanion.insert({
    this.migrant_transient_id = const Value.absent(),
    required int person_id,
    this.date = const Value.absent(),
    this.type = const Value.absent(),
    this.reason_of_leaving = const Value.absent(),
    this.reason_of_transfer = const Value.absent(),
    this.stay_duration = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<MigrantTransientData> custom({
    Expression<int>? migrant_transient_id,
    Expression<int>? person_id,
    Expression<DateTime>? date,
    Expression<String>? type,
    Expression<String>? reason_of_leaving,
    Expression<String>? reason_of_transfer,
    Expression<int>? stay_duration,
  }) {
    return RawValuesInsertable({
      if (migrant_transient_id != null)
        'migrant_transient_id': migrant_transient_id,
      if (person_id != null) 'person_id': person_id,
      if (date != null) 'date': date,
      if (type != null) 'type': type,
      if (reason_of_leaving != null) 'reason_of_leaving': reason_of_leaving,
      if (reason_of_transfer != null) 'reason_of_transfer': reason_of_transfer,
      if (stay_duration != null) 'stay_duration': stay_duration,
    });
  }

  MigrantTransientsCompanion copyWith({
    Value<int>? migrant_transient_id,
    Value<int>? person_id,
    Value<DateTime?>? date,
    Value<Transient?>? type,
    Value<String?>? reason_of_leaving,
    Value<String?>? reason_of_transfer,
    Value<int?>? stay_duration,
  }) {
    return MigrantTransientsCompanion(
      migrant_transient_id: migrant_transient_id ?? this.migrant_transient_id,
      person_id: person_id ?? this.person_id,
      date: date ?? this.date,
      type: type ?? this.type,
      reason_of_leaving: reason_of_leaving ?? this.reason_of_leaving,
      reason_of_transfer: reason_of_transfer ?? this.reason_of_transfer,
      stay_duration: stay_duration ?? this.stay_duration,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (migrant_transient_id.present) {
      map['migrant_transient_id'] = Variable<int>(migrant_transient_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(
        $MigrantTransientsTable.$convertertypen.toSql(type.value),
      );
    }
    if (reason_of_leaving.present) {
      map['reason_of_leaving'] = Variable<String>(reason_of_leaving.value);
    }
    if (reason_of_transfer.present) {
      map['reason_of_transfer'] = Variable<String>(reason_of_transfer.value);
    }
    if (stay_duration.present) {
      map['stay_duration'] = Variable<int>(stay_duration.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MigrantTransientsCompanion(')
          ..write('migrant_transient_id: $migrant_transient_id, ')
          ..write('person_id: $person_id, ')
          ..write('date: $date, ')
          ..write('type: $type, ')
          ..write('reason_of_leaving: $reason_of_leaving, ')
          ..write('reason_of_transfer: $reason_of_transfer, ')
          ..write('stay_duration: $stay_duration')
          ..write(')'))
        .toString();
  }
}

class $RelationshipTypesTable extends RelationshipTypes
    with TableInfo<$RelationshipTypesTable, RelationshipTypeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RelationshipTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _relationship_idMeta = const VerificationMeta(
    'relationship_id',
  );
  @override
  late final GeneratedColumn<int> relationship_id = GeneratedColumn<int>(
    'relationship_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _relationshipMeta = const VerificationMeta(
    'relationship',
  );
  @override
  late final GeneratedColumn<String> relationship = GeneratedColumn<String>(
    'relationship',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [relationship_id, relationship];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'relationship_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<RelationshipTypeData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('relationship_id')) {
      context.handle(
        _relationship_idMeta,
        relationship_id.isAcceptableOrUnknown(
          data['relationship_id']!,
          _relationship_idMeta,
        ),
      );
    }
    if (data.containsKey('relationship')) {
      context.handle(
        _relationshipMeta,
        relationship.isAcceptableOrUnknown(
          data['relationship']!,
          _relationshipMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_relationshipMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {relationship_id};
  @override
  RelationshipTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RelationshipTypeData(
      relationship_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}relationship_id'],
          )!,
      relationship:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}relationship'],
          )!,
    );
  }

  @override
  $RelationshipTypesTable createAlias(String alias) {
    return $RelationshipTypesTable(attachedDatabase, alias);
  }
}

class RelationshipTypeData extends DataClass
    implements Insertable<RelationshipTypeData> {
  final int relationship_id;
  final String relationship;
  const RelationshipTypeData({
    required this.relationship_id,
    required this.relationship,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['relationship_id'] = Variable<int>(relationship_id);
    map['relationship'] = Variable<String>(relationship);
    return map;
  }

  RelationshipTypesCompanion toCompanion(bool nullToAbsent) {
    return RelationshipTypesCompanion(
      relationship_id: Value(relationship_id),
      relationship: Value(relationship),
    );
  }

  factory RelationshipTypeData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RelationshipTypeData(
      relationship_id: serializer.fromJson<int>(json['relationship_id']),
      relationship: serializer.fromJson<String>(json['relationship']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'relationship_id': serializer.toJson<int>(relationship_id),
      'relationship': serializer.toJson<String>(relationship),
    };
  }

  RelationshipTypeData copyWith({int? relationship_id, String? relationship}) =>
      RelationshipTypeData(
        relationship_id: relationship_id ?? this.relationship_id,
        relationship: relationship ?? this.relationship,
      );
  RelationshipTypeData copyWithCompanion(RelationshipTypesCompanion data) {
    return RelationshipTypeData(
      relationship_id:
          data.relationship_id.present
              ? data.relationship_id.value
              : this.relationship_id,
      relationship:
          data.relationship.present
              ? data.relationship.value
              : this.relationship,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RelationshipTypeData(')
          ..write('relationship_id: $relationship_id, ')
          ..write('relationship: $relationship')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(relationship_id, relationship);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RelationshipTypeData &&
          other.relationship_id == this.relationship_id &&
          other.relationship == this.relationship);
}

class RelationshipTypesCompanion extends UpdateCompanion<RelationshipTypeData> {
  final Value<int> relationship_id;
  final Value<String> relationship;
  const RelationshipTypesCompanion({
    this.relationship_id = const Value.absent(),
    this.relationship = const Value.absent(),
  });
  RelationshipTypesCompanion.insert({
    this.relationship_id = const Value.absent(),
    required String relationship,
  }) : relationship = Value(relationship);
  static Insertable<RelationshipTypeData> custom({
    Expression<int>? relationship_id,
    Expression<String>? relationship,
  }) {
    return RawValuesInsertable({
      if (relationship_id != null) 'relationship_id': relationship_id,
      if (relationship != null) 'relationship': relationship,
    });
  }

  RelationshipTypesCompanion copyWith({
    Value<int>? relationship_id,
    Value<String>? relationship,
  }) {
    return RelationshipTypesCompanion(
      relationship_id: relationship_id ?? this.relationship_id,
      relationship: relationship ?? this.relationship,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (relationship_id.present) {
      map['relationship_id'] = Variable<int>(relationship_id.value);
    }
    if (relationship.present) {
      map['relationship'] = Variable<String>(relationship.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RelationshipTypesCompanion(')
          ..write('relationship_id: $relationship_id, ')
          ..write('relationship: $relationship')
          ..write(')'))
        .toString();
  }
}

class $HouseholdRelationshipsTable extends HouseholdRelationships
    with TableInfo<$HouseholdRelationshipsTable, HouseholdRelationship> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdRelationshipsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _household_relationship_idMeta =
      const VerificationMeta('household_relationship_id');
  @override
  late final GeneratedColumn<int> household_relationship_id =
      GeneratedColumn<int>(
        'household_relationship_id',
        aliasedName,
        false,
        hasAutoIncrement: true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'PRIMARY KEY AUTOINCREMENT',
        ),
      );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _relationship_idMeta = const VerificationMeta(
    'relationship_id',
  );
  @override
  late final GeneratedColumn<int> relationship_id = GeneratedColumn<int>(
    'relationship_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES relationship_types (relationship_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    household_relationship_id,
    person_id,
    household_id,
    relationship_id,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household_relationships';
  @override
  VerificationContext validateIntegrity(
    Insertable<HouseholdRelationship> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('household_relationship_id')) {
      context.handle(
        _household_relationship_idMeta,
        household_relationship_id.isAcceptableOrUnknown(
          data['household_relationship_id']!,
          _household_relationship_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('relationship_id')) {
      context.handle(
        _relationship_idMeta,
        relationship_id.isAcceptableOrUnknown(
          data['relationship_id']!,
          _relationship_idMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {household_relationship_id};
  @override
  HouseholdRelationship map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdRelationship(
      household_relationship_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_relationship_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      relationship_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}relationship_id'],
      ),
    );
  }

  @override
  $HouseholdRelationshipsTable createAlias(String alias) {
    return $HouseholdRelationshipsTable(attachedDatabase, alias);
  }
}

class HouseholdRelationship extends DataClass
    implements Insertable<HouseholdRelationship> {
  final int household_relationship_id;
  final int person_id;
  final int household_id;
  final int? relationship_id;
  const HouseholdRelationship({
    required this.household_relationship_id,
    required this.person_id,
    required this.household_id,
    this.relationship_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['household_relationship_id'] = Variable<int>(household_relationship_id);
    map['person_id'] = Variable<int>(person_id);
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || relationship_id != null) {
      map['relationship_id'] = Variable<int>(relationship_id);
    }
    return map;
  }

  HouseholdRelationshipsCompanion toCompanion(bool nullToAbsent) {
    return HouseholdRelationshipsCompanion(
      household_relationship_id: Value(household_relationship_id),
      person_id: Value(person_id),
      household_id: Value(household_id),
      relationship_id:
          relationship_id == null && nullToAbsent
              ? const Value.absent()
              : Value(relationship_id),
    );
  }

  factory HouseholdRelationship.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdRelationship(
      household_relationship_id: serializer.fromJson<int>(
        json['household_relationship_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
      household_id: serializer.fromJson<int>(json['household_id']),
      relationship_id: serializer.fromJson<int?>(json['relationship_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'household_relationship_id': serializer.toJson<int>(
        household_relationship_id,
      ),
      'person_id': serializer.toJson<int>(person_id),
      'household_id': serializer.toJson<int>(household_id),
      'relationship_id': serializer.toJson<int?>(relationship_id),
    };
  }

  HouseholdRelationship copyWith({
    int? household_relationship_id,
    int? person_id,
    int? household_id,
    Value<int?> relationship_id = const Value.absent(),
  }) => HouseholdRelationship(
    household_relationship_id:
        household_relationship_id ?? this.household_relationship_id,
    person_id: person_id ?? this.person_id,
    household_id: household_id ?? this.household_id,
    relationship_id:
        relationship_id.present ? relationship_id.value : this.relationship_id,
  );
  HouseholdRelationship copyWithCompanion(
    HouseholdRelationshipsCompanion data,
  ) {
    return HouseholdRelationship(
      household_relationship_id:
          data.household_relationship_id.present
              ? data.household_relationship_id.value
              : this.household_relationship_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      relationship_id:
          data.relationship_id.present
              ? data.relationship_id.value
              : this.relationship_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdRelationship(')
          ..write('household_relationship_id: $household_relationship_id, ')
          ..write('person_id: $person_id, ')
          ..write('household_id: $household_id, ')
          ..write('relationship_id: $relationship_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    household_relationship_id,
    person_id,
    household_id,
    relationship_id,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdRelationship &&
          other.household_relationship_id == this.household_relationship_id &&
          other.person_id == this.person_id &&
          other.household_id == this.household_id &&
          other.relationship_id == this.relationship_id);
}

class HouseholdRelationshipsCompanion
    extends UpdateCompanion<HouseholdRelationship> {
  final Value<int> household_relationship_id;
  final Value<int> person_id;
  final Value<int> household_id;
  final Value<int?> relationship_id;
  const HouseholdRelationshipsCompanion({
    this.household_relationship_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.relationship_id = const Value.absent(),
  });
  HouseholdRelationshipsCompanion.insert({
    this.household_relationship_id = const Value.absent(),
    required int person_id,
    required int household_id,
    this.relationship_id = const Value.absent(),
  }) : person_id = Value(person_id),
       household_id = Value(household_id);
  static Insertable<HouseholdRelationship> custom({
    Expression<int>? household_relationship_id,
    Expression<int>? person_id,
    Expression<int>? household_id,
    Expression<int>? relationship_id,
  }) {
    return RawValuesInsertable({
      if (household_relationship_id != null)
        'household_relationship_id': household_relationship_id,
      if (person_id != null) 'person_id': person_id,
      if (household_id != null) 'household_id': household_id,
      if (relationship_id != null) 'relationship_id': relationship_id,
    });
  }

  HouseholdRelationshipsCompanion copyWith({
    Value<int>? household_relationship_id,
    Value<int>? person_id,
    Value<int>? household_id,
    Value<int?>? relationship_id,
  }) {
    return HouseholdRelationshipsCompanion(
      household_relationship_id:
          household_relationship_id ?? this.household_relationship_id,
      person_id: person_id ?? this.person_id,
      household_id: household_id ?? this.household_id,
      relationship_id: relationship_id ?? this.relationship_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (household_relationship_id.present) {
      map['household_relationship_id'] = Variable<int>(
        household_relationship_id.value,
      );
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (relationship_id.present) {
      map['relationship_id'] = Variable<int>(relationship_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdRelationshipsCompanion(')
          ..write('household_relationship_id: $household_relationship_id, ')
          ..write('person_id: $person_id, ')
          ..write('household_id: $household_id, ')
          ..write('relationship_id: $relationship_id')
          ..write(')'))
        .toString();
  }
}

class $ServicesTable extends Services
    with TableInfo<$ServicesTable, ServiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServicesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _service_idMeta = const VerificationMeta(
    'service_id',
  );
  @override
  late final GeneratedColumn<int> service_id = GeneratedColumn<int>(
    'service_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _serviceMeta = const VerificationMeta(
    'service',
  );
  @override
  late final GeneratedColumn<String> service = GeneratedColumn<String>(
    'service',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<ClientTypes?, String>
  client_type_id = GeneratedColumn<String>(
    'client_type_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<ClientTypes?>($ServicesTable.$converterclient_type_idn);
  static const VerificationMeta _ave_client_numMeta = const VerificationMeta(
    'ave_client_num',
  );
  @override
  late final GeneratedColumn<int> ave_client_num = GeneratedColumn<int>(
    'ave_client_num',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    service_id,
    service,
    household_id,
    client_type_id,
    ave_client_num,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'services';
  @override
  VerificationContext validateIntegrity(
    Insertable<ServiceData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('service_id')) {
      context.handle(
        _service_idMeta,
        service_id.isAcceptableOrUnknown(data['service_id']!, _service_idMeta),
      );
    }
    if (data.containsKey('service')) {
      context.handle(
        _serviceMeta,
        service.isAcceptableOrUnknown(data['service']!, _serviceMeta),
      );
    } else if (isInserting) {
      context.missing(_serviceMeta);
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('ave_client_num')) {
      context.handle(
        _ave_client_numMeta,
        ave_client_num.isAcceptableOrUnknown(
          data['ave_client_num']!,
          _ave_client_numMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {service_id};
  @override
  ServiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceData(
      service_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}service_id'],
          )!,
      service:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}service'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      client_type_id: $ServicesTable.$converterclient_type_idn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}client_type_id'],
        ),
      ),
      ave_client_num: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}ave_client_num'],
      ),
    );
  }

  @override
  $ServicesTable createAlias(String alias) {
    return $ServicesTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<ClientTypes, String, String>
  $converterclient_type_id = const EnumNameConverter<ClientTypes>(
    ClientTypes.values,
  );
  static JsonTypeConverter2<ClientTypes?, String?, String?>
  $converterclient_type_idn = JsonTypeConverter2.asNullable(
    $converterclient_type_id,
  );
}

class ServiceData extends DataClass implements Insertable<ServiceData> {
  final int service_id;
  final String service;
  final int household_id;
  final ClientTypes? client_type_id;
  final int? ave_client_num;
  const ServiceData({
    required this.service_id,
    required this.service,
    required this.household_id,
    this.client_type_id,
    this.ave_client_num,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['service_id'] = Variable<int>(service_id);
    map['service'] = Variable<String>(service);
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || client_type_id != null) {
      map['client_type_id'] = Variable<String>(
        $ServicesTable.$converterclient_type_idn.toSql(client_type_id),
      );
    }
    if (!nullToAbsent || ave_client_num != null) {
      map['ave_client_num'] = Variable<int>(ave_client_num);
    }
    return map;
  }

  ServicesCompanion toCompanion(bool nullToAbsent) {
    return ServicesCompanion(
      service_id: Value(service_id),
      service: Value(service),
      household_id: Value(household_id),
      client_type_id:
          client_type_id == null && nullToAbsent
              ? const Value.absent()
              : Value(client_type_id),
      ave_client_num:
          ave_client_num == null && nullToAbsent
              ? const Value.absent()
              : Value(ave_client_num),
    );
  }

  factory ServiceData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceData(
      service_id: serializer.fromJson<int>(json['service_id']),
      service: serializer.fromJson<String>(json['service']),
      household_id: serializer.fromJson<int>(json['household_id']),
      client_type_id: $ServicesTable.$converterclient_type_idn.fromJson(
        serializer.fromJson<String?>(json['client_type_id']),
      ),
      ave_client_num: serializer.fromJson<int?>(json['ave_client_num']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'service_id': serializer.toJson<int>(service_id),
      'service': serializer.toJson<String>(service),
      'household_id': serializer.toJson<int>(household_id),
      'client_type_id': serializer.toJson<String?>(
        $ServicesTable.$converterclient_type_idn.toJson(client_type_id),
      ),
      'ave_client_num': serializer.toJson<int?>(ave_client_num),
    };
  }

  ServiceData copyWith({
    int? service_id,
    String? service,
    int? household_id,
    Value<ClientTypes?> client_type_id = const Value.absent(),
    Value<int?> ave_client_num = const Value.absent(),
  }) => ServiceData(
    service_id: service_id ?? this.service_id,
    service: service ?? this.service,
    household_id: household_id ?? this.household_id,
    client_type_id:
        client_type_id.present ? client_type_id.value : this.client_type_id,
    ave_client_num:
        ave_client_num.present ? ave_client_num.value : this.ave_client_num,
  );
  ServiceData copyWithCompanion(ServicesCompanion data) {
    return ServiceData(
      service_id:
          data.service_id.present ? data.service_id.value : this.service_id,
      service: data.service.present ? data.service.value : this.service,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      client_type_id:
          data.client_type_id.present
              ? data.client_type_id.value
              : this.client_type_id,
      ave_client_num:
          data.ave_client_num.present
              ? data.ave_client_num.value
              : this.ave_client_num,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ServiceData(')
          ..write('service_id: $service_id, ')
          ..write('service: $service, ')
          ..write('household_id: $household_id, ')
          ..write('client_type_id: $client_type_id, ')
          ..write('ave_client_num: $ave_client_num')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    service_id,
    service,
    household_id,
    client_type_id,
    ave_client_num,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceData &&
          other.service_id == this.service_id &&
          other.service == this.service &&
          other.household_id == this.household_id &&
          other.client_type_id == this.client_type_id &&
          other.ave_client_num == this.ave_client_num);
}

class ServicesCompanion extends UpdateCompanion<ServiceData> {
  final Value<int> service_id;
  final Value<String> service;
  final Value<int> household_id;
  final Value<ClientTypes?> client_type_id;
  final Value<int?> ave_client_num;
  const ServicesCompanion({
    this.service_id = const Value.absent(),
    this.service = const Value.absent(),
    this.household_id = const Value.absent(),
    this.client_type_id = const Value.absent(),
    this.ave_client_num = const Value.absent(),
  });
  ServicesCompanion.insert({
    this.service_id = const Value.absent(),
    required String service,
    required int household_id,
    this.client_type_id = const Value.absent(),
    this.ave_client_num = const Value.absent(),
  }) : service = Value(service),
       household_id = Value(household_id);
  static Insertable<ServiceData> custom({
    Expression<int>? service_id,
    Expression<String>? service,
    Expression<int>? household_id,
    Expression<String>? client_type_id,
    Expression<int>? ave_client_num,
  }) {
    return RawValuesInsertable({
      if (service_id != null) 'service_id': service_id,
      if (service != null) 'service': service,
      if (household_id != null) 'household_id': household_id,
      if (client_type_id != null) 'client_type_id': client_type_id,
      if (ave_client_num != null) 'ave_client_num': ave_client_num,
    });
  }

  ServicesCompanion copyWith({
    Value<int>? service_id,
    Value<String>? service,
    Value<int>? household_id,
    Value<ClientTypes?>? client_type_id,
    Value<int?>? ave_client_num,
  }) {
    return ServicesCompanion(
      service_id: service_id ?? this.service_id,
      service: service ?? this.service,
      household_id: household_id ?? this.household_id,
      client_type_id: client_type_id ?? this.client_type_id,
      ave_client_num: ave_client_num ?? this.ave_client_num,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (service_id.present) {
      map['service_id'] = Variable<int>(service_id.value);
    }
    if (service.present) {
      map['service'] = Variable<String>(service.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (client_type_id.present) {
      map['client_type_id'] = Variable<String>(
        $ServicesTable.$converterclient_type_idn.toSql(client_type_id.value),
      );
    }
    if (ave_client_num.present) {
      map['ave_client_num'] = Variable<int>(ave_client_num.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServicesCompanion(')
          ..write('service_id: $service_id, ')
          ..write('service: $service, ')
          ..write('household_id: $household_id, ')
          ..write('client_type_id: $client_type_id, ')
          ..write('ave_client_num: $ave_client_num')
          ..write(')'))
        .toString();
  }
}

class $PrimaryNeedsTable extends PrimaryNeeds
    with TableInfo<$PrimaryNeedsTable, PrimaryNeedData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PrimaryNeedsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _primary_need_idMeta = const VerificationMeta(
    'primary_need_id',
  );
  @override
  late final GeneratedColumn<int> primary_need_id = GeneratedColumn<int>(
    'primary_need_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _needMeta = const VerificationMeta('need');
  @override
  late final GeneratedColumn<String> need = GeneratedColumn<String>(
    'need',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priorityMeta = const VerificationMeta(
    'priority',
  );
  @override
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
    'priority',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    primary_need_id,
    household_id,
    need,
    priority,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'primary_needs';
  @override
  VerificationContext validateIntegrity(
    Insertable<PrimaryNeedData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('primary_need_id')) {
      context.handle(
        _primary_need_idMeta,
        primary_need_id.isAcceptableOrUnknown(
          data['primary_need_id']!,
          _primary_need_idMeta,
        ),
      );
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('need')) {
      context.handle(
        _needMeta,
        need.isAcceptableOrUnknown(data['need']!, _needMeta),
      );
    } else if (isInserting) {
      context.missing(_needMeta);
    }
    if (data.containsKey('priority')) {
      context.handle(
        _priorityMeta,
        priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta),
      );
    } else if (isInserting) {
      context.missing(_priorityMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {primary_need_id};
  @override
  PrimaryNeedData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PrimaryNeedData(
      primary_need_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}primary_need_id'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      need:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}need'],
          )!,
      priority:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}priority'],
          )!,
    );
  }

  @override
  $PrimaryNeedsTable createAlias(String alias) {
    return $PrimaryNeedsTable(attachedDatabase, alias);
  }
}

class PrimaryNeedData extends DataClass implements Insertable<PrimaryNeedData> {
  final int primary_need_id;
  final int household_id;
  final String need;
  final int priority;
  const PrimaryNeedData({
    required this.primary_need_id,
    required this.household_id,
    required this.need,
    required this.priority,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['primary_need_id'] = Variable<int>(primary_need_id);
    map['household_id'] = Variable<int>(household_id);
    map['need'] = Variable<String>(need);
    map['priority'] = Variable<int>(priority);
    return map;
  }

  PrimaryNeedsCompanion toCompanion(bool nullToAbsent) {
    return PrimaryNeedsCompanion(
      primary_need_id: Value(primary_need_id),
      household_id: Value(household_id),
      need: Value(need),
      priority: Value(priority),
    );
  }

  factory PrimaryNeedData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PrimaryNeedData(
      primary_need_id: serializer.fromJson<int>(json['primary_need_id']),
      household_id: serializer.fromJson<int>(json['household_id']),
      need: serializer.fromJson<String>(json['need']),
      priority: serializer.fromJson<int>(json['priority']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'primary_need_id': serializer.toJson<int>(primary_need_id),
      'household_id': serializer.toJson<int>(household_id),
      'need': serializer.toJson<String>(need),
      'priority': serializer.toJson<int>(priority),
    };
  }

  PrimaryNeedData copyWith({
    int? primary_need_id,
    int? household_id,
    String? need,
    int? priority,
  }) => PrimaryNeedData(
    primary_need_id: primary_need_id ?? this.primary_need_id,
    household_id: household_id ?? this.household_id,
    need: need ?? this.need,
    priority: priority ?? this.priority,
  );
  PrimaryNeedData copyWithCompanion(PrimaryNeedsCompanion data) {
    return PrimaryNeedData(
      primary_need_id:
          data.primary_need_id.present
              ? data.primary_need_id.value
              : this.primary_need_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      need: data.need.present ? data.need.value : this.need,
      priority: data.priority.present ? data.priority.value : this.priority,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PrimaryNeedData(')
          ..write('primary_need_id: $primary_need_id, ')
          ..write('household_id: $household_id, ')
          ..write('need: $need, ')
          ..write('priority: $priority')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(primary_need_id, household_id, need, priority);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PrimaryNeedData &&
          other.primary_need_id == this.primary_need_id &&
          other.household_id == this.household_id &&
          other.need == this.need &&
          other.priority == this.priority);
}

class PrimaryNeedsCompanion extends UpdateCompanion<PrimaryNeedData> {
  final Value<int> primary_need_id;
  final Value<int> household_id;
  final Value<String> need;
  final Value<int> priority;
  const PrimaryNeedsCompanion({
    this.primary_need_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.need = const Value.absent(),
    this.priority = const Value.absent(),
  });
  PrimaryNeedsCompanion.insert({
    this.primary_need_id = const Value.absent(),
    required int household_id,
    required String need,
    required int priority,
  }) : household_id = Value(household_id),
       need = Value(need),
       priority = Value(priority);
  static Insertable<PrimaryNeedData> custom({
    Expression<int>? primary_need_id,
    Expression<int>? household_id,
    Expression<String>? need,
    Expression<int>? priority,
  }) {
    return RawValuesInsertable({
      if (primary_need_id != null) 'primary_need_id': primary_need_id,
      if (household_id != null) 'household_id': household_id,
      if (need != null) 'need': need,
      if (priority != null) 'priority': priority,
    });
  }

  PrimaryNeedsCompanion copyWith({
    Value<int>? primary_need_id,
    Value<int>? household_id,
    Value<String>? need,
    Value<int>? priority,
  }) {
    return PrimaryNeedsCompanion(
      primary_need_id: primary_need_id ?? this.primary_need_id,
      household_id: household_id ?? this.household_id,
      need: need ?? this.need,
      priority: priority ?? this.priority,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (primary_need_id.present) {
      map['primary_need_id'] = Variable<int>(primary_need_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (need.present) {
      map['need'] = Variable<String>(need.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PrimaryNeedsCompanion(')
          ..write('primary_need_id: $primary_need_id, ')
          ..write('household_id: $household_id, ')
          ..write('need: $need, ')
          ..write('priority: $priority')
          ..write(')'))
        .toString();
  }
}

class $FemaleMortalitiesTable extends FemaleMortalities
    with TableInfo<$FemaleMortalitiesTable, FemaleMortalityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FemaleMortalitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _female_mortality_idMeta =
      const VerificationMeta('female_mortality_id');
  @override
  late final GeneratedColumn<int> female_mortality_id = GeneratedColumn<int>(
    'female_mortality_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _ageMeta = const VerificationMeta('age');
  @override
  late final GeneratedColumn<int> age = GeneratedColumn<int>(
    'age',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _death_causeMeta = const VerificationMeta(
    'death_cause',
  );
  @override
  late final GeneratedColumn<String> death_cause = GeneratedColumn<String>(
    'death_cause',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    female_mortality_id,
    household_id,
    age,
    death_cause,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'female_mortalities';
  @override
  VerificationContext validateIntegrity(
    Insertable<FemaleMortalityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('female_mortality_id')) {
      context.handle(
        _female_mortality_idMeta,
        female_mortality_id.isAcceptableOrUnknown(
          data['female_mortality_id']!,
          _female_mortality_idMeta,
        ),
      );
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('age')) {
      context.handle(
        _ageMeta,
        age.isAcceptableOrUnknown(data['age']!, _ageMeta),
      );
    }
    if (data.containsKey('death_cause')) {
      context.handle(
        _death_causeMeta,
        death_cause.isAcceptableOrUnknown(
          data['death_cause']!,
          _death_causeMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {female_mortality_id};
  @override
  FemaleMortalityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FemaleMortalityData(
      female_mortality_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}female_mortality_id'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      age: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}age'],
      ),
      death_cause: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}death_cause'],
      ),
    );
  }

  @override
  $FemaleMortalitiesTable createAlias(String alias) {
    return $FemaleMortalitiesTable(attachedDatabase, alias);
  }
}

class FemaleMortalityData extends DataClass
    implements Insertable<FemaleMortalityData> {
  final int female_mortality_id;
  final int household_id;
  final int? age;
  final String? death_cause;
  const FemaleMortalityData({
    required this.female_mortality_id,
    required this.household_id,
    this.age,
    this.death_cause,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['female_mortality_id'] = Variable<int>(female_mortality_id);
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || age != null) {
      map['age'] = Variable<int>(age);
    }
    if (!nullToAbsent || death_cause != null) {
      map['death_cause'] = Variable<String>(death_cause);
    }
    return map;
  }

  FemaleMortalitiesCompanion toCompanion(bool nullToAbsent) {
    return FemaleMortalitiesCompanion(
      female_mortality_id: Value(female_mortality_id),
      household_id: Value(household_id),
      age: age == null && nullToAbsent ? const Value.absent() : Value(age),
      death_cause:
          death_cause == null && nullToAbsent
              ? const Value.absent()
              : Value(death_cause),
    );
  }

  factory FemaleMortalityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FemaleMortalityData(
      female_mortality_id: serializer.fromJson<int>(
        json['female_mortality_id'],
      ),
      household_id: serializer.fromJson<int>(json['household_id']),
      age: serializer.fromJson<int?>(json['age']),
      death_cause: serializer.fromJson<String?>(json['death_cause']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'female_mortality_id': serializer.toJson<int>(female_mortality_id),
      'household_id': serializer.toJson<int>(household_id),
      'age': serializer.toJson<int?>(age),
      'death_cause': serializer.toJson<String?>(death_cause),
    };
  }

  FemaleMortalityData copyWith({
    int? female_mortality_id,
    int? household_id,
    Value<int?> age = const Value.absent(),
    Value<String?> death_cause = const Value.absent(),
  }) => FemaleMortalityData(
    female_mortality_id: female_mortality_id ?? this.female_mortality_id,
    household_id: household_id ?? this.household_id,
    age: age.present ? age.value : this.age,
    death_cause: death_cause.present ? death_cause.value : this.death_cause,
  );
  FemaleMortalityData copyWithCompanion(FemaleMortalitiesCompanion data) {
    return FemaleMortalityData(
      female_mortality_id:
          data.female_mortality_id.present
              ? data.female_mortality_id.value
              : this.female_mortality_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      age: data.age.present ? data.age.value : this.age,
      death_cause:
          data.death_cause.present ? data.death_cause.value : this.death_cause,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FemaleMortalityData(')
          ..write('female_mortality_id: $female_mortality_id, ')
          ..write('household_id: $household_id, ')
          ..write('age: $age, ')
          ..write('death_cause: $death_cause')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(female_mortality_id, household_id, age, death_cause);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FemaleMortalityData &&
          other.female_mortality_id == this.female_mortality_id &&
          other.household_id == this.household_id &&
          other.age == this.age &&
          other.death_cause == this.death_cause);
}

class FemaleMortalitiesCompanion extends UpdateCompanion<FemaleMortalityData> {
  final Value<int> female_mortality_id;
  final Value<int> household_id;
  final Value<int?> age;
  final Value<String?> death_cause;
  const FemaleMortalitiesCompanion({
    this.female_mortality_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.age = const Value.absent(),
    this.death_cause = const Value.absent(),
  });
  FemaleMortalitiesCompanion.insert({
    this.female_mortality_id = const Value.absent(),
    required int household_id,
    this.age = const Value.absent(),
    this.death_cause = const Value.absent(),
  }) : household_id = Value(household_id);
  static Insertable<FemaleMortalityData> custom({
    Expression<int>? female_mortality_id,
    Expression<int>? household_id,
    Expression<int>? age,
    Expression<String>? death_cause,
  }) {
    return RawValuesInsertable({
      if (female_mortality_id != null)
        'female_mortality_id': female_mortality_id,
      if (household_id != null) 'household_id': household_id,
      if (age != null) 'age': age,
      if (death_cause != null) 'death_cause': death_cause,
    });
  }

  FemaleMortalitiesCompanion copyWith({
    Value<int>? female_mortality_id,
    Value<int>? household_id,
    Value<int?>? age,
    Value<String?>? death_cause,
  }) {
    return FemaleMortalitiesCompanion(
      female_mortality_id: female_mortality_id ?? this.female_mortality_id,
      household_id: household_id ?? this.household_id,
      age: age ?? this.age,
      death_cause: death_cause ?? this.death_cause,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (female_mortality_id.present) {
      map['female_mortality_id'] = Variable<int>(female_mortality_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (age.present) {
      map['age'] = Variable<int>(age.value);
    }
    if (death_cause.present) {
      map['death_cause'] = Variable<String>(death_cause.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FemaleMortalitiesCompanion(')
          ..write('female_mortality_id: $female_mortality_id, ')
          ..write('household_id: $household_id, ')
          ..write('age: $age, ')
          ..write('death_cause: $death_cause')
          ..write(')'))
        .toString();
  }
}

class $ChildMortalitiesTable extends ChildMortalities
    with TableInfo<$ChildMortalitiesTable, ChildMortalityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ChildMortalitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _child_mortality_idMeta =
      const VerificationMeta('child_mortality_id');
  @override
  late final GeneratedColumn<int> child_mortality_id = GeneratedColumn<int>(
    'child_mortality_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _ageMeta = const VerificationMeta('age');
  @override
  late final GeneratedColumn<int> age = GeneratedColumn<int>(
    'age',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Sex?, String> sex =
      GeneratedColumn<String>(
        'sex',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Sex?>($ChildMortalitiesTable.$convertersexn);
  static const VerificationMeta _death_causeMeta = const VerificationMeta(
    'death_cause',
  );
  @override
  late final GeneratedColumn<String> death_cause = GeneratedColumn<String>(
    'death_cause',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    child_mortality_id,
    household_id,
    age,
    sex,
    death_cause,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'child_mortalities';
  @override
  VerificationContext validateIntegrity(
    Insertable<ChildMortalityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('child_mortality_id')) {
      context.handle(
        _child_mortality_idMeta,
        child_mortality_id.isAcceptableOrUnknown(
          data['child_mortality_id']!,
          _child_mortality_idMeta,
        ),
      );
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('age')) {
      context.handle(
        _ageMeta,
        age.isAcceptableOrUnknown(data['age']!, _ageMeta),
      );
    }
    if (data.containsKey('death_cause')) {
      context.handle(
        _death_causeMeta,
        death_cause.isAcceptableOrUnknown(
          data['death_cause']!,
          _death_causeMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {child_mortality_id};
  @override
  ChildMortalityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ChildMortalityData(
      child_mortality_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}child_mortality_id'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      age: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}age'],
      ),
      sex: $ChildMortalitiesTable.$convertersexn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}sex'],
        ),
      ),
      death_cause: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}death_cause'],
      ),
    );
  }

  @override
  $ChildMortalitiesTable createAlias(String alias) {
    return $ChildMortalitiesTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<Sex, String, String> $convertersex =
      const EnumNameConverter<Sex>(Sex.values);
  static JsonTypeConverter2<Sex?, String?, String?> $convertersexn =
      JsonTypeConverter2.asNullable($convertersex);
}

class ChildMortalityData extends DataClass
    implements Insertable<ChildMortalityData> {
  final int child_mortality_id;
  final int household_id;
  final int? age;
  final Sex? sex;
  final String? death_cause;
  const ChildMortalityData({
    required this.child_mortality_id,
    required this.household_id,
    this.age,
    this.sex,
    this.death_cause,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['child_mortality_id'] = Variable<int>(child_mortality_id);
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || age != null) {
      map['age'] = Variable<int>(age);
    }
    if (!nullToAbsent || sex != null) {
      map['sex'] = Variable<String>(
        $ChildMortalitiesTable.$convertersexn.toSql(sex),
      );
    }
    if (!nullToAbsent || death_cause != null) {
      map['death_cause'] = Variable<String>(death_cause);
    }
    return map;
  }

  ChildMortalitiesCompanion toCompanion(bool nullToAbsent) {
    return ChildMortalitiesCompanion(
      child_mortality_id: Value(child_mortality_id),
      household_id: Value(household_id),
      age: age == null && nullToAbsent ? const Value.absent() : Value(age),
      sex: sex == null && nullToAbsent ? const Value.absent() : Value(sex),
      death_cause:
          death_cause == null && nullToAbsent
              ? const Value.absent()
              : Value(death_cause),
    );
  }

  factory ChildMortalityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ChildMortalityData(
      child_mortality_id: serializer.fromJson<int>(json['child_mortality_id']),
      household_id: serializer.fromJson<int>(json['household_id']),
      age: serializer.fromJson<int?>(json['age']),
      sex: $ChildMortalitiesTable.$convertersexn.fromJson(
        serializer.fromJson<String?>(json['sex']),
      ),
      death_cause: serializer.fromJson<String?>(json['death_cause']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'child_mortality_id': serializer.toJson<int>(child_mortality_id),
      'household_id': serializer.toJson<int>(household_id),
      'age': serializer.toJson<int?>(age),
      'sex': serializer.toJson<String?>(
        $ChildMortalitiesTable.$convertersexn.toJson(sex),
      ),
      'death_cause': serializer.toJson<String?>(death_cause),
    };
  }

  ChildMortalityData copyWith({
    int? child_mortality_id,
    int? household_id,
    Value<int?> age = const Value.absent(),
    Value<Sex?> sex = const Value.absent(),
    Value<String?> death_cause = const Value.absent(),
  }) => ChildMortalityData(
    child_mortality_id: child_mortality_id ?? this.child_mortality_id,
    household_id: household_id ?? this.household_id,
    age: age.present ? age.value : this.age,
    sex: sex.present ? sex.value : this.sex,
    death_cause: death_cause.present ? death_cause.value : this.death_cause,
  );
  ChildMortalityData copyWithCompanion(ChildMortalitiesCompanion data) {
    return ChildMortalityData(
      child_mortality_id:
          data.child_mortality_id.present
              ? data.child_mortality_id.value
              : this.child_mortality_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      age: data.age.present ? data.age.value : this.age,
      sex: data.sex.present ? data.sex.value : this.sex,
      death_cause:
          data.death_cause.present ? data.death_cause.value : this.death_cause,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ChildMortalityData(')
          ..write('child_mortality_id: $child_mortality_id, ')
          ..write('household_id: $household_id, ')
          ..write('age: $age, ')
          ..write('sex: $sex, ')
          ..write('death_cause: $death_cause')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(child_mortality_id, household_id, age, sex, death_cause);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ChildMortalityData &&
          other.child_mortality_id == this.child_mortality_id &&
          other.household_id == this.household_id &&
          other.age == this.age &&
          other.sex == this.sex &&
          other.death_cause == this.death_cause);
}

class ChildMortalitiesCompanion extends UpdateCompanion<ChildMortalityData> {
  final Value<int> child_mortality_id;
  final Value<int> household_id;
  final Value<int?> age;
  final Value<Sex?> sex;
  final Value<String?> death_cause;
  const ChildMortalitiesCompanion({
    this.child_mortality_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.age = const Value.absent(),
    this.sex = const Value.absent(),
    this.death_cause = const Value.absent(),
  });
  ChildMortalitiesCompanion.insert({
    this.child_mortality_id = const Value.absent(),
    required int household_id,
    this.age = const Value.absent(),
    this.sex = const Value.absent(),
    this.death_cause = const Value.absent(),
  }) : household_id = Value(household_id);
  static Insertable<ChildMortalityData> custom({
    Expression<int>? child_mortality_id,
    Expression<int>? household_id,
    Expression<int>? age,
    Expression<String>? sex,
    Expression<String>? death_cause,
  }) {
    return RawValuesInsertable({
      if (child_mortality_id != null) 'child_mortality_id': child_mortality_id,
      if (household_id != null) 'household_id': household_id,
      if (age != null) 'age': age,
      if (sex != null) 'sex': sex,
      if (death_cause != null) 'death_cause': death_cause,
    });
  }

  ChildMortalitiesCompanion copyWith({
    Value<int>? child_mortality_id,
    Value<int>? household_id,
    Value<int?>? age,
    Value<Sex?>? sex,
    Value<String?>? death_cause,
  }) {
    return ChildMortalitiesCompanion(
      child_mortality_id: child_mortality_id ?? this.child_mortality_id,
      household_id: household_id ?? this.household_id,
      age: age ?? this.age,
      sex: sex ?? this.sex,
      death_cause: death_cause ?? this.death_cause,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (child_mortality_id.present) {
      map['child_mortality_id'] = Variable<int>(child_mortality_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (age.present) {
      map['age'] = Variable<int>(age.value);
    }
    if (sex.present) {
      map['sex'] = Variable<String>(
        $ChildMortalitiesTable.$convertersexn.toSql(sex.value),
      );
    }
    if (death_cause.present) {
      map['death_cause'] = Variable<String>(death_cause.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ChildMortalitiesCompanion(')
          ..write('child_mortality_id: $child_mortality_id, ')
          ..write('household_id: $household_id, ')
          ..write('age: $age, ')
          ..write('sex: $sex, ')
          ..write('death_cause: $death_cause')
          ..write(')'))
        .toString();
  }
}

class $FutureResidenciesTable extends FutureResidencies
    with TableInfo<$FutureResidenciesTable, FutureResidency> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FutureResidenciesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _future_residency_idMeta =
      const VerificationMeta('future_residency_id');
  @override
  late final GeneratedColumn<int> future_residency_id = GeneratedColumn<int>(
    'future_residency_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _household_idMeta = const VerificationMeta(
    'household_id',
  );
  @override
  late final GeneratedColumn<int> household_id = GeneratedColumn<int>(
    'household_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES households (household_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _barangayMeta = const VerificationMeta(
    'barangay',
  );
  @override
  late final GeneratedColumn<String> barangay = GeneratedColumn<String>(
    'barangay',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _municipalityMeta = const VerificationMeta(
    'municipality',
  );
  @override
  late final GeneratedColumn<String> municipality = GeneratedColumn<String>(
    'municipality',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    future_residency_id,
    household_id,
    barangay,
    municipality,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'future_residencies';
  @override
  VerificationContext validateIntegrity(
    Insertable<FutureResidency> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('future_residency_id')) {
      context.handle(
        _future_residency_idMeta,
        future_residency_id.isAcceptableOrUnknown(
          data['future_residency_id']!,
          _future_residency_idMeta,
        ),
      );
    }
    if (data.containsKey('household_id')) {
      context.handle(
        _household_idMeta,
        household_id.isAcceptableOrUnknown(
          data['household_id']!,
          _household_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_household_idMeta);
    }
    if (data.containsKey('barangay')) {
      context.handle(
        _barangayMeta,
        barangay.isAcceptableOrUnknown(data['barangay']!, _barangayMeta),
      );
    }
    if (data.containsKey('municipality')) {
      context.handle(
        _municipalityMeta,
        municipality.isAcceptableOrUnknown(
          data['municipality']!,
          _municipalityMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {future_residency_id};
  @override
  FutureResidency map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FutureResidency(
      future_residency_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}future_residency_id'],
          )!,
      household_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}household_id'],
          )!,
      barangay: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barangay'],
      ),
      municipality: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}municipality'],
      ),
    );
  }

  @override
  $FutureResidenciesTable createAlias(String alias) {
    return $FutureResidenciesTable(attachedDatabase, alias);
  }
}

class FutureResidency extends DataClass implements Insertable<FutureResidency> {
  final int future_residency_id;
  final int household_id;
  final String? barangay;
  final String? municipality;
  const FutureResidency({
    required this.future_residency_id,
    required this.household_id,
    this.barangay,
    this.municipality,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['future_residency_id'] = Variable<int>(future_residency_id);
    map['household_id'] = Variable<int>(household_id);
    if (!nullToAbsent || barangay != null) {
      map['barangay'] = Variable<String>(barangay);
    }
    if (!nullToAbsent || municipality != null) {
      map['municipality'] = Variable<String>(municipality);
    }
    return map;
  }

  FutureResidenciesCompanion toCompanion(bool nullToAbsent) {
    return FutureResidenciesCompanion(
      future_residency_id: Value(future_residency_id),
      household_id: Value(household_id),
      barangay:
          barangay == null && nullToAbsent
              ? const Value.absent()
              : Value(barangay),
      municipality:
          municipality == null && nullToAbsent
              ? const Value.absent()
              : Value(municipality),
    );
  }

  factory FutureResidency.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FutureResidency(
      future_residency_id: serializer.fromJson<int>(
        json['future_residency_id'],
      ),
      household_id: serializer.fromJson<int>(json['household_id']),
      barangay: serializer.fromJson<String?>(json['barangay']),
      municipality: serializer.fromJson<String?>(json['municipality']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'future_residency_id': serializer.toJson<int>(future_residency_id),
      'household_id': serializer.toJson<int>(household_id),
      'barangay': serializer.toJson<String?>(barangay),
      'municipality': serializer.toJson<String?>(municipality),
    };
  }

  FutureResidency copyWith({
    int? future_residency_id,
    int? household_id,
    Value<String?> barangay = const Value.absent(),
    Value<String?> municipality = const Value.absent(),
  }) => FutureResidency(
    future_residency_id: future_residency_id ?? this.future_residency_id,
    household_id: household_id ?? this.household_id,
    barangay: barangay.present ? barangay.value : this.barangay,
    municipality: municipality.present ? municipality.value : this.municipality,
  );
  FutureResidency copyWithCompanion(FutureResidenciesCompanion data) {
    return FutureResidency(
      future_residency_id:
          data.future_residency_id.present
              ? data.future_residency_id.value
              : this.future_residency_id,
      household_id:
          data.household_id.present
              ? data.household_id.value
              : this.household_id,
      barangay: data.barangay.present ? data.barangay.value : this.barangay,
      municipality:
          data.municipality.present
              ? data.municipality.value
              : this.municipality,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FutureResidency(')
          ..write('future_residency_id: $future_residency_id, ')
          ..write('household_id: $household_id, ')
          ..write('barangay: $barangay, ')
          ..write('municipality: $municipality')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(future_residency_id, household_id, barangay, municipality);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FutureResidency &&
          other.future_residency_id == this.future_residency_id &&
          other.household_id == this.household_id &&
          other.barangay == this.barangay &&
          other.municipality == this.municipality);
}

class FutureResidenciesCompanion extends UpdateCompanion<FutureResidency> {
  final Value<int> future_residency_id;
  final Value<int> household_id;
  final Value<String?> barangay;
  final Value<String?> municipality;
  const FutureResidenciesCompanion({
    this.future_residency_id = const Value.absent(),
    this.household_id = const Value.absent(),
    this.barangay = const Value.absent(),
    this.municipality = const Value.absent(),
  });
  FutureResidenciesCompanion.insert({
    this.future_residency_id = const Value.absent(),
    required int household_id,
    this.barangay = const Value.absent(),
    this.municipality = const Value.absent(),
  }) : household_id = Value(household_id);
  static Insertable<FutureResidency> custom({
    Expression<int>? future_residency_id,
    Expression<int>? household_id,
    Expression<String>? barangay,
    Expression<String>? municipality,
  }) {
    return RawValuesInsertable({
      if (future_residency_id != null)
        'future_residency_id': future_residency_id,
      if (household_id != null) 'household_id': household_id,
      if (barangay != null) 'barangay': barangay,
      if (municipality != null) 'municipality': municipality,
    });
  }

  FutureResidenciesCompanion copyWith({
    Value<int>? future_residency_id,
    Value<int>? household_id,
    Value<String?>? barangay,
    Value<String?>? municipality,
  }) {
    return FutureResidenciesCompanion(
      future_residency_id: future_residency_id ?? this.future_residency_id,
      household_id: household_id ?? this.household_id,
      barangay: barangay ?? this.barangay,
      municipality: municipality ?? this.municipality,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (future_residency_id.present) {
      map['future_residency_id'] = Variable<int>(future_residency_id.value);
    }
    if (household_id.present) {
      map['household_id'] = Variable<int>(household_id.value);
    }
    if (barangay.present) {
      map['barangay'] = Variable<String>(barangay.value);
    }
    if (municipality.present) {
      map['municipality'] = Variable<String>(municipality.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FutureResidenciesCompanion(')
          ..write('future_residency_id: $future_residency_id, ')
          ..write('household_id: $household_id, ')
          ..write('barangay: $barangay, ')
          ..write('municipality: $municipality')
          ..write(')'))
        .toString();
  }
}

class $DeliveryPlacesTable extends DeliveryPlaces
    with TableInfo<$DeliveryPlacesTable, DeliveryPlaceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DeliveryPlacesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _delivery_place_idMeta = const VerificationMeta(
    'delivery_place_id',
  );
  @override
  late final GeneratedColumn<int> delivery_place_id = GeneratedColumn<int>(
    'delivery_place_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _placeMeta = const VerificationMeta('place');
  @override
  late final GeneratedColumn<String> place = GeneratedColumn<String>(
    'place',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [delivery_place_id, place];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'delivery_places';
  @override
  VerificationContext validateIntegrity(
    Insertable<DeliveryPlaceData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('delivery_place_id')) {
      context.handle(
        _delivery_place_idMeta,
        delivery_place_id.isAcceptableOrUnknown(
          data['delivery_place_id']!,
          _delivery_place_idMeta,
        ),
      );
    }
    if (data.containsKey('place')) {
      context.handle(
        _placeMeta,
        place.isAcceptableOrUnknown(data['place']!, _placeMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {delivery_place_id};
  @override
  DeliveryPlaceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DeliveryPlaceData(
      delivery_place_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}delivery_place_id'],
          )!,
      place: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}place'],
      ),
    );
  }

  @override
  $DeliveryPlacesTable createAlias(String alias) {
    return $DeliveryPlacesTable(attachedDatabase, alias);
  }
}

class DeliveryPlaceData extends DataClass
    implements Insertable<DeliveryPlaceData> {
  final int delivery_place_id;
  final String? place;
  const DeliveryPlaceData({required this.delivery_place_id, this.place});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['delivery_place_id'] = Variable<int>(delivery_place_id);
    if (!nullToAbsent || place != null) {
      map['place'] = Variable<String>(place);
    }
    return map;
  }

  DeliveryPlacesCompanion toCompanion(bool nullToAbsent) {
    return DeliveryPlacesCompanion(
      delivery_place_id: Value(delivery_place_id),
      place:
          place == null && nullToAbsent ? const Value.absent() : Value(place),
    );
  }

  factory DeliveryPlaceData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DeliveryPlaceData(
      delivery_place_id: serializer.fromJson<int>(json['delivery_place_id']),
      place: serializer.fromJson<String?>(json['place']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'delivery_place_id': serializer.toJson<int>(delivery_place_id),
      'place': serializer.toJson<String?>(place),
    };
  }

  DeliveryPlaceData copyWith({
    int? delivery_place_id,
    Value<String?> place = const Value.absent(),
  }) => DeliveryPlaceData(
    delivery_place_id: delivery_place_id ?? this.delivery_place_id,
    place: place.present ? place.value : this.place,
  );
  DeliveryPlaceData copyWithCompanion(DeliveryPlacesCompanion data) {
    return DeliveryPlaceData(
      delivery_place_id:
          data.delivery_place_id.present
              ? data.delivery_place_id.value
              : this.delivery_place_id,
      place: data.place.present ? data.place.value : this.place,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryPlaceData(')
          ..write('delivery_place_id: $delivery_place_id, ')
          ..write('place: $place')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(delivery_place_id, place);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DeliveryPlaceData &&
          other.delivery_place_id == this.delivery_place_id &&
          other.place == this.place);
}

class DeliveryPlacesCompanion extends UpdateCompanion<DeliveryPlaceData> {
  final Value<int> delivery_place_id;
  final Value<String?> place;
  const DeliveryPlacesCompanion({
    this.delivery_place_id = const Value.absent(),
    this.place = const Value.absent(),
  });
  DeliveryPlacesCompanion.insert({
    this.delivery_place_id = const Value.absent(),
    this.place = const Value.absent(),
  });
  static Insertable<DeliveryPlaceData> custom({
    Expression<int>? delivery_place_id,
    Expression<String>? place,
  }) {
    return RawValuesInsertable({
      if (delivery_place_id != null) 'delivery_place_id': delivery_place_id,
      if (place != null) 'place': place,
    });
  }

  DeliveryPlacesCompanion copyWith({
    Value<int>? delivery_place_id,
    Value<String?>? place,
  }) {
    return DeliveryPlacesCompanion(
      delivery_place_id: delivery_place_id ?? this.delivery_place_id,
      place: place ?? this.place,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (delivery_place_id.present) {
      map['delivery_place_id'] = Variable<int>(delivery_place_id.value);
    }
    if (place.present) {
      map['place'] = Variable<String>(place.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryPlacesCompanion(')
          ..write('delivery_place_id: $delivery_place_id, ')
          ..write('place: $place')
          ..write(')'))
        .toString();
  }
}

class $AssistedPersonsTable extends AssistedPersons
    with TableInfo<$AssistedPersonsTable, AssistedPersonData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AssistedPersonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _assisted_person_idMeta =
      const VerificationMeta('assisted_person_id');
  @override
  late final GeneratedColumn<int> assisted_person_id = GeneratedColumn<int>(
    'assisted_person_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [assisted_person_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'assisted_persons';
  @override
  VerificationContext validateIntegrity(
    Insertable<AssistedPersonData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('assisted_person_id')) {
      context.handle(
        _assisted_person_idMeta,
        assisted_person_id.isAcceptableOrUnknown(
          data['assisted_person_id']!,
          _assisted_person_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {assisted_person_id};
  @override
  AssistedPersonData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AssistedPersonData(
      assisted_person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}assisted_person_id'],
          )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      ),
    );
  }

  @override
  $AssistedPersonsTable createAlias(String alias) {
    return $AssistedPersonsTable(attachedDatabase, alias);
  }
}

class AssistedPersonData extends DataClass
    implements Insertable<AssistedPersonData> {
  final int assisted_person_id;
  final String? name;
  const AssistedPersonData({required this.assisted_person_id, this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['assisted_person_id'] = Variable<int>(assisted_person_id);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    return map;
  }

  AssistedPersonsCompanion toCompanion(bool nullToAbsent) {
    return AssistedPersonsCompanion(
      assisted_person_id: Value(assisted_person_id),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory AssistedPersonData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AssistedPersonData(
      assisted_person_id: serializer.fromJson<int>(json['assisted_person_id']),
      name: serializer.fromJson<String?>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'assisted_person_id': serializer.toJson<int>(assisted_person_id),
      'name': serializer.toJson<String?>(name),
    };
  }

  AssistedPersonData copyWith({
    int? assisted_person_id,
    Value<String?> name = const Value.absent(),
  }) => AssistedPersonData(
    assisted_person_id: assisted_person_id ?? this.assisted_person_id,
    name: name.present ? name.value : this.name,
  );
  AssistedPersonData copyWithCompanion(AssistedPersonsCompanion data) {
    return AssistedPersonData(
      assisted_person_id:
          data.assisted_person_id.present
              ? data.assisted_person_id.value
              : this.assisted_person_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AssistedPersonData(')
          ..write('assisted_person_id: $assisted_person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(assisted_person_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AssistedPersonData &&
          other.assisted_person_id == this.assisted_person_id &&
          other.name == this.name);
}

class AssistedPersonsCompanion extends UpdateCompanion<AssistedPersonData> {
  final Value<int> assisted_person_id;
  final Value<String?> name;
  const AssistedPersonsCompanion({
    this.assisted_person_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  AssistedPersonsCompanion.insert({
    this.assisted_person_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  static Insertable<AssistedPersonData> custom({
    Expression<int>? assisted_person_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (assisted_person_id != null) 'assisted_person_id': assisted_person_id,
      if (name != null) 'name': name,
    });
  }

  AssistedPersonsCompanion copyWith({
    Value<int>? assisted_person_id,
    Value<String?>? name,
  }) {
    return AssistedPersonsCompanion(
      assisted_person_id: assisted_person_id ?? this.assisted_person_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (assisted_person_id.present) {
      map['assisted_person_id'] = Variable<int>(assisted_person_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AssistedPersonsCompanion(')
          ..write('assisted_person_id: $assisted_person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $VisitReasonsTable extends VisitReasons
    with TableInfo<$VisitReasonsTable, VisitReasonData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitReasonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _visit_reason_idMeta = const VerificationMeta(
    'visit_reason_id',
  );
  @override
  late final GeneratedColumn<int> visit_reason_id = GeneratedColumn<int>(
    'visit_reason_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [visit_reason_id, reason];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_reasons';
  @override
  VerificationContext validateIntegrity(
    Insertable<VisitReasonData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('visit_reason_id')) {
      context.handle(
        _visit_reason_idMeta,
        visit_reason_id.isAcceptableOrUnknown(
          data['visit_reason_id']!,
          _visit_reason_idMeta,
        ),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {visit_reason_id};
  @override
  VisitReasonData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitReasonData(
      visit_reason_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}visit_reason_id'],
          )!,
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      ),
    );
  }

  @override
  $VisitReasonsTable createAlias(String alias) {
    return $VisitReasonsTable(attachedDatabase, alias);
  }
}

class VisitReasonData extends DataClass implements Insertable<VisitReasonData> {
  final int visit_reason_id;
  final String? reason;
  const VisitReasonData({required this.visit_reason_id, this.reason});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['visit_reason_id'] = Variable<int>(visit_reason_id);
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    return map;
  }

  VisitReasonsCompanion toCompanion(bool nullToAbsent) {
    return VisitReasonsCompanion(
      visit_reason_id: Value(visit_reason_id),
      reason:
          reason == null && nullToAbsent ? const Value.absent() : Value(reason),
    );
  }

  factory VisitReasonData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitReasonData(
      visit_reason_id: serializer.fromJson<int>(json['visit_reason_id']),
      reason: serializer.fromJson<String?>(json['reason']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'visit_reason_id': serializer.toJson<int>(visit_reason_id),
      'reason': serializer.toJson<String?>(reason),
    };
  }

  VisitReasonData copyWith({
    int? visit_reason_id,
    Value<String?> reason = const Value.absent(),
  }) => VisitReasonData(
    visit_reason_id: visit_reason_id ?? this.visit_reason_id,
    reason: reason.present ? reason.value : this.reason,
  );
  VisitReasonData copyWithCompanion(VisitReasonsCompanion data) {
    return VisitReasonData(
      visit_reason_id:
          data.visit_reason_id.present
              ? data.visit_reason_id.value
              : this.visit_reason_id,
      reason: data.reason.present ? data.reason.value : this.reason,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VisitReasonData(')
          ..write('visit_reason_id: $visit_reason_id, ')
          ..write('reason: $reason')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(visit_reason_id, reason);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitReasonData &&
          other.visit_reason_id == this.visit_reason_id &&
          other.reason == this.reason);
}

class VisitReasonsCompanion extends UpdateCompanion<VisitReasonData> {
  final Value<int> visit_reason_id;
  final Value<String?> reason;
  const VisitReasonsCompanion({
    this.visit_reason_id = const Value.absent(),
    this.reason = const Value.absent(),
  });
  VisitReasonsCompanion.insert({
    this.visit_reason_id = const Value.absent(),
    this.reason = const Value.absent(),
  });
  static Insertable<VisitReasonData> custom({
    Expression<int>? visit_reason_id,
    Expression<String>? reason,
  }) {
    return RawValuesInsertable({
      if (visit_reason_id != null) 'visit_reason_id': visit_reason_id,
      if (reason != null) 'reason': reason,
    });
  }

  VisitReasonsCompanion copyWith({
    Value<int>? visit_reason_id,
    Value<String?>? reason,
  }) {
    return VisitReasonsCompanion(
      visit_reason_id: visit_reason_id ?? this.visit_reason_id,
      reason: reason ?? this.reason,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (visit_reason_id.present) {
      map['visit_reason_id'] = Variable<int>(visit_reason_id.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitReasonsCompanion(')
          ..write('visit_reason_id: $visit_reason_id, ')
          ..write('reason: $reason')
          ..write(')'))
        .toString();
  }
}

class $FpSourcesTable extends FpSources
    with TableInfo<$FpSourcesTable, FpSourceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FpSourcesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fp_source_idMeta = const VerificationMeta(
    'fp_source_id',
  );
  @override
  late final GeneratedColumn<int> fp_source_id = GeneratedColumn<int>(
    'fp_source_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [fp_source_id, source];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fp_sources';
  @override
  VerificationContext validateIntegrity(
    Insertable<FpSourceData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fp_source_id')) {
      context.handle(
        _fp_source_idMeta,
        fp_source_id.isAcceptableOrUnknown(
          data['fp_source_id']!,
          _fp_source_idMeta,
        ),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {fp_source_id};
  @override
  FpSourceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FpSourceData(
      fp_source_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}fp_source_id'],
          )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      ),
    );
  }

  @override
  $FpSourcesTable createAlias(String alias) {
    return $FpSourcesTable(attachedDatabase, alias);
  }
}

class FpSourceData extends DataClass implements Insertable<FpSourceData> {
  final int fp_source_id;
  final String? source;
  const FpSourceData({required this.fp_source_id, this.source});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['fp_source_id'] = Variable<int>(fp_source_id);
    if (!nullToAbsent || source != null) {
      map['source'] = Variable<String>(source);
    }
    return map;
  }

  FpSourcesCompanion toCompanion(bool nullToAbsent) {
    return FpSourcesCompanion(
      fp_source_id: Value(fp_source_id),
      source:
          source == null && nullToAbsent ? const Value.absent() : Value(source),
    );
  }

  factory FpSourceData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FpSourceData(
      fp_source_id: serializer.fromJson<int>(json['fp_source_id']),
      source: serializer.fromJson<String?>(json['source']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fp_source_id': serializer.toJson<int>(fp_source_id),
      'source': serializer.toJson<String?>(source),
    };
  }

  FpSourceData copyWith({
    int? fp_source_id,
    Value<String?> source = const Value.absent(),
  }) => FpSourceData(
    fp_source_id: fp_source_id ?? this.fp_source_id,
    source: source.present ? source.value : this.source,
  );
  FpSourceData copyWithCompanion(FpSourcesCompanion data) {
    return FpSourceData(
      fp_source_id:
          data.fp_source_id.present
              ? data.fp_source_id.value
              : this.fp_source_id,
      source: data.source.present ? data.source.value : this.source,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FpSourceData(')
          ..write('fp_source_id: $fp_source_id, ')
          ..write('source: $source')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(fp_source_id, source);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FpSourceData &&
          other.fp_source_id == this.fp_source_id &&
          other.source == this.source);
}

class FpSourcesCompanion extends UpdateCompanion<FpSourceData> {
  final Value<int> fp_source_id;
  final Value<String?> source;
  const FpSourcesCompanion({
    this.fp_source_id = const Value.absent(),
    this.source = const Value.absent(),
  });
  FpSourcesCompanion.insert({
    this.fp_source_id = const Value.absent(),
    this.source = const Value.absent(),
  });
  static Insertable<FpSourceData> custom({
    Expression<int>? fp_source_id,
    Expression<String>? source,
  }) {
    return RawValuesInsertable({
      if (fp_source_id != null) 'fp_source_id': fp_source_id,
      if (source != null) 'source': source,
    });
  }

  FpSourcesCompanion copyWith({
    Value<int>? fp_source_id,
    Value<String?>? source,
  }) {
    return FpSourcesCompanion(
      fp_source_id: fp_source_id ?? this.fp_source_id,
      source: source ?? this.source,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fp_source_id.present) {
      map['fp_source_id'] = Variable<int>(fp_source_id.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FpSourcesCompanion(')
          ..write('fp_source_id: $fp_source_id, ')
          ..write('source: $source')
          ..write(')'))
        .toString();
  }
}

class $FpMethodsTable extends FpMethods
    with TableInfo<$FpMethodsTable, FpMethodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FpMethodsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fp_method_idMeta = const VerificationMeta(
    'fp_method_id',
  );
  @override
  late final GeneratedColumn<int> fp_method_id = GeneratedColumn<int>(
    'fp_method_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _methodMeta = const VerificationMeta('method');
  @override
  late final GeneratedColumn<String> method = GeneratedColumn<String>(
    'method',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [fp_method_id, method];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fp_methods';
  @override
  VerificationContext validateIntegrity(
    Insertable<FpMethodData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fp_method_id')) {
      context.handle(
        _fp_method_idMeta,
        fp_method_id.isAcceptableOrUnknown(
          data['fp_method_id']!,
          _fp_method_idMeta,
        ),
      );
    }
    if (data.containsKey('method')) {
      context.handle(
        _methodMeta,
        method.isAcceptableOrUnknown(data['method']!, _methodMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {fp_method_id};
  @override
  FpMethodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FpMethodData(
      fp_method_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}fp_method_id'],
          )!,
      method: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}method'],
      ),
    );
  }

  @override
  $FpMethodsTable createAlias(String alias) {
    return $FpMethodsTable(attachedDatabase, alias);
  }
}

class FpMethodData extends DataClass implements Insertable<FpMethodData> {
  final int fp_method_id;
  final String? method;
  const FpMethodData({required this.fp_method_id, this.method});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['fp_method_id'] = Variable<int>(fp_method_id);
    if (!nullToAbsent || method != null) {
      map['method'] = Variable<String>(method);
    }
    return map;
  }

  FpMethodsCompanion toCompanion(bool nullToAbsent) {
    return FpMethodsCompanion(
      fp_method_id: Value(fp_method_id),
      method:
          method == null && nullToAbsent ? const Value.absent() : Value(method),
    );
  }

  factory FpMethodData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FpMethodData(
      fp_method_id: serializer.fromJson<int>(json['fp_method_id']),
      method: serializer.fromJson<String?>(json['method']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fp_method_id': serializer.toJson<int>(fp_method_id),
      'method': serializer.toJson<String?>(method),
    };
  }

  FpMethodData copyWith({
    int? fp_method_id,
    Value<String?> method = const Value.absent(),
  }) => FpMethodData(
    fp_method_id: fp_method_id ?? this.fp_method_id,
    method: method.present ? method.value : this.method,
  );
  FpMethodData copyWithCompanion(FpMethodsCompanion data) {
    return FpMethodData(
      fp_method_id:
          data.fp_method_id.present
              ? data.fp_method_id.value
              : this.fp_method_id,
      method: data.method.present ? data.method.value : this.method,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FpMethodData(')
          ..write('fp_method_id: $fp_method_id, ')
          ..write('method: $method')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(fp_method_id, method);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FpMethodData &&
          other.fp_method_id == this.fp_method_id &&
          other.method == this.method);
}

class FpMethodsCompanion extends UpdateCompanion<FpMethodData> {
  final Value<int> fp_method_id;
  final Value<String?> method;
  const FpMethodsCompanion({
    this.fp_method_id = const Value.absent(),
    this.method = const Value.absent(),
  });
  FpMethodsCompanion.insert({
    this.fp_method_id = const Value.absent(),
    this.method = const Value.absent(),
  });
  static Insertable<FpMethodData> custom({
    Expression<int>? fp_method_id,
    Expression<String>? method,
  }) {
    return RawValuesInsertable({
      if (fp_method_id != null) 'fp_method_id': fp_method_id,
      if (method != null) 'method': method,
    });
  }

  FpMethodsCompanion copyWith({
    Value<int>? fp_method_id,
    Value<String?>? method,
  }) {
    return FpMethodsCompanion(
      fp_method_id: fp_method_id ?? this.fp_method_id,
      method: method ?? this.method,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fp_method_id.present) {
      map['fp_method_id'] = Variable<int>(fp_method_id.value);
    }
    if (method.present) {
      map['method'] = Variable<String>(method.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FpMethodsCompanion(')
          ..write('fp_method_id: $fp_method_id, ')
          ..write('method: $method')
          ..write(')'))
        .toString();
  }
}

class $FishingProductsTable extends FishingProducts
    with TableInfo<$FishingProductsTable, FishingProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FishingProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fishing_product_idMeta =
      const VerificationMeta('fishing_product_id');
  @override
  late final GeneratedColumn<int> fishing_product_id = GeneratedColumn<int>(
    'fishing_product_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [fishing_product_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fishing_products';
  @override
  VerificationContext validateIntegrity(
    Insertable<FishingProductData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fishing_product_id')) {
      context.handle(
        _fishing_product_idMeta,
        fishing_product_id.isAcceptableOrUnknown(
          data['fishing_product_id']!,
          _fishing_product_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {fishing_product_id};
  @override
  FishingProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FishingProductData(
      fishing_product_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}fishing_product_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $FishingProductsTable createAlias(String alias) {
    return $FishingProductsTable(attachedDatabase, alias);
  }
}

class FishingProductData extends DataClass
    implements Insertable<FishingProductData> {
  final int fishing_product_id;
  final String name;
  const FishingProductData({
    required this.fishing_product_id,
    required this.name,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['fishing_product_id'] = Variable<int>(fishing_product_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  FishingProductsCompanion toCompanion(bool nullToAbsent) {
    return FishingProductsCompanion(
      fishing_product_id: Value(fishing_product_id),
      name: Value(name),
    );
  }

  factory FishingProductData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FishingProductData(
      fishing_product_id: serializer.fromJson<int>(json['fishing_product_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fishing_product_id': serializer.toJson<int>(fishing_product_id),
      'name': serializer.toJson<String>(name),
    };
  }

  FishingProductData copyWith({int? fishing_product_id, String? name}) =>
      FishingProductData(
        fishing_product_id: fishing_product_id ?? this.fishing_product_id,
        name: name ?? this.name,
      );
  FishingProductData copyWithCompanion(FishingProductsCompanion data) {
    return FishingProductData(
      fishing_product_id:
          data.fishing_product_id.present
              ? data.fishing_product_id.value
              : this.fishing_product_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FishingProductData(')
          ..write('fishing_product_id: $fishing_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(fishing_product_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FishingProductData &&
          other.fishing_product_id == this.fishing_product_id &&
          other.name == this.name);
}

class FishingProductsCompanion extends UpdateCompanion<FishingProductData> {
  final Value<int> fishing_product_id;
  final Value<String> name;
  const FishingProductsCompanion({
    this.fishing_product_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  FishingProductsCompanion.insert({
    this.fishing_product_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<FishingProductData> custom({
    Expression<int>? fishing_product_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (fishing_product_id != null) 'fishing_product_id': fishing_product_id,
      if (name != null) 'name': name,
    });
  }

  FishingProductsCompanion copyWith({
    Value<int>? fishing_product_id,
    Value<String>? name,
  }) {
    return FishingProductsCompanion(
      fishing_product_id: fishing_product_id ?? this.fishing_product_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fishing_product_id.present) {
      map['fishing_product_id'] = Variable<int>(fishing_product_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FishingProductsCompanion(')
          ..write('fishing_product_id: $fishing_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $FishingTable extends Fishing with TableInfo<$FishingTable, FishingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FishingTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fishing_idMeta = const VerificationMeta(
    'fishing_id',
  );
  @override
  late final GeneratedColumn<int> fishing_id = GeneratedColumn<int>(
    'fishing_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _fishing_product_idMeta =
      const VerificationMeta('fishing_product_id');
  @override
  late final GeneratedColumn<int> fishing_product_id = GeneratedColumn<int>(
    'fishing_product_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES fishing_products (fishing_product_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _area_haMeta = const VerificationMeta(
    'area_ha',
  );
  @override
  late final GeneratedColumn<double> area_ha = GeneratedColumn<double>(
    'area_ha',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _volume_kgMeta = const VerificationMeta(
    'volume_kg',
  );
  @override
  late final GeneratedColumn<double> volume_kg = GeneratedColumn<double>(
    'volume_kg',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _production_valueMeta = const VerificationMeta(
    'production_value',
  );
  @override
  late final GeneratedColumn<int> production_value = GeneratedColumn<int>(
    'production_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fisherman_countMeta = const VerificationMeta(
    'fisherman_count',
  );
  @override
  late final GeneratedColumn<int> fisherman_count = GeneratedColumn<int>(
    'fisherman_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    fishing_id,
    person_id,
    fishing_product_id,
    area_ha,
    volume_kg,
    production_value,
    fisherman_count,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fishing';
  @override
  VerificationContext validateIntegrity(
    Insertable<FishingData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fishing_id')) {
      context.handle(
        _fishing_idMeta,
        fishing_id.isAcceptableOrUnknown(data['fishing_id']!, _fishing_idMeta),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('fishing_product_id')) {
      context.handle(
        _fishing_product_idMeta,
        fishing_product_id.isAcceptableOrUnknown(
          data['fishing_product_id']!,
          _fishing_product_idMeta,
        ),
      );
    }
    if (data.containsKey('area_ha')) {
      context.handle(
        _area_haMeta,
        area_ha.isAcceptableOrUnknown(data['area_ha']!, _area_haMeta),
      );
    }
    if (data.containsKey('volume_kg')) {
      context.handle(
        _volume_kgMeta,
        volume_kg.isAcceptableOrUnknown(data['volume_kg']!, _volume_kgMeta),
      );
    }
    if (data.containsKey('production_value')) {
      context.handle(
        _production_valueMeta,
        production_value.isAcceptableOrUnknown(
          data['production_value']!,
          _production_valueMeta,
        ),
      );
    }
    if (data.containsKey('fisherman_count')) {
      context.handle(
        _fisherman_countMeta,
        fisherman_count.isAcceptableOrUnknown(
          data['fisherman_count']!,
          _fisherman_countMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {fishing_id};
  @override
  FishingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FishingData(
      fishing_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}fishing_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      fishing_product_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fishing_product_id'],
      ),
      area_ha: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}area_ha'],
      ),
      volume_kg: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}volume_kg'],
      ),
      production_value: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}production_value'],
      ),
      fisherman_count: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fisherman_count'],
      ),
    );
  }

  @override
  $FishingTable createAlias(String alias) {
    return $FishingTable(attachedDatabase, alias);
  }
}

class FishingData extends DataClass implements Insertable<FishingData> {
  final int fishing_id;
  final int person_id;
  final int? fishing_product_id;
  final double? area_ha;
  final double? volume_kg;
  final int? production_value;
  final int? fisherman_count;
  const FishingData({
    required this.fishing_id,
    required this.person_id,
    this.fishing_product_id,
    this.area_ha,
    this.volume_kg,
    this.production_value,
    this.fisherman_count,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['fishing_id'] = Variable<int>(fishing_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || fishing_product_id != null) {
      map['fishing_product_id'] = Variable<int>(fishing_product_id);
    }
    if (!nullToAbsent || area_ha != null) {
      map['area_ha'] = Variable<double>(area_ha);
    }
    if (!nullToAbsent || volume_kg != null) {
      map['volume_kg'] = Variable<double>(volume_kg);
    }
    if (!nullToAbsent || production_value != null) {
      map['production_value'] = Variable<int>(production_value);
    }
    if (!nullToAbsent || fisherman_count != null) {
      map['fisherman_count'] = Variable<int>(fisherman_count);
    }
    return map;
  }

  FishingCompanion toCompanion(bool nullToAbsent) {
    return FishingCompanion(
      fishing_id: Value(fishing_id),
      person_id: Value(person_id),
      fishing_product_id:
          fishing_product_id == null && nullToAbsent
              ? const Value.absent()
              : Value(fishing_product_id),
      area_ha:
          area_ha == null && nullToAbsent
              ? const Value.absent()
              : Value(area_ha),
      volume_kg:
          volume_kg == null && nullToAbsent
              ? const Value.absent()
              : Value(volume_kg),
      production_value:
          production_value == null && nullToAbsent
              ? const Value.absent()
              : Value(production_value),
      fisherman_count:
          fisherman_count == null && nullToAbsent
              ? const Value.absent()
              : Value(fisherman_count),
    );
  }

  factory FishingData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FishingData(
      fishing_id: serializer.fromJson<int>(json['fishing_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      fishing_product_id: serializer.fromJson<int?>(json['fishing_product_id']),
      area_ha: serializer.fromJson<double?>(json['area_ha']),
      volume_kg: serializer.fromJson<double?>(json['volume_kg']),
      production_value: serializer.fromJson<int?>(json['production_value']),
      fisherman_count: serializer.fromJson<int?>(json['fisherman_count']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fishing_id': serializer.toJson<int>(fishing_id),
      'person_id': serializer.toJson<int>(person_id),
      'fishing_product_id': serializer.toJson<int?>(fishing_product_id),
      'area_ha': serializer.toJson<double?>(area_ha),
      'volume_kg': serializer.toJson<double?>(volume_kg),
      'production_value': serializer.toJson<int?>(production_value),
      'fisherman_count': serializer.toJson<int?>(fisherman_count),
    };
  }

  FishingData copyWith({
    int? fishing_id,
    int? person_id,
    Value<int?> fishing_product_id = const Value.absent(),
    Value<double?> area_ha = const Value.absent(),
    Value<double?> volume_kg = const Value.absent(),
    Value<int?> production_value = const Value.absent(),
    Value<int?> fisherman_count = const Value.absent(),
  }) => FishingData(
    fishing_id: fishing_id ?? this.fishing_id,
    person_id: person_id ?? this.person_id,
    fishing_product_id:
        fishing_product_id.present
            ? fishing_product_id.value
            : this.fishing_product_id,
    area_ha: area_ha.present ? area_ha.value : this.area_ha,
    volume_kg: volume_kg.present ? volume_kg.value : this.volume_kg,
    production_value:
        production_value.present
            ? production_value.value
            : this.production_value,
    fisherman_count:
        fisherman_count.present ? fisherman_count.value : this.fisherman_count,
  );
  FishingData copyWithCompanion(FishingCompanion data) {
    return FishingData(
      fishing_id:
          data.fishing_id.present ? data.fishing_id.value : this.fishing_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      fishing_product_id:
          data.fishing_product_id.present
              ? data.fishing_product_id.value
              : this.fishing_product_id,
      area_ha: data.area_ha.present ? data.area_ha.value : this.area_ha,
      volume_kg: data.volume_kg.present ? data.volume_kg.value : this.volume_kg,
      production_value:
          data.production_value.present
              ? data.production_value.value
              : this.production_value,
      fisherman_count:
          data.fisherman_count.present
              ? data.fisherman_count.value
              : this.fisherman_count,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FishingData(')
          ..write('fishing_id: $fishing_id, ')
          ..write('person_id: $person_id, ')
          ..write('fishing_product_id: $fishing_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('fisherman_count: $fisherman_count')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    fishing_id,
    person_id,
    fishing_product_id,
    area_ha,
    volume_kg,
    production_value,
    fisherman_count,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FishingData &&
          other.fishing_id == this.fishing_id &&
          other.person_id == this.person_id &&
          other.fishing_product_id == this.fishing_product_id &&
          other.area_ha == this.area_ha &&
          other.volume_kg == this.volume_kg &&
          other.production_value == this.production_value &&
          other.fisherman_count == this.fisherman_count);
}

class FishingCompanion extends UpdateCompanion<FishingData> {
  final Value<int> fishing_id;
  final Value<int> person_id;
  final Value<int?> fishing_product_id;
  final Value<double?> area_ha;
  final Value<double?> volume_kg;
  final Value<int?> production_value;
  final Value<int?> fisherman_count;
  const FishingCompanion({
    this.fishing_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.fishing_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.fisherman_count = const Value.absent(),
  });
  FishingCompanion.insert({
    this.fishing_id = const Value.absent(),
    required int person_id,
    this.fishing_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.fisherman_count = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<FishingData> custom({
    Expression<int>? fishing_id,
    Expression<int>? person_id,
    Expression<int>? fishing_product_id,
    Expression<double>? area_ha,
    Expression<double>? volume_kg,
    Expression<int>? production_value,
    Expression<int>? fisherman_count,
  }) {
    return RawValuesInsertable({
      if (fishing_id != null) 'fishing_id': fishing_id,
      if (person_id != null) 'person_id': person_id,
      if (fishing_product_id != null) 'fishing_product_id': fishing_product_id,
      if (area_ha != null) 'area_ha': area_ha,
      if (volume_kg != null) 'volume_kg': volume_kg,
      if (production_value != null) 'production_value': production_value,
      if (fisherman_count != null) 'fisherman_count': fisherman_count,
    });
  }

  FishingCompanion copyWith({
    Value<int>? fishing_id,
    Value<int>? person_id,
    Value<int?>? fishing_product_id,
    Value<double?>? area_ha,
    Value<double?>? volume_kg,
    Value<int?>? production_value,
    Value<int?>? fisherman_count,
  }) {
    return FishingCompanion(
      fishing_id: fishing_id ?? this.fishing_id,
      person_id: person_id ?? this.person_id,
      fishing_product_id: fishing_product_id ?? this.fishing_product_id,
      area_ha: area_ha ?? this.area_ha,
      volume_kg: volume_kg ?? this.volume_kg,
      production_value: production_value ?? this.production_value,
      fisherman_count: fisherman_count ?? this.fisherman_count,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fishing_id.present) {
      map['fishing_id'] = Variable<int>(fishing_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (fishing_product_id.present) {
      map['fishing_product_id'] = Variable<int>(fishing_product_id.value);
    }
    if (area_ha.present) {
      map['area_ha'] = Variable<double>(area_ha.value);
    }
    if (volume_kg.present) {
      map['volume_kg'] = Variable<double>(volume_kg.value);
    }
    if (production_value.present) {
      map['production_value'] = Variable<int>(production_value.value);
    }
    if (fisherman_count.present) {
      map['fisherman_count'] = Variable<int>(fisherman_count.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FishingCompanion(')
          ..write('fishing_id: $fishing_id, ')
          ..write('person_id: $person_id, ')
          ..write('fishing_product_id: $fishing_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('fisherman_count: $fisherman_count')
          ..write(')'))
        .toString();
  }
}

class $AgriProductsTable extends AgriProducts
    with TableInfo<$AgriProductsTable, AgriProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AgriProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _agri_product_idMeta = const VerificationMeta(
    'agri_product_id',
  );
  @override
  late final GeneratedColumn<int> agri_product_id = GeneratedColumn<int>(
    'agri_product_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [agri_product_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'agri_products';
  @override
  VerificationContext validateIntegrity(
    Insertable<AgriProductData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('agri_product_id')) {
      context.handle(
        _agri_product_idMeta,
        agri_product_id.isAcceptableOrUnknown(
          data['agri_product_id']!,
          _agri_product_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {agri_product_id};
  @override
  AgriProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AgriProductData(
      agri_product_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}agri_product_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $AgriProductsTable createAlias(String alias) {
    return $AgriProductsTable(attachedDatabase, alias);
  }
}

class AgriProductData extends DataClass implements Insertable<AgriProductData> {
  final int agri_product_id;
  final String name;
  const AgriProductData({required this.agri_product_id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['agri_product_id'] = Variable<int>(agri_product_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  AgriProductsCompanion toCompanion(bool nullToAbsent) {
    return AgriProductsCompanion(
      agri_product_id: Value(agri_product_id),
      name: Value(name),
    );
  }

  factory AgriProductData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AgriProductData(
      agri_product_id: serializer.fromJson<int>(json['agri_product_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'agri_product_id': serializer.toJson<int>(agri_product_id),
      'name': serializer.toJson<String>(name),
    };
  }

  AgriProductData copyWith({int? agri_product_id, String? name}) =>
      AgriProductData(
        agri_product_id: agri_product_id ?? this.agri_product_id,
        name: name ?? this.name,
      );
  AgriProductData copyWithCompanion(AgriProductsCompanion data) {
    return AgriProductData(
      agri_product_id:
          data.agri_product_id.present
              ? data.agri_product_id.value
              : this.agri_product_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AgriProductData(')
          ..write('agri_product_id: $agri_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(agri_product_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AgriProductData &&
          other.agri_product_id == this.agri_product_id &&
          other.name == this.name);
}

class AgriProductsCompanion extends UpdateCompanion<AgriProductData> {
  final Value<int> agri_product_id;
  final Value<String> name;
  const AgriProductsCompanion({
    this.agri_product_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  AgriProductsCompanion.insert({
    this.agri_product_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<AgriProductData> custom({
    Expression<int>? agri_product_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (agri_product_id != null) 'agri_product_id': agri_product_id,
      if (name != null) 'name': name,
    });
  }

  AgriProductsCompanion copyWith({
    Value<int>? agri_product_id,
    Value<String>? name,
  }) {
    return AgriProductsCompanion(
      agri_product_id: agri_product_id ?? this.agri_product_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (agri_product_id.present) {
      map['agri_product_id'] = Variable<int>(agri_product_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AgriProductsCompanion(')
          ..write('agri_product_id: $agri_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $AgricultureTable extends Agriculture
    with TableInfo<$AgricultureTable, AgricultureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AgricultureTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _agriculture_idMeta = const VerificationMeta(
    'agriculture_id',
  );
  @override
  late final GeneratedColumn<int> agriculture_id = GeneratedColumn<int>(
    'agriculture_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _agri_product_idMeta = const VerificationMeta(
    'agri_product_id',
  );
  @override
  late final GeneratedColumn<int> agri_product_id = GeneratedColumn<int>(
    'agri_product_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES agri_products (agri_product_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _area_haMeta = const VerificationMeta(
    'area_ha',
  );
  @override
  late final GeneratedColumn<double> area_ha = GeneratedColumn<double>(
    'area_ha',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _volume_kgMeta = const VerificationMeta(
    'volume_kg',
  );
  @override
  late final GeneratedColumn<double> volume_kg = GeneratedColumn<double>(
    'volume_kg',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _production_valueMeta = const VerificationMeta(
    'production_value',
  );
  @override
  late final GeneratedColumn<int> production_value = GeneratedColumn<int>(
    'production_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _farmer_countMeta = const VerificationMeta(
    'farmer_count',
  );
  @override
  late final GeneratedColumn<int> farmer_count = GeneratedColumn<int>(
    'farmer_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    agriculture_id,
    person_id,
    agri_product_id,
    area_ha,
    volume_kg,
    production_value,
    farmer_count,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'agriculture';
  @override
  VerificationContext validateIntegrity(
    Insertable<AgricultureData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('agriculture_id')) {
      context.handle(
        _agriculture_idMeta,
        agriculture_id.isAcceptableOrUnknown(
          data['agriculture_id']!,
          _agriculture_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('agri_product_id')) {
      context.handle(
        _agri_product_idMeta,
        agri_product_id.isAcceptableOrUnknown(
          data['agri_product_id']!,
          _agri_product_idMeta,
        ),
      );
    }
    if (data.containsKey('area_ha')) {
      context.handle(
        _area_haMeta,
        area_ha.isAcceptableOrUnknown(data['area_ha']!, _area_haMeta),
      );
    }
    if (data.containsKey('volume_kg')) {
      context.handle(
        _volume_kgMeta,
        volume_kg.isAcceptableOrUnknown(data['volume_kg']!, _volume_kgMeta),
      );
    }
    if (data.containsKey('production_value')) {
      context.handle(
        _production_valueMeta,
        production_value.isAcceptableOrUnknown(
          data['production_value']!,
          _production_valueMeta,
        ),
      );
    }
    if (data.containsKey('farmer_count')) {
      context.handle(
        _farmer_countMeta,
        farmer_count.isAcceptableOrUnknown(
          data['farmer_count']!,
          _farmer_countMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {agriculture_id};
  @override
  AgricultureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AgricultureData(
      agriculture_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}agriculture_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      agri_product_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}agri_product_id'],
      ),
      area_ha: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}area_ha'],
      ),
      volume_kg: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}volume_kg'],
      ),
      production_value: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}production_value'],
      ),
      farmer_count: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}farmer_count'],
      ),
    );
  }

  @override
  $AgricultureTable createAlias(String alias) {
    return $AgricultureTable(attachedDatabase, alias);
  }
}

class AgricultureData extends DataClass implements Insertable<AgricultureData> {
  final int agriculture_id;
  final int person_id;
  final int? agri_product_id;
  final double? area_ha;
  final double? volume_kg;
  final int? production_value;
  final int? farmer_count;
  const AgricultureData({
    required this.agriculture_id,
    required this.person_id,
    this.agri_product_id,
    this.area_ha,
    this.volume_kg,
    this.production_value,
    this.farmer_count,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['agriculture_id'] = Variable<int>(agriculture_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || agri_product_id != null) {
      map['agri_product_id'] = Variable<int>(agri_product_id);
    }
    if (!nullToAbsent || area_ha != null) {
      map['area_ha'] = Variable<double>(area_ha);
    }
    if (!nullToAbsent || volume_kg != null) {
      map['volume_kg'] = Variable<double>(volume_kg);
    }
    if (!nullToAbsent || production_value != null) {
      map['production_value'] = Variable<int>(production_value);
    }
    if (!nullToAbsent || farmer_count != null) {
      map['farmer_count'] = Variable<int>(farmer_count);
    }
    return map;
  }

  AgricultureCompanion toCompanion(bool nullToAbsent) {
    return AgricultureCompanion(
      agriculture_id: Value(agriculture_id),
      person_id: Value(person_id),
      agri_product_id:
          agri_product_id == null && nullToAbsent
              ? const Value.absent()
              : Value(agri_product_id),
      area_ha:
          area_ha == null && nullToAbsent
              ? const Value.absent()
              : Value(area_ha),
      volume_kg:
          volume_kg == null && nullToAbsent
              ? const Value.absent()
              : Value(volume_kg),
      production_value:
          production_value == null && nullToAbsent
              ? const Value.absent()
              : Value(production_value),
      farmer_count:
          farmer_count == null && nullToAbsent
              ? const Value.absent()
              : Value(farmer_count),
    );
  }

  factory AgricultureData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AgricultureData(
      agriculture_id: serializer.fromJson<int>(json['agriculture_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      agri_product_id: serializer.fromJson<int?>(json['agri_product_id']),
      area_ha: serializer.fromJson<double?>(json['area_ha']),
      volume_kg: serializer.fromJson<double?>(json['volume_kg']),
      production_value: serializer.fromJson<int?>(json['production_value']),
      farmer_count: serializer.fromJson<int?>(json['farmer_count']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'agriculture_id': serializer.toJson<int>(agriculture_id),
      'person_id': serializer.toJson<int>(person_id),
      'agri_product_id': serializer.toJson<int?>(agri_product_id),
      'area_ha': serializer.toJson<double?>(area_ha),
      'volume_kg': serializer.toJson<double?>(volume_kg),
      'production_value': serializer.toJson<int?>(production_value),
      'farmer_count': serializer.toJson<int?>(farmer_count),
    };
  }

  AgricultureData copyWith({
    int? agriculture_id,
    int? person_id,
    Value<int?> agri_product_id = const Value.absent(),
    Value<double?> area_ha = const Value.absent(),
    Value<double?> volume_kg = const Value.absent(),
    Value<int?> production_value = const Value.absent(),
    Value<int?> farmer_count = const Value.absent(),
  }) => AgricultureData(
    agriculture_id: agriculture_id ?? this.agriculture_id,
    person_id: person_id ?? this.person_id,
    agri_product_id:
        agri_product_id.present ? agri_product_id.value : this.agri_product_id,
    area_ha: area_ha.present ? area_ha.value : this.area_ha,
    volume_kg: volume_kg.present ? volume_kg.value : this.volume_kg,
    production_value:
        production_value.present
            ? production_value.value
            : this.production_value,
    farmer_count: farmer_count.present ? farmer_count.value : this.farmer_count,
  );
  AgricultureData copyWithCompanion(AgricultureCompanion data) {
    return AgricultureData(
      agriculture_id:
          data.agriculture_id.present
              ? data.agriculture_id.value
              : this.agriculture_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      agri_product_id:
          data.agri_product_id.present
              ? data.agri_product_id.value
              : this.agri_product_id,
      area_ha: data.area_ha.present ? data.area_ha.value : this.area_ha,
      volume_kg: data.volume_kg.present ? data.volume_kg.value : this.volume_kg,
      production_value:
          data.production_value.present
              ? data.production_value.value
              : this.production_value,
      farmer_count:
          data.farmer_count.present
              ? data.farmer_count.value
              : this.farmer_count,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AgricultureData(')
          ..write('agriculture_id: $agriculture_id, ')
          ..write('person_id: $person_id, ')
          ..write('agri_product_id: $agri_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('farmer_count: $farmer_count')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    agriculture_id,
    person_id,
    agri_product_id,
    area_ha,
    volume_kg,
    production_value,
    farmer_count,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AgricultureData &&
          other.agriculture_id == this.agriculture_id &&
          other.person_id == this.person_id &&
          other.agri_product_id == this.agri_product_id &&
          other.area_ha == this.area_ha &&
          other.volume_kg == this.volume_kg &&
          other.production_value == this.production_value &&
          other.farmer_count == this.farmer_count);
}

class AgricultureCompanion extends UpdateCompanion<AgricultureData> {
  final Value<int> agriculture_id;
  final Value<int> person_id;
  final Value<int?> agri_product_id;
  final Value<double?> area_ha;
  final Value<double?> volume_kg;
  final Value<int?> production_value;
  final Value<int?> farmer_count;
  const AgricultureCompanion({
    this.agriculture_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.agri_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.farmer_count = const Value.absent(),
  });
  AgricultureCompanion.insert({
    this.agriculture_id = const Value.absent(),
    required int person_id,
    this.agri_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.farmer_count = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<AgricultureData> custom({
    Expression<int>? agriculture_id,
    Expression<int>? person_id,
    Expression<int>? agri_product_id,
    Expression<double>? area_ha,
    Expression<double>? volume_kg,
    Expression<int>? production_value,
    Expression<int>? farmer_count,
  }) {
    return RawValuesInsertable({
      if (agriculture_id != null) 'agriculture_id': agriculture_id,
      if (person_id != null) 'person_id': person_id,
      if (agri_product_id != null) 'agri_product_id': agri_product_id,
      if (area_ha != null) 'area_ha': area_ha,
      if (volume_kg != null) 'volume_kg': volume_kg,
      if (production_value != null) 'production_value': production_value,
      if (farmer_count != null) 'farmer_count': farmer_count,
    });
  }

  AgricultureCompanion copyWith({
    Value<int>? agriculture_id,
    Value<int>? person_id,
    Value<int?>? agri_product_id,
    Value<double?>? area_ha,
    Value<double?>? volume_kg,
    Value<int?>? production_value,
    Value<int?>? farmer_count,
  }) {
    return AgricultureCompanion(
      agriculture_id: agriculture_id ?? this.agriculture_id,
      person_id: person_id ?? this.person_id,
      agri_product_id: agri_product_id ?? this.agri_product_id,
      area_ha: area_ha ?? this.area_ha,
      volume_kg: volume_kg ?? this.volume_kg,
      production_value: production_value ?? this.production_value,
      farmer_count: farmer_count ?? this.farmer_count,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (agriculture_id.present) {
      map['agriculture_id'] = Variable<int>(agriculture_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (agri_product_id.present) {
      map['agri_product_id'] = Variable<int>(agri_product_id.value);
    }
    if (area_ha.present) {
      map['area_ha'] = Variable<double>(area_ha.value);
    }
    if (volume_kg.present) {
      map['volume_kg'] = Variable<double>(volume_kg.value);
    }
    if (production_value.present) {
      map['production_value'] = Variable<int>(production_value.value);
    }
    if (farmer_count.present) {
      map['farmer_count'] = Variable<int>(farmer_count.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AgricultureCompanion(')
          ..write('agriculture_id: $agriculture_id, ')
          ..write('person_id: $person_id, ')
          ..write('agri_product_id: $agri_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('farmer_count: $farmer_count')
          ..write(')'))
        .toString();
  }
}

class $LivestockProductsTable extends LivestockProducts
    with TableInfo<$LivestockProductsTable, LivestockProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LivestockProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _livestock_product_idMeta =
      const VerificationMeta('livestock_product_id');
  @override
  late final GeneratedColumn<int> livestock_product_id = GeneratedColumn<int>(
    'livestock_product_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [livestock_product_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'livestock_products';
  @override
  VerificationContext validateIntegrity(
    Insertable<LivestockProductData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('livestock_product_id')) {
      context.handle(
        _livestock_product_idMeta,
        livestock_product_id.isAcceptableOrUnknown(
          data['livestock_product_id']!,
          _livestock_product_idMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {livestock_product_id};
  @override
  LivestockProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LivestockProductData(
      livestock_product_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}livestock_product_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $LivestockProductsTable createAlias(String alias) {
    return $LivestockProductsTable(attachedDatabase, alias);
  }
}

class LivestockProductData extends DataClass
    implements Insertable<LivestockProductData> {
  final int livestock_product_id;
  final String name;
  const LivestockProductData({
    required this.livestock_product_id,
    required this.name,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['livestock_product_id'] = Variable<int>(livestock_product_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  LivestockProductsCompanion toCompanion(bool nullToAbsent) {
    return LivestockProductsCompanion(
      livestock_product_id: Value(livestock_product_id),
      name: Value(name),
    );
  }

  factory LivestockProductData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LivestockProductData(
      livestock_product_id: serializer.fromJson<int>(
        json['livestock_product_id'],
      ),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'livestock_product_id': serializer.toJson<int>(livestock_product_id),
      'name': serializer.toJson<String>(name),
    };
  }

  LivestockProductData copyWith({int? livestock_product_id, String? name}) =>
      LivestockProductData(
        livestock_product_id: livestock_product_id ?? this.livestock_product_id,
        name: name ?? this.name,
      );
  LivestockProductData copyWithCompanion(LivestockProductsCompanion data) {
    return LivestockProductData(
      livestock_product_id:
          data.livestock_product_id.present
              ? data.livestock_product_id.value
              : this.livestock_product_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LivestockProductData(')
          ..write('livestock_product_id: $livestock_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(livestock_product_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LivestockProductData &&
          other.livestock_product_id == this.livestock_product_id &&
          other.name == this.name);
}

class LivestockProductsCompanion extends UpdateCompanion<LivestockProductData> {
  final Value<int> livestock_product_id;
  final Value<String> name;
  const LivestockProductsCompanion({
    this.livestock_product_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  LivestockProductsCompanion.insert({
    this.livestock_product_id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<LivestockProductData> custom({
    Expression<int>? livestock_product_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (livestock_product_id != null)
        'livestock_product_id': livestock_product_id,
      if (name != null) 'name': name,
    });
  }

  LivestockProductsCompanion copyWith({
    Value<int>? livestock_product_id,
    Value<String>? name,
  }) {
    return LivestockProductsCompanion(
      livestock_product_id: livestock_product_id ?? this.livestock_product_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (livestock_product_id.present) {
      map['livestock_product_id'] = Variable<int>(livestock_product_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LivestockProductsCompanion(')
          ..write('livestock_product_id: $livestock_product_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $LivestockTable extends Livestock
    with TableInfo<$LivestockTable, LivestockData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LivestockTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _livestock_idMeta = const VerificationMeta(
    'livestock_id',
  );
  @override
  late final GeneratedColumn<int> livestock_id = GeneratedColumn<int>(
    'livestock_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _livestock_product_idMeta =
      const VerificationMeta('livestock_product_id');
  @override
  late final GeneratedColumn<int> livestock_product_id = GeneratedColumn<int>(
    'livestock_product_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES livestock_products (livestock_product_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _area_haMeta = const VerificationMeta(
    'area_ha',
  );
  @override
  late final GeneratedColumn<double> area_ha = GeneratedColumn<double>(
    'area_ha',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _volume_kgMeta = const VerificationMeta(
    'volume_kg',
  );
  @override
  late final GeneratedColumn<double> volume_kg = GeneratedColumn<double>(
    'volume_kg',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _production_valueMeta = const VerificationMeta(
    'production_value',
  );
  @override
  late final GeneratedColumn<int> production_value = GeneratedColumn<int>(
    'production_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _farmer_countMeta = const VerificationMeta(
    'farmer_count',
  );
  @override
  late final GeneratedColumn<int> farmer_count = GeneratedColumn<int>(
    'farmer_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    livestock_id,
    person_id,
    livestock_product_id,
    area_ha,
    volume_kg,
    production_value,
    farmer_count,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'livestock';
  @override
  VerificationContext validateIntegrity(
    Insertable<LivestockData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('livestock_id')) {
      context.handle(
        _livestock_idMeta,
        livestock_id.isAcceptableOrUnknown(
          data['livestock_id']!,
          _livestock_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('livestock_product_id')) {
      context.handle(
        _livestock_product_idMeta,
        livestock_product_id.isAcceptableOrUnknown(
          data['livestock_product_id']!,
          _livestock_product_idMeta,
        ),
      );
    }
    if (data.containsKey('area_ha')) {
      context.handle(
        _area_haMeta,
        area_ha.isAcceptableOrUnknown(data['area_ha']!, _area_haMeta),
      );
    }
    if (data.containsKey('volume_kg')) {
      context.handle(
        _volume_kgMeta,
        volume_kg.isAcceptableOrUnknown(data['volume_kg']!, _volume_kgMeta),
      );
    }
    if (data.containsKey('production_value')) {
      context.handle(
        _production_valueMeta,
        production_value.isAcceptableOrUnknown(
          data['production_value']!,
          _production_valueMeta,
        ),
      );
    }
    if (data.containsKey('farmer_count')) {
      context.handle(
        _farmer_countMeta,
        farmer_count.isAcceptableOrUnknown(
          data['farmer_count']!,
          _farmer_countMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {livestock_id};
  @override
  LivestockData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LivestockData(
      livestock_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}livestock_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      livestock_product_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}livestock_product_id'],
      ),
      area_ha: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}area_ha'],
      ),
      volume_kg: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}volume_kg'],
      ),
      production_value: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}production_value'],
      ),
      farmer_count: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}farmer_count'],
      ),
    );
  }

  @override
  $LivestockTable createAlias(String alias) {
    return $LivestockTable(attachedDatabase, alias);
  }
}

class LivestockData extends DataClass implements Insertable<LivestockData> {
  final int livestock_id;
  final int person_id;
  final int? livestock_product_id;
  final double? area_ha;
  final double? volume_kg;
  final int? production_value;
  final int? farmer_count;
  const LivestockData({
    required this.livestock_id,
    required this.person_id,
    this.livestock_product_id,
    this.area_ha,
    this.volume_kg,
    this.production_value,
    this.farmer_count,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['livestock_id'] = Variable<int>(livestock_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || livestock_product_id != null) {
      map['livestock_product_id'] = Variable<int>(livestock_product_id);
    }
    if (!nullToAbsent || area_ha != null) {
      map['area_ha'] = Variable<double>(area_ha);
    }
    if (!nullToAbsent || volume_kg != null) {
      map['volume_kg'] = Variable<double>(volume_kg);
    }
    if (!nullToAbsent || production_value != null) {
      map['production_value'] = Variable<int>(production_value);
    }
    if (!nullToAbsent || farmer_count != null) {
      map['farmer_count'] = Variable<int>(farmer_count);
    }
    return map;
  }

  LivestockCompanion toCompanion(bool nullToAbsent) {
    return LivestockCompanion(
      livestock_id: Value(livestock_id),
      person_id: Value(person_id),
      livestock_product_id:
          livestock_product_id == null && nullToAbsent
              ? const Value.absent()
              : Value(livestock_product_id),
      area_ha:
          area_ha == null && nullToAbsent
              ? const Value.absent()
              : Value(area_ha),
      volume_kg:
          volume_kg == null && nullToAbsent
              ? const Value.absent()
              : Value(volume_kg),
      production_value:
          production_value == null && nullToAbsent
              ? const Value.absent()
              : Value(production_value),
      farmer_count:
          farmer_count == null && nullToAbsent
              ? const Value.absent()
              : Value(farmer_count),
    );
  }

  factory LivestockData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LivestockData(
      livestock_id: serializer.fromJson<int>(json['livestock_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      livestock_product_id: serializer.fromJson<int?>(
        json['livestock_product_id'],
      ),
      area_ha: serializer.fromJson<double?>(json['area_ha']),
      volume_kg: serializer.fromJson<double?>(json['volume_kg']),
      production_value: serializer.fromJson<int?>(json['production_value']),
      farmer_count: serializer.fromJson<int?>(json['farmer_count']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'livestock_id': serializer.toJson<int>(livestock_id),
      'person_id': serializer.toJson<int>(person_id),
      'livestock_product_id': serializer.toJson<int?>(livestock_product_id),
      'area_ha': serializer.toJson<double?>(area_ha),
      'volume_kg': serializer.toJson<double?>(volume_kg),
      'production_value': serializer.toJson<int?>(production_value),
      'farmer_count': serializer.toJson<int?>(farmer_count),
    };
  }

  LivestockData copyWith({
    int? livestock_id,
    int? person_id,
    Value<int?> livestock_product_id = const Value.absent(),
    Value<double?> area_ha = const Value.absent(),
    Value<double?> volume_kg = const Value.absent(),
    Value<int?> production_value = const Value.absent(),
    Value<int?> farmer_count = const Value.absent(),
  }) => LivestockData(
    livestock_id: livestock_id ?? this.livestock_id,
    person_id: person_id ?? this.person_id,
    livestock_product_id:
        livestock_product_id.present
            ? livestock_product_id.value
            : this.livestock_product_id,
    area_ha: area_ha.present ? area_ha.value : this.area_ha,
    volume_kg: volume_kg.present ? volume_kg.value : this.volume_kg,
    production_value:
        production_value.present
            ? production_value.value
            : this.production_value,
    farmer_count: farmer_count.present ? farmer_count.value : this.farmer_count,
  );
  LivestockData copyWithCompanion(LivestockCompanion data) {
    return LivestockData(
      livestock_id:
          data.livestock_id.present
              ? data.livestock_id.value
              : this.livestock_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      livestock_product_id:
          data.livestock_product_id.present
              ? data.livestock_product_id.value
              : this.livestock_product_id,
      area_ha: data.area_ha.present ? data.area_ha.value : this.area_ha,
      volume_kg: data.volume_kg.present ? data.volume_kg.value : this.volume_kg,
      production_value:
          data.production_value.present
              ? data.production_value.value
              : this.production_value,
      farmer_count:
          data.farmer_count.present
              ? data.farmer_count.value
              : this.farmer_count,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LivestockData(')
          ..write('livestock_id: $livestock_id, ')
          ..write('person_id: $person_id, ')
          ..write('livestock_product_id: $livestock_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('farmer_count: $farmer_count')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    livestock_id,
    person_id,
    livestock_product_id,
    area_ha,
    volume_kg,
    production_value,
    farmer_count,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LivestockData &&
          other.livestock_id == this.livestock_id &&
          other.person_id == this.person_id &&
          other.livestock_product_id == this.livestock_product_id &&
          other.area_ha == this.area_ha &&
          other.volume_kg == this.volume_kg &&
          other.production_value == this.production_value &&
          other.farmer_count == this.farmer_count);
}

class LivestockCompanion extends UpdateCompanion<LivestockData> {
  final Value<int> livestock_id;
  final Value<int> person_id;
  final Value<int?> livestock_product_id;
  final Value<double?> area_ha;
  final Value<double?> volume_kg;
  final Value<int?> production_value;
  final Value<int?> farmer_count;
  const LivestockCompanion({
    this.livestock_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.livestock_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.farmer_count = const Value.absent(),
  });
  LivestockCompanion.insert({
    this.livestock_id = const Value.absent(),
    required int person_id,
    this.livestock_product_id = const Value.absent(),
    this.area_ha = const Value.absent(),
    this.volume_kg = const Value.absent(),
    this.production_value = const Value.absent(),
    this.farmer_count = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<LivestockData> custom({
    Expression<int>? livestock_id,
    Expression<int>? person_id,
    Expression<int>? livestock_product_id,
    Expression<double>? area_ha,
    Expression<double>? volume_kg,
    Expression<int>? production_value,
    Expression<int>? farmer_count,
  }) {
    return RawValuesInsertable({
      if (livestock_id != null) 'livestock_id': livestock_id,
      if (person_id != null) 'person_id': person_id,
      if (livestock_product_id != null)
        'livestock_product_id': livestock_product_id,
      if (area_ha != null) 'area_ha': area_ha,
      if (volume_kg != null) 'volume_kg': volume_kg,
      if (production_value != null) 'production_value': production_value,
      if (farmer_count != null) 'farmer_count': farmer_count,
    });
  }

  LivestockCompanion copyWith({
    Value<int>? livestock_id,
    Value<int>? person_id,
    Value<int?>? livestock_product_id,
    Value<double?>? area_ha,
    Value<double?>? volume_kg,
    Value<int?>? production_value,
    Value<int?>? farmer_count,
  }) {
    return LivestockCompanion(
      livestock_id: livestock_id ?? this.livestock_id,
      person_id: person_id ?? this.person_id,
      livestock_product_id: livestock_product_id ?? this.livestock_product_id,
      area_ha: area_ha ?? this.area_ha,
      volume_kg: volume_kg ?? this.volume_kg,
      production_value: production_value ?? this.production_value,
      farmer_count: farmer_count ?? this.farmer_count,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (livestock_id.present) {
      map['livestock_id'] = Variable<int>(livestock_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (livestock_product_id.present) {
      map['livestock_product_id'] = Variable<int>(livestock_product_id.value);
    }
    if (area_ha.present) {
      map['area_ha'] = Variable<double>(area_ha.value);
    }
    if (volume_kg.present) {
      map['volume_kg'] = Variable<double>(volume_kg.value);
    }
    if (production_value.present) {
      map['production_value'] = Variable<int>(production_value.value);
    }
    if (farmer_count.present) {
      map['farmer_count'] = Variable<int>(farmer_count.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LivestockCompanion(')
          ..write('livestock_id: $livestock_id, ')
          ..write('person_id: $person_id, ')
          ..write('livestock_product_id: $livestock_product_id, ')
          ..write('area_ha: $area_ha, ')
          ..write('volume_kg: $volume_kg, ')
          ..write('production_value: $production_value, ')
          ..write('farmer_count: $farmer_count')
          ..write(')'))
        .toString();
  }
}

class $QuestionsTable extends Questions
    with TableInfo<$QuestionsTable, QuestionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $QuestionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _question_idMeta = const VerificationMeta(
    'question_id',
  );
  @override
  late final GeneratedColumn<int> question_id = GeneratedColumn<int>(
    'question_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _questionMeta = const VerificationMeta(
    'question',
  );
  @override
  late final GeneratedColumn<String> question = GeneratedColumn<String>(
    'question',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [question_id, question];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'questions';
  @override
  VerificationContext validateIntegrity(
    Insertable<QuestionData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('question_id')) {
      context.handle(
        _question_idMeta,
        question_id.isAcceptableOrUnknown(
          data['question_id']!,
          _question_idMeta,
        ),
      );
    }
    if (data.containsKey('question')) {
      context.handle(
        _questionMeta,
        question.isAcceptableOrUnknown(data['question']!, _questionMeta),
      );
    } else if (isInserting) {
      context.missing(_questionMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {question_id};
  @override
  QuestionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return QuestionData(
      question_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}question_id'],
          )!,
      question:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}question'],
          )!,
    );
  }

  @override
  $QuestionsTable createAlias(String alias) {
    return $QuestionsTable(attachedDatabase, alias);
  }
}

class QuestionData extends DataClass implements Insertable<QuestionData> {
  final int question_id;
  final String question;
  const QuestionData({required this.question_id, required this.question});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['question_id'] = Variable<int>(question_id);
    map['question'] = Variable<String>(question);
    return map;
  }

  QuestionsCompanion toCompanion(bool nullToAbsent) {
    return QuestionsCompanion(
      question_id: Value(question_id),
      question: Value(question),
    );
  }

  factory QuestionData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return QuestionData(
      question_id: serializer.fromJson<int>(json['question_id']),
      question: serializer.fromJson<String>(json['question']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'question_id': serializer.toJson<int>(question_id),
      'question': serializer.toJson<String>(question),
    };
  }

  QuestionData copyWith({int? question_id, String? question}) => QuestionData(
    question_id: question_id ?? this.question_id,
    question: question ?? this.question,
  );
  QuestionData copyWithCompanion(QuestionsCompanion data) {
    return QuestionData(
      question_id:
          data.question_id.present ? data.question_id.value : this.question_id,
      question: data.question.present ? data.question.value : this.question,
    );
  }

  @override
  String toString() {
    return (StringBuffer('QuestionData(')
          ..write('question_id: $question_id, ')
          ..write('question: $question')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(question_id, question);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is QuestionData &&
          other.question_id == this.question_id &&
          other.question == this.question);
}

class QuestionsCompanion extends UpdateCompanion<QuestionData> {
  final Value<int> question_id;
  final Value<String> question;
  const QuestionsCompanion({
    this.question_id = const Value.absent(),
    this.question = const Value.absent(),
  });
  QuestionsCompanion.insert({
    this.question_id = const Value.absent(),
    required String question,
  }) : question = Value(question);
  static Insertable<QuestionData> custom({
    Expression<int>? question_id,
    Expression<String>? question,
  }) {
    return RawValuesInsertable({
      if (question_id != null) 'question_id': question_id,
      if (question != null) 'question': question,
    });
  }

  QuestionsCompanion copyWith({
    Value<int>? question_id,
    Value<String>? question,
  }) {
    return QuestionsCompanion(
      question_id: question_id ?? this.question_id,
      question: question ?? this.question,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (question_id.present) {
      map['question_id'] = Variable<int>(question_id.value);
    }
    if (question.present) {
      map['question'] = Variable<String>(question.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('QuestionsCompanion(')
          ..write('question_id: $question_id, ')
          ..write('question: $question')
          ..write(')'))
        .toString();
  }
}

class $QuestionChoicesTable extends QuestionChoices
    with TableInfo<$QuestionChoicesTable, QustionChoiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $QuestionChoicesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _choice_idMeta = const VerificationMeta(
    'choice_id',
  );
  @override
  late final GeneratedColumn<int> choice_id = GeneratedColumn<int>(
    'choice_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _choiceMeta = const VerificationMeta('choice');
  @override
  late final GeneratedColumn<String> choice = GeneratedColumn<String>(
    'choice',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _question_idMeta = const VerificationMeta(
    'question_id',
  );
  @override
  late final GeneratedColumn<int> question_id = GeneratedColumn<int>(
    'question_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES questions (question_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [choice_id, choice, question_id];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'question_choices';
  @override
  VerificationContext validateIntegrity(
    Insertable<QustionChoiceData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('choice_id')) {
      context.handle(
        _choice_idMeta,
        choice_id.isAcceptableOrUnknown(data['choice_id']!, _choice_idMeta),
      );
    }
    if (data.containsKey('choice')) {
      context.handle(
        _choiceMeta,
        choice.isAcceptableOrUnknown(data['choice']!, _choiceMeta),
      );
    } else if (isInserting) {
      context.missing(_choiceMeta);
    }
    if (data.containsKey('question_id')) {
      context.handle(
        _question_idMeta,
        question_id.isAcceptableOrUnknown(
          data['question_id']!,
          _question_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_question_idMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {choice_id};
  @override
  QustionChoiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return QustionChoiceData(
      choice_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}choice_id'],
          )!,
      choice:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}choice'],
          )!,
      question_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}question_id'],
          )!,
    );
  }

  @override
  $QuestionChoicesTable createAlias(String alias) {
    return $QuestionChoicesTable(attachedDatabase, alias);
  }
}

class QustionChoiceData extends DataClass
    implements Insertable<QustionChoiceData> {
  final int choice_id;
  final String choice;
  final int question_id;
  const QustionChoiceData({
    required this.choice_id,
    required this.choice,
    required this.question_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['choice_id'] = Variable<int>(choice_id);
    map['choice'] = Variable<String>(choice);
    map['question_id'] = Variable<int>(question_id);
    return map;
  }

  QuestionChoicesCompanion toCompanion(bool nullToAbsent) {
    return QuestionChoicesCompanion(
      choice_id: Value(choice_id),
      choice: Value(choice),
      question_id: Value(question_id),
    );
  }

  factory QustionChoiceData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return QustionChoiceData(
      choice_id: serializer.fromJson<int>(json['choice_id']),
      choice: serializer.fromJson<String>(json['choice']),
      question_id: serializer.fromJson<int>(json['question_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'choice_id': serializer.toJson<int>(choice_id),
      'choice': serializer.toJson<String>(choice),
      'question_id': serializer.toJson<int>(question_id),
    };
  }

  QustionChoiceData copyWith({
    int? choice_id,
    String? choice,
    int? question_id,
  }) => QustionChoiceData(
    choice_id: choice_id ?? this.choice_id,
    choice: choice ?? this.choice,
    question_id: question_id ?? this.question_id,
  );
  QustionChoiceData copyWithCompanion(QuestionChoicesCompanion data) {
    return QustionChoiceData(
      choice_id: data.choice_id.present ? data.choice_id.value : this.choice_id,
      choice: data.choice.present ? data.choice.value : this.choice,
      question_id:
          data.question_id.present ? data.question_id.value : this.question_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('QustionChoiceData(')
          ..write('choice_id: $choice_id, ')
          ..write('choice: $choice, ')
          ..write('question_id: $question_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(choice_id, choice, question_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is QustionChoiceData &&
          other.choice_id == this.choice_id &&
          other.choice == this.choice &&
          other.question_id == this.question_id);
}

class QuestionChoicesCompanion extends UpdateCompanion<QustionChoiceData> {
  final Value<int> choice_id;
  final Value<String> choice;
  final Value<int> question_id;
  const QuestionChoicesCompanion({
    this.choice_id = const Value.absent(),
    this.choice = const Value.absent(),
    this.question_id = const Value.absent(),
  });
  QuestionChoicesCompanion.insert({
    this.choice_id = const Value.absent(),
    required String choice,
    required int question_id,
  }) : choice = Value(choice),
       question_id = Value(question_id);
  static Insertable<QustionChoiceData> custom({
    Expression<int>? choice_id,
    Expression<String>? choice,
    Expression<int>? question_id,
  }) {
    return RawValuesInsertable({
      if (choice_id != null) 'choice_id': choice_id,
      if (choice != null) 'choice': choice,
      if (question_id != null) 'question_id': question_id,
    });
  }

  QuestionChoicesCompanion copyWith({
    Value<int>? choice_id,
    Value<String>? choice,
    Value<int>? question_id,
  }) {
    return QuestionChoicesCompanion(
      choice_id: choice_id ?? this.choice_id,
      choice: choice ?? this.choice,
      question_id: question_id ?? this.question_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (choice_id.present) {
      map['choice_id'] = Variable<int>(choice_id.value);
    }
    if (choice.present) {
      map['choice'] = Variable<String>(choice.value);
    }
    if (question_id.present) {
      map['question_id'] = Variable<int>(question_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('QuestionChoicesCompanion(')
          ..write('choice_id: $choice_id, ')
          ..write('choice: $choice, ')
          ..write('question_id: $question_id')
          ..write(')'))
        .toString();
  }
}

class $HouseholdResponsesTable extends HouseholdResponses
    with TableInfo<$HouseholdResponsesTable, HouseholdResponseData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdResponsesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _response_idMeta = const VerificationMeta(
    'response_id',
  );
  @override
  late final GeneratedColumn<int> response_id = GeneratedColumn<int>(
    'response_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _choice_idMeta = const VerificationMeta(
    'choice_id',
  );
  @override
  late final GeneratedColumn<int> choice_id = GeneratedColumn<int>(
    'choice_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES question_choices (choice_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _question_idMeta = const VerificationMeta(
    'question_id',
  );
  @override
  late final GeneratedColumn<int> question_id = GeneratedColumn<int>(
    'question_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES questions (question_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [response_id, choice_id, question_id];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household_responses';
  @override
  VerificationContext validateIntegrity(
    Insertable<HouseholdResponseData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('response_id')) {
      context.handle(
        _response_idMeta,
        response_id.isAcceptableOrUnknown(
          data['response_id']!,
          _response_idMeta,
        ),
      );
    }
    if (data.containsKey('choice_id')) {
      context.handle(
        _choice_idMeta,
        choice_id.isAcceptableOrUnknown(data['choice_id']!, _choice_idMeta),
      );
    } else if (isInserting) {
      context.missing(_choice_idMeta);
    }
    if (data.containsKey('question_id')) {
      context.handle(
        _question_idMeta,
        question_id.isAcceptableOrUnknown(
          data['question_id']!,
          _question_idMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_question_idMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {response_id};
  @override
  HouseholdResponseData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdResponseData(
      response_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}response_id'],
          )!,
      choice_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}choice_id'],
          )!,
      question_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}question_id'],
          )!,
    );
  }

  @override
  $HouseholdResponsesTable createAlias(String alias) {
    return $HouseholdResponsesTable(attachedDatabase, alias);
  }
}

class HouseholdResponseData extends DataClass
    implements Insertable<HouseholdResponseData> {
  final int response_id;
  final int choice_id;
  final int question_id;
  const HouseholdResponseData({
    required this.response_id,
    required this.choice_id,
    required this.question_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['response_id'] = Variable<int>(response_id);
    map['choice_id'] = Variable<int>(choice_id);
    map['question_id'] = Variable<int>(question_id);
    return map;
  }

  HouseholdResponsesCompanion toCompanion(bool nullToAbsent) {
    return HouseholdResponsesCompanion(
      response_id: Value(response_id),
      choice_id: Value(choice_id),
      question_id: Value(question_id),
    );
  }

  factory HouseholdResponseData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdResponseData(
      response_id: serializer.fromJson<int>(json['response_id']),
      choice_id: serializer.fromJson<int>(json['choice_id']),
      question_id: serializer.fromJson<int>(json['question_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'response_id': serializer.toJson<int>(response_id),
      'choice_id': serializer.toJson<int>(choice_id),
      'question_id': serializer.toJson<int>(question_id),
    };
  }

  HouseholdResponseData copyWith({
    int? response_id,
    int? choice_id,
    int? question_id,
  }) => HouseholdResponseData(
    response_id: response_id ?? this.response_id,
    choice_id: choice_id ?? this.choice_id,
    question_id: question_id ?? this.question_id,
  );
  HouseholdResponseData copyWithCompanion(HouseholdResponsesCompanion data) {
    return HouseholdResponseData(
      response_id:
          data.response_id.present ? data.response_id.value : this.response_id,
      choice_id: data.choice_id.present ? data.choice_id.value : this.choice_id,
      question_id:
          data.question_id.present ? data.question_id.value : this.question_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdResponseData(')
          ..write('response_id: $response_id, ')
          ..write('choice_id: $choice_id, ')
          ..write('question_id: $question_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(response_id, choice_id, question_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdResponseData &&
          other.response_id == this.response_id &&
          other.choice_id == this.choice_id &&
          other.question_id == this.question_id);
}

class HouseholdResponsesCompanion
    extends UpdateCompanion<HouseholdResponseData> {
  final Value<int> response_id;
  final Value<int> choice_id;
  final Value<int> question_id;
  const HouseholdResponsesCompanion({
    this.response_id = const Value.absent(),
    this.choice_id = const Value.absent(),
    this.question_id = const Value.absent(),
  });
  HouseholdResponsesCompanion.insert({
    this.response_id = const Value.absent(),
    required int choice_id,
    required int question_id,
  }) : choice_id = Value(choice_id),
       question_id = Value(question_id);
  static Insertable<HouseholdResponseData> custom({
    Expression<int>? response_id,
    Expression<int>? choice_id,
    Expression<int>? question_id,
  }) {
    return RawValuesInsertable({
      if (response_id != null) 'response_id': response_id,
      if (choice_id != null) 'choice_id': choice_id,
      if (question_id != null) 'question_id': question_id,
    });
  }

  HouseholdResponsesCompanion copyWith({
    Value<int>? response_id,
    Value<int>? choice_id,
    Value<int>? question_id,
  }) {
    return HouseholdResponsesCompanion(
      response_id: response_id ?? this.response_id,
      choice_id: choice_id ?? this.choice_id,
      question_id: question_id ?? this.question_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (response_id.present) {
      map['response_id'] = Variable<int>(response_id.value);
    }
    if (choice_id.present) {
      map['choice_id'] = Variable<int>(choice_id.value);
    }
    if (question_id.present) {
      map['question_id'] = Variable<int>(question_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdResponsesCompanion(')
          ..write('response_id: $response_id, ')
          ..write('choice_id: $choice_id, ')
          ..write('question_id: $question_id')
          ..write(')'))
        .toString();
  }
}

class $FamilyPlansTable extends FamilyPlans
    with TableInfo<$FamilyPlansTable, FamilyPlanData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FamilyPlansTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _family_plan_idMeta = const VerificationMeta(
    'family_plan_id',
  );
  @override
  late final GeneratedColumn<int> family_plan_id = GeneratedColumn<int>(
    'family_plan_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _fp_method_idMeta = const VerificationMeta(
    'fp_method_id',
  );
  @override
  late final GeneratedColumn<int> fp_method_id = GeneratedColumn<int>(
    'fp_method_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES fp_methods (fp_method_id) ON DELETE RESTRICT',
    ),
  );
  static const VerificationMeta _fp_source_idMeta = const VerificationMeta(
    'fp_source_id',
  );
  @override
  late final GeneratedColumn<int> fp_source_id = GeneratedColumn<int>(
    'fp_source_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES fp_sources (fp_source_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    family_plan_id,
    person_id,
    fp_method_id,
    fp_source_id,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'family_plans';
  @override
  VerificationContext validateIntegrity(
    Insertable<FamilyPlanData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('family_plan_id')) {
      context.handle(
        _family_plan_idMeta,
        family_plan_id.isAcceptableOrUnknown(
          data['family_plan_id']!,
          _family_plan_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('fp_method_id')) {
      context.handle(
        _fp_method_idMeta,
        fp_method_id.isAcceptableOrUnknown(
          data['fp_method_id']!,
          _fp_method_idMeta,
        ),
      );
    }
    if (data.containsKey('fp_source_id')) {
      context.handle(
        _fp_source_idMeta,
        fp_source_id.isAcceptableOrUnknown(
          data['fp_source_id']!,
          _fp_source_idMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {family_plan_id};
  @override
  FamilyPlanData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FamilyPlanData(
      family_plan_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}family_plan_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      fp_method_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fp_method_id'],
      ),
      fp_source_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fp_source_id'],
      ),
    );
  }

  @override
  $FamilyPlansTable createAlias(String alias) {
    return $FamilyPlansTable(attachedDatabase, alias);
  }
}

class FamilyPlanData extends DataClass implements Insertable<FamilyPlanData> {
  final int family_plan_id;
  final int person_id;
  final int? fp_method_id;
  final int? fp_source_id;
  const FamilyPlanData({
    required this.family_plan_id,
    required this.person_id,
    this.fp_method_id,
    this.fp_source_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['family_plan_id'] = Variable<int>(family_plan_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || fp_method_id != null) {
      map['fp_method_id'] = Variable<int>(fp_method_id);
    }
    if (!nullToAbsent || fp_source_id != null) {
      map['fp_source_id'] = Variable<int>(fp_source_id);
    }
    return map;
  }

  FamilyPlansCompanion toCompanion(bool nullToAbsent) {
    return FamilyPlansCompanion(
      family_plan_id: Value(family_plan_id),
      person_id: Value(person_id),
      fp_method_id:
          fp_method_id == null && nullToAbsent
              ? const Value.absent()
              : Value(fp_method_id),
      fp_source_id:
          fp_source_id == null && nullToAbsent
              ? const Value.absent()
              : Value(fp_source_id),
    );
  }

  factory FamilyPlanData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FamilyPlanData(
      family_plan_id: serializer.fromJson<int>(json['family_plan_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      fp_method_id: serializer.fromJson<int?>(json['fp_method_id']),
      fp_source_id: serializer.fromJson<int?>(json['fp_source_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'family_plan_id': serializer.toJson<int>(family_plan_id),
      'person_id': serializer.toJson<int>(person_id),
      'fp_method_id': serializer.toJson<int?>(fp_method_id),
      'fp_source_id': serializer.toJson<int?>(fp_source_id),
    };
  }

  FamilyPlanData copyWith({
    int? family_plan_id,
    int? person_id,
    Value<int?> fp_method_id = const Value.absent(),
    Value<int?> fp_source_id = const Value.absent(),
  }) => FamilyPlanData(
    family_plan_id: family_plan_id ?? this.family_plan_id,
    person_id: person_id ?? this.person_id,
    fp_method_id: fp_method_id.present ? fp_method_id.value : this.fp_method_id,
    fp_source_id: fp_source_id.present ? fp_source_id.value : this.fp_source_id,
  );
  FamilyPlanData copyWithCompanion(FamilyPlansCompanion data) {
    return FamilyPlanData(
      family_plan_id:
          data.family_plan_id.present
              ? data.family_plan_id.value
              : this.family_plan_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      fp_method_id:
          data.fp_method_id.present
              ? data.fp_method_id.value
              : this.fp_method_id,
      fp_source_id:
          data.fp_source_id.present
              ? data.fp_source_id.value
              : this.fp_source_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FamilyPlanData(')
          ..write('family_plan_id: $family_plan_id, ')
          ..write('person_id: $person_id, ')
          ..write('fp_method_id: $fp_method_id, ')
          ..write('fp_source_id: $fp_source_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(family_plan_id, person_id, fp_method_id, fp_source_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FamilyPlanData &&
          other.family_plan_id == this.family_plan_id &&
          other.person_id == this.person_id &&
          other.fp_method_id == this.fp_method_id &&
          other.fp_source_id == this.fp_source_id);
}

class FamilyPlansCompanion extends UpdateCompanion<FamilyPlanData> {
  final Value<int> family_plan_id;
  final Value<int> person_id;
  final Value<int?> fp_method_id;
  final Value<int?> fp_source_id;
  const FamilyPlansCompanion({
    this.family_plan_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.fp_method_id = const Value.absent(),
    this.fp_source_id = const Value.absent(),
  });
  FamilyPlansCompanion.insert({
    this.family_plan_id = const Value.absent(),
    required int person_id,
    this.fp_method_id = const Value.absent(),
    this.fp_source_id = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<FamilyPlanData> custom({
    Expression<int>? family_plan_id,
    Expression<int>? person_id,
    Expression<int>? fp_method_id,
    Expression<int>? fp_source_id,
  }) {
    return RawValuesInsertable({
      if (family_plan_id != null) 'family_plan_id': family_plan_id,
      if (person_id != null) 'person_id': person_id,
      if (fp_method_id != null) 'fp_method_id': fp_method_id,
      if (fp_source_id != null) 'fp_source_id': fp_source_id,
    });
  }

  FamilyPlansCompanion copyWith({
    Value<int>? family_plan_id,
    Value<int>? person_id,
    Value<int?>? fp_method_id,
    Value<int?>? fp_source_id,
  }) {
    return FamilyPlansCompanion(
      family_plan_id: family_plan_id ?? this.family_plan_id,
      person_id: person_id ?? this.person_id,
      fp_method_id: fp_method_id ?? this.fp_method_id,
      fp_source_id: fp_source_id ?? this.fp_source_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (family_plan_id.present) {
      map['family_plan_id'] = Variable<int>(family_plan_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (fp_method_id.present) {
      map['fp_method_id'] = Variable<int>(fp_method_id.value);
    }
    if (fp_source_id.present) {
      map['fp_source_id'] = Variable<int>(fp_source_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FamilyPlansCompanion(')
          ..write('family_plan_id: $family_plan_id, ')
          ..write('person_id: $person_id, ')
          ..write('fp_method_id: $fp_method_id, ')
          ..write('fp_source_id: $fp_source_id')
          ..write(')'))
        .toString();
  }
}

class $MaternalInfosTable extends MaternalInfos
    with TableInfo<$MaternalInfosTable, MaternalInfoData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MaternalInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _maternal_info_idMeta = const VerificationMeta(
    'maternal_info_id',
  );
  @override
  late final GeneratedColumn<int> maternal_info_id = GeneratedColumn<int>(
    'maternal_info_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _pregnantMeta = const VerificationMeta(
    'pregnant',
  );
  @override
  late final GeneratedColumn<bool> pregnant = GeneratedColumn<bool>(
    'pregnant',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("pregnant" IN (0, 1))',
    ),
  );
  static const VerificationMeta _lactatingMeta = const VerificationMeta(
    'lactating',
  );
  @override
  late final GeneratedColumn<bool> lactating = GeneratedColumn<bool>(
    'lactating',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("lactating" IN (0, 1))',
    ),
  );
  static const VerificationMeta _living_children_numMeta =
      const VerificationMeta('living_children_num');
  @override
  late final GeneratedColumn<int> living_children_num = GeneratedColumn<int>(
    'living_children_num',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fp_intentionMeta = const VerificationMeta(
    'fp_intention',
  );
  @override
  late final GeneratedColumn<bool> fp_intention = GeneratedColumn<bool>(
    'fp_intention',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("fp_intention" IN (0, 1))',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    maternal_info_id,
    person_id,
    pregnant,
    lactating,
    living_children_num,
    fp_intention,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'maternal_infos';
  @override
  VerificationContext validateIntegrity(
    Insertable<MaternalInfoData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('maternal_info_id')) {
      context.handle(
        _maternal_info_idMeta,
        maternal_info_id.isAcceptableOrUnknown(
          data['maternal_info_id']!,
          _maternal_info_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('pregnant')) {
      context.handle(
        _pregnantMeta,
        pregnant.isAcceptableOrUnknown(data['pregnant']!, _pregnantMeta),
      );
    }
    if (data.containsKey('lactating')) {
      context.handle(
        _lactatingMeta,
        lactating.isAcceptableOrUnknown(data['lactating']!, _lactatingMeta),
      );
    }
    if (data.containsKey('living_children_num')) {
      context.handle(
        _living_children_numMeta,
        living_children_num.isAcceptableOrUnknown(
          data['living_children_num']!,
          _living_children_numMeta,
        ),
      );
    }
    if (data.containsKey('fp_intention')) {
      context.handle(
        _fp_intentionMeta,
        fp_intention.isAcceptableOrUnknown(
          data['fp_intention']!,
          _fp_intentionMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {maternal_info_id};
  @override
  MaternalInfoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MaternalInfoData(
      maternal_info_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}maternal_info_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      pregnant: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}pregnant'],
      ),
      lactating: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}lactating'],
      ),
      living_children_num: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}living_children_num'],
      ),
      fp_intention: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}fp_intention'],
      ),
    );
  }

  @override
  $MaternalInfosTable createAlias(String alias) {
    return $MaternalInfosTable(attachedDatabase, alias);
  }
}

class MaternalInfoData extends DataClass
    implements Insertable<MaternalInfoData> {
  final int maternal_info_id;
  final int person_id;
  final bool? pregnant;
  final bool? lactating;
  final int? living_children_num;
  final bool? fp_intention;
  const MaternalInfoData({
    required this.maternal_info_id,
    required this.person_id,
    this.pregnant,
    this.lactating,
    this.living_children_num,
    this.fp_intention,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['maternal_info_id'] = Variable<int>(maternal_info_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || pregnant != null) {
      map['pregnant'] = Variable<bool>(pregnant);
    }
    if (!nullToAbsent || lactating != null) {
      map['lactating'] = Variable<bool>(lactating);
    }
    if (!nullToAbsent || living_children_num != null) {
      map['living_children_num'] = Variable<int>(living_children_num);
    }
    if (!nullToAbsent || fp_intention != null) {
      map['fp_intention'] = Variable<bool>(fp_intention);
    }
    return map;
  }

  MaternalInfosCompanion toCompanion(bool nullToAbsent) {
    return MaternalInfosCompanion(
      maternal_info_id: Value(maternal_info_id),
      person_id: Value(person_id),
      pregnant:
          pregnant == null && nullToAbsent
              ? const Value.absent()
              : Value(pregnant),
      lactating:
          lactating == null && nullToAbsent
              ? const Value.absent()
              : Value(lactating),
      living_children_num:
          living_children_num == null && nullToAbsent
              ? const Value.absent()
              : Value(living_children_num),
      fp_intention:
          fp_intention == null && nullToAbsent
              ? const Value.absent()
              : Value(fp_intention),
    );
  }

  factory MaternalInfoData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MaternalInfoData(
      maternal_info_id: serializer.fromJson<int>(json['maternal_info_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      pregnant: serializer.fromJson<bool?>(json['pregnant']),
      lactating: serializer.fromJson<bool?>(json['lactating']),
      living_children_num: serializer.fromJson<int?>(
        json['living_children_num'],
      ),
      fp_intention: serializer.fromJson<bool?>(json['fp_intention']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'maternal_info_id': serializer.toJson<int>(maternal_info_id),
      'person_id': serializer.toJson<int>(person_id),
      'pregnant': serializer.toJson<bool?>(pregnant),
      'lactating': serializer.toJson<bool?>(lactating),
      'living_children_num': serializer.toJson<int?>(living_children_num),
      'fp_intention': serializer.toJson<bool?>(fp_intention),
    };
  }

  MaternalInfoData copyWith({
    int? maternal_info_id,
    int? person_id,
    Value<bool?> pregnant = const Value.absent(),
    Value<bool?> lactating = const Value.absent(),
    Value<int?> living_children_num = const Value.absent(),
    Value<bool?> fp_intention = const Value.absent(),
  }) => MaternalInfoData(
    maternal_info_id: maternal_info_id ?? this.maternal_info_id,
    person_id: person_id ?? this.person_id,
    pregnant: pregnant.present ? pregnant.value : this.pregnant,
    lactating: lactating.present ? lactating.value : this.lactating,
    living_children_num:
        living_children_num.present
            ? living_children_num.value
            : this.living_children_num,
    fp_intention: fp_intention.present ? fp_intention.value : this.fp_intention,
  );
  MaternalInfoData copyWithCompanion(MaternalInfosCompanion data) {
    return MaternalInfoData(
      maternal_info_id:
          data.maternal_info_id.present
              ? data.maternal_info_id.value
              : this.maternal_info_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      pregnant: data.pregnant.present ? data.pregnant.value : this.pregnant,
      lactating: data.lactating.present ? data.lactating.value : this.lactating,
      living_children_num:
          data.living_children_num.present
              ? data.living_children_num.value
              : this.living_children_num,
      fp_intention:
          data.fp_intention.present
              ? data.fp_intention.value
              : this.fp_intention,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MaternalInfoData(')
          ..write('maternal_info_id: $maternal_info_id, ')
          ..write('person_id: $person_id, ')
          ..write('pregnant: $pregnant, ')
          ..write('lactating: $lactating, ')
          ..write('living_children_num: $living_children_num, ')
          ..write('fp_intention: $fp_intention')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    maternal_info_id,
    person_id,
    pregnant,
    lactating,
    living_children_num,
    fp_intention,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MaternalInfoData &&
          other.maternal_info_id == this.maternal_info_id &&
          other.person_id == this.person_id &&
          other.pregnant == this.pregnant &&
          other.lactating == this.lactating &&
          other.living_children_num == this.living_children_num &&
          other.fp_intention == this.fp_intention);
}

class MaternalInfosCompanion extends UpdateCompanion<MaternalInfoData> {
  final Value<int> maternal_info_id;
  final Value<int> person_id;
  final Value<bool?> pregnant;
  final Value<bool?> lactating;
  final Value<int?> living_children_num;
  final Value<bool?> fp_intention;
  const MaternalInfosCompanion({
    this.maternal_info_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.pregnant = const Value.absent(),
    this.lactating = const Value.absent(),
    this.living_children_num = const Value.absent(),
    this.fp_intention = const Value.absent(),
  });
  MaternalInfosCompanion.insert({
    this.maternal_info_id = const Value.absent(),
    required int person_id,
    this.pregnant = const Value.absent(),
    this.lactating = const Value.absent(),
    this.living_children_num = const Value.absent(),
    this.fp_intention = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<MaternalInfoData> custom({
    Expression<int>? maternal_info_id,
    Expression<int>? person_id,
    Expression<bool>? pregnant,
    Expression<bool>? lactating,
    Expression<int>? living_children_num,
    Expression<bool>? fp_intention,
  }) {
    return RawValuesInsertable({
      if (maternal_info_id != null) 'maternal_info_id': maternal_info_id,
      if (person_id != null) 'person_id': person_id,
      if (pregnant != null) 'pregnant': pregnant,
      if (lactating != null) 'lactating': lactating,
      if (living_children_num != null)
        'living_children_num': living_children_num,
      if (fp_intention != null) 'fp_intention': fp_intention,
    });
  }

  MaternalInfosCompanion copyWith({
    Value<int>? maternal_info_id,
    Value<int>? person_id,
    Value<bool?>? pregnant,
    Value<bool?>? lactating,
    Value<int?>? living_children_num,
    Value<bool?>? fp_intention,
  }) {
    return MaternalInfosCompanion(
      maternal_info_id: maternal_info_id ?? this.maternal_info_id,
      person_id: person_id ?? this.person_id,
      pregnant: pregnant ?? this.pregnant,
      lactating: lactating ?? this.lactating,
      living_children_num: living_children_num ?? this.living_children_num,
      fp_intention: fp_intention ?? this.fp_intention,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (maternal_info_id.present) {
      map['maternal_info_id'] = Variable<int>(maternal_info_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (pregnant.present) {
      map['pregnant'] = Variable<bool>(pregnant.value);
    }
    if (lactating.present) {
      map['lactating'] = Variable<bool>(lactating.value);
    }
    if (living_children_num.present) {
      map['living_children_num'] = Variable<int>(living_children_num.value);
    }
    if (fp_intention.present) {
      map['fp_intention'] = Variable<bool>(fp_intention.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MaternalInfosCompanion(')
          ..write('maternal_info_id: $maternal_info_id, ')
          ..write('person_id: $person_id, ')
          ..write('pregnant: $pregnant, ')
          ..write('lactating: $lactating, ')
          ..write('living_children_num: $living_children_num, ')
          ..write('fp_intention: $fp_intention')
          ..write(')'))
        .toString();
  }
}

class $VisitedFacilitiesTable extends VisitedFacilities
    with TableInfo<$VisitedFacilitiesTable, VisitedFacilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitedFacilitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _visited_facility_idMeta =
      const VerificationMeta('visited_facility_id');
  @override
  late final GeneratedColumn<int> visited_facility_id = GeneratedColumn<int>(
    'visited_facility_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _visit_reason_idMeta = const VerificationMeta(
    'visit_reason_id',
  );
  @override
  late final GeneratedColumn<int> visit_reason_id = GeneratedColumn<int>(
    'visit_reason_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES visit_reasons (visit_reason_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    visited_facility_id,
    person_id,
    name,
    date,
    visit_reason_id,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visited_facilities';
  @override
  VerificationContext validateIntegrity(
    Insertable<VisitedFacilityData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('visited_facility_id')) {
      context.handle(
        _visited_facility_idMeta,
        visited_facility_id.isAcceptableOrUnknown(
          data['visited_facility_id']!,
          _visited_facility_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    }
    if (data.containsKey('visit_reason_id')) {
      context.handle(
        _visit_reason_idMeta,
        visit_reason_id.isAcceptableOrUnknown(
          data['visit_reason_id']!,
          _visit_reason_idMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {visited_facility_id};
  @override
  VisitedFacilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitedFacilityData(
      visited_facility_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}visited_facility_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      ),
      visit_reason_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}visit_reason_id'],
      ),
    );
  }

  @override
  $VisitedFacilitiesTable createAlias(String alias) {
    return $VisitedFacilitiesTable(attachedDatabase, alias);
  }
}

class VisitedFacilityData extends DataClass
    implements Insertable<VisitedFacilityData> {
  final int visited_facility_id;
  final int person_id;
  final String name;
  final DateTime? date;
  final int? visit_reason_id;
  const VisitedFacilityData({
    required this.visited_facility_id,
    required this.person_id,
    required this.name,
    this.date,
    this.visit_reason_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['visited_facility_id'] = Variable<int>(visited_facility_id);
    map['person_id'] = Variable<int>(person_id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || date != null) {
      map['date'] = Variable<DateTime>(date);
    }
    if (!nullToAbsent || visit_reason_id != null) {
      map['visit_reason_id'] = Variable<int>(visit_reason_id);
    }
    return map;
  }

  VisitedFacilitiesCompanion toCompanion(bool nullToAbsent) {
    return VisitedFacilitiesCompanion(
      visited_facility_id: Value(visited_facility_id),
      person_id: Value(person_id),
      name: Value(name),
      date: date == null && nullToAbsent ? const Value.absent() : Value(date),
      visit_reason_id:
          visit_reason_id == null && nullToAbsent
              ? const Value.absent()
              : Value(visit_reason_id),
    );
  }

  factory VisitedFacilityData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitedFacilityData(
      visited_facility_id: serializer.fromJson<int>(
        json['visited_facility_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
      name: serializer.fromJson<String>(json['name']),
      date: serializer.fromJson<DateTime?>(json['date']),
      visit_reason_id: serializer.fromJson<int?>(json['visit_reason_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'visited_facility_id': serializer.toJson<int>(visited_facility_id),
      'person_id': serializer.toJson<int>(person_id),
      'name': serializer.toJson<String>(name),
      'date': serializer.toJson<DateTime?>(date),
      'visit_reason_id': serializer.toJson<int?>(visit_reason_id),
    };
  }

  VisitedFacilityData copyWith({
    int? visited_facility_id,
    int? person_id,
    String? name,
    Value<DateTime?> date = const Value.absent(),
    Value<int?> visit_reason_id = const Value.absent(),
  }) => VisitedFacilityData(
    visited_facility_id: visited_facility_id ?? this.visited_facility_id,
    person_id: person_id ?? this.person_id,
    name: name ?? this.name,
    date: date.present ? date.value : this.date,
    visit_reason_id:
        visit_reason_id.present ? visit_reason_id.value : this.visit_reason_id,
  );
  VisitedFacilityData copyWithCompanion(VisitedFacilitiesCompanion data) {
    return VisitedFacilityData(
      visited_facility_id:
          data.visited_facility_id.present
              ? data.visited_facility_id.value
              : this.visited_facility_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      name: data.name.present ? data.name.value : this.name,
      date: data.date.present ? data.date.value : this.date,
      visit_reason_id:
          data.visit_reason_id.present
              ? data.visit_reason_id.value
              : this.visit_reason_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VisitedFacilityData(')
          ..write('visited_facility_id: $visited_facility_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name, ')
          ..write('date: $date, ')
          ..write('visit_reason_id: $visit_reason_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(visited_facility_id, person_id, name, date, visit_reason_id);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitedFacilityData &&
          other.visited_facility_id == this.visited_facility_id &&
          other.person_id == this.person_id &&
          other.name == this.name &&
          other.date == this.date &&
          other.visit_reason_id == this.visit_reason_id);
}

class VisitedFacilitiesCompanion extends UpdateCompanion<VisitedFacilityData> {
  final Value<int> visited_facility_id;
  final Value<int> person_id;
  final Value<String> name;
  final Value<DateTime?> date;
  final Value<int?> visit_reason_id;
  const VisitedFacilitiesCompanion({
    this.visited_facility_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.name = const Value.absent(),
    this.date = const Value.absent(),
    this.visit_reason_id = const Value.absent(),
  });
  VisitedFacilitiesCompanion.insert({
    this.visited_facility_id = const Value.absent(),
    required int person_id,
    required String name,
    this.date = const Value.absent(),
    this.visit_reason_id = const Value.absent(),
  }) : person_id = Value(person_id),
       name = Value(name);
  static Insertable<VisitedFacilityData> custom({
    Expression<int>? visited_facility_id,
    Expression<int>? person_id,
    Expression<String>? name,
    Expression<DateTime>? date,
    Expression<int>? visit_reason_id,
  }) {
    return RawValuesInsertable({
      if (visited_facility_id != null)
        'visited_facility_id': visited_facility_id,
      if (person_id != null) 'person_id': person_id,
      if (name != null) 'name': name,
      if (date != null) 'date': date,
      if (visit_reason_id != null) 'visit_reason_id': visit_reason_id,
    });
  }

  VisitedFacilitiesCompanion copyWith({
    Value<int>? visited_facility_id,
    Value<int>? person_id,
    Value<String>? name,
    Value<DateTime?>? date,
    Value<int?>? visit_reason_id,
  }) {
    return VisitedFacilitiesCompanion(
      visited_facility_id: visited_facility_id ?? this.visited_facility_id,
      person_id: person_id ?? this.person_id,
      name: name ?? this.name,
      date: date ?? this.date,
      visit_reason_id: visit_reason_id ?? this.visit_reason_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (visited_facility_id.present) {
      map['visited_facility_id'] = Variable<int>(visited_facility_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (visit_reason_id.present) {
      map['visit_reason_id'] = Variable<int>(visit_reason_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitedFacilitiesCompanion(')
          ..write('visited_facility_id: $visited_facility_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name, ')
          ..write('date: $date, ')
          ..write('visit_reason_id: $visit_reason_id')
          ..write(')'))
        .toString();
  }
}

class $HealthInsurancesTable extends HealthInsurances
    with TableInfo<$HealthInsurancesTable, HealthInsuranceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HealthInsurancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _health_insurance_idMeta =
      const VerificationMeta('health_insurance_id');
  @override
  late final GeneratedColumn<int> health_insurance_id = GeneratedColumn<int>(
    'health_insurance_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [health_insurance_id, person_id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'health_insurances';
  @override
  VerificationContext validateIntegrity(
    Insertable<HealthInsuranceData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('health_insurance_id')) {
      context.handle(
        _health_insurance_idMeta,
        health_insurance_id.isAcceptableOrUnknown(
          data['health_insurance_id']!,
          _health_insurance_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {health_insurance_id};
  @override
  HealthInsuranceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HealthInsuranceData(
      health_insurance_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}health_insurance_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      name:
          attachedDatabase.typeMapping.read(
            DriftSqlType.string,
            data['${effectivePrefix}name'],
          )!,
    );
  }

  @override
  $HealthInsurancesTable createAlias(String alias) {
    return $HealthInsurancesTable(attachedDatabase, alias);
  }
}

class HealthInsuranceData extends DataClass
    implements Insertable<HealthInsuranceData> {
  final int health_insurance_id;
  final int person_id;
  final String name;
  const HealthInsuranceData({
    required this.health_insurance_id,
    required this.person_id,
    required this.name,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['health_insurance_id'] = Variable<int>(health_insurance_id);
    map['person_id'] = Variable<int>(person_id);
    map['name'] = Variable<String>(name);
    return map;
  }

  HealthInsurancesCompanion toCompanion(bool nullToAbsent) {
    return HealthInsurancesCompanion(
      health_insurance_id: Value(health_insurance_id),
      person_id: Value(person_id),
      name: Value(name),
    );
  }

  factory HealthInsuranceData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HealthInsuranceData(
      health_insurance_id: serializer.fromJson<int>(
        json['health_insurance_id'],
      ),
      person_id: serializer.fromJson<int>(json['person_id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'health_insurance_id': serializer.toJson<int>(health_insurance_id),
      'person_id': serializer.toJson<int>(person_id),
      'name': serializer.toJson<String>(name),
    };
  }

  HealthInsuranceData copyWith({
    int? health_insurance_id,
    int? person_id,
    String? name,
  }) => HealthInsuranceData(
    health_insurance_id: health_insurance_id ?? this.health_insurance_id,
    person_id: person_id ?? this.person_id,
    name: name ?? this.name,
  );
  HealthInsuranceData copyWithCompanion(HealthInsurancesCompanion data) {
    return HealthInsuranceData(
      health_insurance_id:
          data.health_insurance_id.present
              ? data.health_insurance_id.value
              : this.health_insurance_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('HealthInsuranceData(')
          ..write('health_insurance_id: $health_insurance_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(health_insurance_id, person_id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HealthInsuranceData &&
          other.health_insurance_id == this.health_insurance_id &&
          other.person_id == this.person_id &&
          other.name == this.name);
}

class HealthInsurancesCompanion extends UpdateCompanion<HealthInsuranceData> {
  final Value<int> health_insurance_id;
  final Value<int> person_id;
  final Value<String> name;
  const HealthInsurancesCompanion({
    this.health_insurance_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.name = const Value.absent(),
  });
  HealthInsurancesCompanion.insert({
    this.health_insurance_id = const Value.absent(),
    required int person_id,
    required String name,
  }) : person_id = Value(person_id),
       name = Value(name);
  static Insertable<HealthInsuranceData> custom({
    Expression<int>? health_insurance_id,
    Expression<int>? person_id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (health_insurance_id != null)
        'health_insurance_id': health_insurance_id,
      if (person_id != null) 'person_id': person_id,
      if (name != null) 'name': name,
    });
  }

  HealthInsurancesCompanion copyWith({
    Value<int>? health_insurance_id,
    Value<int>? person_id,
    Value<String>? name,
  }) {
    return HealthInsurancesCompanion(
      health_insurance_id: health_insurance_id ?? this.health_insurance_id,
      person_id: person_id ?? this.person_id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (health_insurance_id.present) {
      map['health_insurance_id'] = Variable<int>(health_insurance_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HealthInsurancesCompanion(')
          ..write('health_insurance_id: $health_insurance_id, ')
          ..write('person_id: $person_id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $NewbornInfosTable extends NewbornInfos
    with TableInfo<$NewbornInfosTable, NewbornInfoData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NewbornInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _newborn_info_idMeta = const VerificationMeta(
    'newborn_info_id',
  );
  @override
  late final GeneratedColumn<int> newborn_info_id = GeneratedColumn<int>(
    'newborn_info_id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _person_idMeta = const VerificationMeta(
    'person_id',
  );
  @override
  late final GeneratedColumn<int> person_id = GeneratedColumn<int>(
    'person_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES persons (person_id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _immunizationMeta = const VerificationMeta(
    'immunization',
  );
  @override
  late final GeneratedColumn<bool> immunization = GeneratedColumn<bool>(
    'immunization',
    aliasedName,
    true,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("immunization" IN (0, 1))',
    ),
  );
  static const VerificationMeta _delivery_place_idMeta = const VerificationMeta(
    'delivery_place_id',
  );
  @override
  late final GeneratedColumn<int> delivery_place_id = GeneratedColumn<int>(
    'delivery_place_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES delivery_places (delivery_place_id) ON DELETE NO ACTION',
    ),
  );
  static const VerificationMeta _assisted_person_idMeta =
      const VerificationMeta('assisted_person_id');
  @override
  late final GeneratedColumn<int> assisted_person_id = GeneratedColumn<int>(
    'assisted_person_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES assisted_persons (assisted_person_id) ON DELETE RESTRICT',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    newborn_info_id,
    person_id,
    immunization,
    delivery_place_id,
    assisted_person_id,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'newborn_infos';
  @override
  VerificationContext validateIntegrity(
    Insertable<NewbornInfoData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('newborn_info_id')) {
      context.handle(
        _newborn_info_idMeta,
        newborn_info_id.isAcceptableOrUnknown(
          data['newborn_info_id']!,
          _newborn_info_idMeta,
        ),
      );
    }
    if (data.containsKey('person_id')) {
      context.handle(
        _person_idMeta,
        person_id.isAcceptableOrUnknown(data['person_id']!, _person_idMeta),
      );
    } else if (isInserting) {
      context.missing(_person_idMeta);
    }
    if (data.containsKey('immunization')) {
      context.handle(
        _immunizationMeta,
        immunization.isAcceptableOrUnknown(
          data['immunization']!,
          _immunizationMeta,
        ),
      );
    }
    if (data.containsKey('delivery_place_id')) {
      context.handle(
        _delivery_place_idMeta,
        delivery_place_id.isAcceptableOrUnknown(
          data['delivery_place_id']!,
          _delivery_place_idMeta,
        ),
      );
    }
    if (data.containsKey('assisted_person_id')) {
      context.handle(
        _assisted_person_idMeta,
        assisted_person_id.isAcceptableOrUnknown(
          data['assisted_person_id']!,
          _assisted_person_idMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {newborn_info_id};
  @override
  NewbornInfoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NewbornInfoData(
      newborn_info_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}newborn_info_id'],
          )!,
      person_id:
          attachedDatabase.typeMapping.read(
            DriftSqlType.int,
            data['${effectivePrefix}person_id'],
          )!,
      immunization: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}immunization'],
      ),
      delivery_place_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}delivery_place_id'],
      ),
      assisted_person_id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}assisted_person_id'],
      ),
    );
  }

  @override
  $NewbornInfosTable createAlias(String alias) {
    return $NewbornInfosTable(attachedDatabase, alias);
  }
}

class NewbornInfoData extends DataClass implements Insertable<NewbornInfoData> {
  final int newborn_info_id;
  final int person_id;
  final bool? immunization;
  final int? delivery_place_id;
  final int? assisted_person_id;
  const NewbornInfoData({
    required this.newborn_info_id,
    required this.person_id,
    this.immunization,
    this.delivery_place_id,
    this.assisted_person_id,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['newborn_info_id'] = Variable<int>(newborn_info_id);
    map['person_id'] = Variable<int>(person_id);
    if (!nullToAbsent || immunization != null) {
      map['immunization'] = Variable<bool>(immunization);
    }
    if (!nullToAbsent || delivery_place_id != null) {
      map['delivery_place_id'] = Variable<int>(delivery_place_id);
    }
    if (!nullToAbsent || assisted_person_id != null) {
      map['assisted_person_id'] = Variable<int>(assisted_person_id);
    }
    return map;
  }

  NewbornInfosCompanion toCompanion(bool nullToAbsent) {
    return NewbornInfosCompanion(
      newborn_info_id: Value(newborn_info_id),
      person_id: Value(person_id),
      immunization:
          immunization == null && nullToAbsent
              ? const Value.absent()
              : Value(immunization),
      delivery_place_id:
          delivery_place_id == null && nullToAbsent
              ? const Value.absent()
              : Value(delivery_place_id),
      assisted_person_id:
          assisted_person_id == null && nullToAbsent
              ? const Value.absent()
              : Value(assisted_person_id),
    );
  }

  factory NewbornInfoData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NewbornInfoData(
      newborn_info_id: serializer.fromJson<int>(json['newborn_info_id']),
      person_id: serializer.fromJson<int>(json['person_id']),
      immunization: serializer.fromJson<bool?>(json['immunization']),
      delivery_place_id: serializer.fromJson<int?>(json['delivery_place_id']),
      assisted_person_id: serializer.fromJson<int?>(json['assisted_person_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'newborn_info_id': serializer.toJson<int>(newborn_info_id),
      'person_id': serializer.toJson<int>(person_id),
      'immunization': serializer.toJson<bool?>(immunization),
      'delivery_place_id': serializer.toJson<int?>(delivery_place_id),
      'assisted_person_id': serializer.toJson<int?>(assisted_person_id),
    };
  }

  NewbornInfoData copyWith({
    int? newborn_info_id,
    int? person_id,
    Value<bool?> immunization = const Value.absent(),
    Value<int?> delivery_place_id = const Value.absent(),
    Value<int?> assisted_person_id = const Value.absent(),
  }) => NewbornInfoData(
    newborn_info_id: newborn_info_id ?? this.newborn_info_id,
    person_id: person_id ?? this.person_id,
    immunization: immunization.present ? immunization.value : this.immunization,
    delivery_place_id:
        delivery_place_id.present
            ? delivery_place_id.value
            : this.delivery_place_id,
    assisted_person_id:
        assisted_person_id.present
            ? assisted_person_id.value
            : this.assisted_person_id,
  );
  NewbornInfoData copyWithCompanion(NewbornInfosCompanion data) {
    return NewbornInfoData(
      newborn_info_id:
          data.newborn_info_id.present
              ? data.newborn_info_id.value
              : this.newborn_info_id,
      person_id: data.person_id.present ? data.person_id.value : this.person_id,
      immunization:
          data.immunization.present
              ? data.immunization.value
              : this.immunization,
      delivery_place_id:
          data.delivery_place_id.present
              ? data.delivery_place_id.value
              : this.delivery_place_id,
      assisted_person_id:
          data.assisted_person_id.present
              ? data.assisted_person_id.value
              : this.assisted_person_id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('NewbornInfoData(')
          ..write('newborn_info_id: $newborn_info_id, ')
          ..write('person_id: $person_id, ')
          ..write('immunization: $immunization, ')
          ..write('delivery_place_id: $delivery_place_id, ')
          ..write('assisted_person_id: $assisted_person_id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    newborn_info_id,
    person_id,
    immunization,
    delivery_place_id,
    assisted_person_id,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NewbornInfoData &&
          other.newborn_info_id == this.newborn_info_id &&
          other.person_id == this.person_id &&
          other.immunization == this.immunization &&
          other.delivery_place_id == this.delivery_place_id &&
          other.assisted_person_id == this.assisted_person_id);
}

class NewbornInfosCompanion extends UpdateCompanion<NewbornInfoData> {
  final Value<int> newborn_info_id;
  final Value<int> person_id;
  final Value<bool?> immunization;
  final Value<int?> delivery_place_id;
  final Value<int?> assisted_person_id;
  const NewbornInfosCompanion({
    this.newborn_info_id = const Value.absent(),
    this.person_id = const Value.absent(),
    this.immunization = const Value.absent(),
    this.delivery_place_id = const Value.absent(),
    this.assisted_person_id = const Value.absent(),
  });
  NewbornInfosCompanion.insert({
    this.newborn_info_id = const Value.absent(),
    required int person_id,
    this.immunization = const Value.absent(),
    this.delivery_place_id = const Value.absent(),
    this.assisted_person_id = const Value.absent(),
  }) : person_id = Value(person_id);
  static Insertable<NewbornInfoData> custom({
    Expression<int>? newborn_info_id,
    Expression<int>? person_id,
    Expression<bool>? immunization,
    Expression<int>? delivery_place_id,
    Expression<int>? assisted_person_id,
  }) {
    return RawValuesInsertable({
      if (newborn_info_id != null) 'newborn_info_id': newborn_info_id,
      if (person_id != null) 'person_id': person_id,
      if (immunization != null) 'immunization': immunization,
      if (delivery_place_id != null) 'delivery_place_id': delivery_place_id,
      if (assisted_person_id != null) 'assisted_person_id': assisted_person_id,
    });
  }

  NewbornInfosCompanion copyWith({
    Value<int>? newborn_info_id,
    Value<int>? person_id,
    Value<bool?>? immunization,
    Value<int?>? delivery_place_id,
    Value<int?>? assisted_person_id,
  }) {
    return NewbornInfosCompanion(
      newborn_info_id: newborn_info_id ?? this.newborn_info_id,
      person_id: person_id ?? this.person_id,
      immunization: immunization ?? this.immunization,
      delivery_place_id: delivery_place_id ?? this.delivery_place_id,
      assisted_person_id: assisted_person_id ?? this.assisted_person_id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (newborn_info_id.present) {
      map['newborn_info_id'] = Variable<int>(newborn_info_id.value);
    }
    if (person_id.present) {
      map['person_id'] = Variable<int>(person_id.value);
    }
    if (immunization.present) {
      map['immunization'] = Variable<bool>(immunization.value);
    }
    if (delivery_place_id.present) {
      map['delivery_place_id'] = Variable<int>(delivery_place_id.value);
    }
    if (assisted_person_id.present) {
      map['assisted_person_id'] = Variable<int>(assisted_person_id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NewbornInfosCompanion(')
          ..write('newborn_info_id: $newborn_info_id, ')
          ..write('person_id: $person_id, ')
          ..write('immunization: $immunization, ')
          ..write('delivery_place_id: $delivery_place_id, ')
          ..write('assisted_person_id: $assisted_person_id')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $ReligionsTable religions = $ReligionsTable(this);
  late final $NationalitiesTable nationalities = $NationalitiesTable(this);
  late final $EthnicitiesTable ethnicities = $EthnicitiesTable(this);
  late final $BloodTypesTable bloodTypes = $BloodTypesTable(this);
  late final $AddressesTable addresses = $AddressesTable(this);
  late final $BuildingTypesTable buildingTypes = $BuildingTypesTable(this);
  late final $HouseholdsTable households = $HouseholdsTable(this);
  late final $MonthlyIncomesTable monthlyIncomes = $MonthlyIncomesTable(this);
  late final $DailyIncomesTable dailyIncomes = $DailyIncomesTable(this);
  late final $EducationTable education = $EducationTable(this);
  late final $PersonsTable persons = $PersonsTable(this);
  late final $OccupationsTable occupations = $OccupationsTable(this);
  late final $EmailsTable emails = $EmailsTable(this);
  late final $PhoneNumbersTable phoneNumbers = $PhoneNumbersTable(this);
  late final $GadgetsTable gadgets = $GadgetsTable(this);
  late final $GovermentProgramsTable govermentPrograms =
      $GovermentProgramsTable(this);
  late final $VoterRegistriesTable voterRegistries = $VoterRegistriesTable(
    this,
  );
  late final $RegisteredSeniorsTable registeredSeniors =
      $RegisteredSeniorsTable(this);
  late final $DisabilitiesTable disabilities = $DisabilitiesTable(this);
  late final $EnrolledTable enrolled = $EnrolledTable(this);
  late final $CTCRecordsTable cTCRecords = $CTCRecordsTable(this);
  late final $BrgyHistoriesTable brgyHistories = $BrgyHistoriesTable(this);
  late final $MigrantTransientsTable migrantTransients =
      $MigrantTransientsTable(this);
  late final $RelationshipTypesTable relationshipTypes =
      $RelationshipTypesTable(this);
  late final $HouseholdRelationshipsTable householdRelationships =
      $HouseholdRelationshipsTable(this);
  late final $ServicesTable services = $ServicesTable(this);
  late final $PrimaryNeedsTable primaryNeeds = $PrimaryNeedsTable(this);
  late final $FemaleMortalitiesTable femaleMortalities =
      $FemaleMortalitiesTable(this);
  late final $ChildMortalitiesTable childMortalities = $ChildMortalitiesTable(
    this,
  );
  late final $FutureResidenciesTable futureResidencies =
      $FutureResidenciesTable(this);
  late final $DeliveryPlacesTable deliveryPlaces = $DeliveryPlacesTable(this);
  late final $AssistedPersonsTable assistedPersons = $AssistedPersonsTable(
    this,
  );
  late final $VisitReasonsTable visitReasons = $VisitReasonsTable(this);
  late final $FpSourcesTable fpSources = $FpSourcesTable(this);
  late final $FpMethodsTable fpMethods = $FpMethodsTable(this);
  late final $FishingProductsTable fishingProducts = $FishingProductsTable(
    this,
  );
  late final $FishingTable fishing = $FishingTable(this);
  late final $AgriProductsTable agriProducts = $AgriProductsTable(this);
  late final $AgricultureTable agriculture = $AgricultureTable(this);
  late final $LivestockProductsTable livestockProducts =
      $LivestockProductsTable(this);
  late final $LivestockTable livestock = $LivestockTable(this);
  late final $QuestionsTable questions = $QuestionsTable(this);
  late final $QuestionChoicesTable questionChoices = $QuestionChoicesTable(
    this,
  );
  late final $HouseholdResponsesTable householdResponses =
      $HouseholdResponsesTable(this);
  late final $FamilyPlansTable familyPlans = $FamilyPlansTable(this);
  late final $MaternalInfosTable maternalInfos = $MaternalInfosTable(this);
  late final $VisitedFacilitiesTable visitedFacilities =
      $VisitedFacilitiesTable(this);
  late final $HealthInsurancesTable healthInsurances = $HealthInsurancesTable(
    this,
  );
  late final $NewbornInfosTable newbornInfos = $NewbornInfosTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    religions,
    nationalities,
    ethnicities,
    bloodTypes,
    addresses,
    buildingTypes,
    households,
    monthlyIncomes,
    dailyIncomes,
    education,
    persons,
    occupations,
    emails,
    phoneNumbers,
    gadgets,
    govermentPrograms,
    voterRegistries,
    registeredSeniors,
    disabilities,
    enrolled,
    cTCRecords,
    brgyHistories,
    migrantTransients,
    relationshipTypes,
    householdRelationships,
    services,
    primaryNeeds,
    femaleMortalities,
    childMortalities,
    futureResidencies,
    deliveryPlaces,
    assistedPersons,
    visitReasons,
    fpSources,
    fpMethods,
    fishingProducts,
    fishing,
    agriProducts,
    agriculture,
    livestockProducts,
    livestock,
    questions,
    questionChoices,
    householdResponses,
    familyPlans,
    maternalInfos,
    visitedFacilities,
    healthInsurances,
    newbornInfos,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('occupations', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('emails', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('phone_numbers', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('gadgets', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('goverment_programs', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('voter_registries', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('registered_seniors', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('disabilities', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('enrolled', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'education',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('enrolled', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('c_t_c_records', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('brgy_histories', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('migrant_transients', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('household_relationships', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('household_relationships', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('services', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('primary_needs', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('female_mortalities', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('child_mortalities', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'households',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('future_residencies', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('fishing', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('agriculture', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('livestock', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('family_plans', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('maternal_infos', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('visited_facilities', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('health_insurances', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'persons',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('newborn_infos', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$ReligionsTableCreateCompanionBuilder =
    ReligionsCompanion Function({Value<int> religion_id, required String name});
typedef $$ReligionsTableUpdateCompanionBuilder =
    ReligionsCompanion Function({Value<int> religion_id, Value<String> name});

final class $$ReligionsTableReferences
    extends BaseReferences<_$AppDatabase, $ReligionsTable, ReligionData> {
  $$ReligionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.religions.religion_id,
      db.persons.religion_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.religion_id.religion_id.sqlEquals(
        $_itemColumn<int>('religion_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ReligionsTableFilterComposer
    extends Composer<_$AppDatabase, $ReligionsTable> {
  $$ReligionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get religion_id => $composableBuilder(
    column: $table.religion_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.religion_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.religion_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ReligionsTableOrderingComposer
    extends Composer<_$AppDatabase, $ReligionsTable> {
  $$ReligionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get religion_id => $composableBuilder(
    column: $table.religion_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ReligionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReligionsTable> {
  $$ReligionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get religion_id => $composableBuilder(
    column: $table.religion_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.religion_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.religion_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ReligionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ReligionsTable,
          ReligionData,
          $$ReligionsTableFilterComposer,
          $$ReligionsTableOrderingComposer,
          $$ReligionsTableAnnotationComposer,
          $$ReligionsTableCreateCompanionBuilder,
          $$ReligionsTableUpdateCompanionBuilder,
          (ReligionData, $$ReligionsTableReferences),
          ReligionData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$ReligionsTableTableManager(_$AppDatabase db, $ReligionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$ReligionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$ReligionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$ReligionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> religion_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => ReligionsCompanion(religion_id: religion_id, name: name),
          createCompanionCallback:
              ({
                Value<int> religion_id = const Value.absent(),
                required String name,
              }) => ReligionsCompanion.insert(
                religion_id: religion_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$ReligionsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      ReligionData,
                      $ReligionsTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$ReligionsTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$ReligionsTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.religion_id == item.religion_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ReligionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ReligionsTable,
      ReligionData,
      $$ReligionsTableFilterComposer,
      $$ReligionsTableOrderingComposer,
      $$ReligionsTableAnnotationComposer,
      $$ReligionsTableCreateCompanionBuilder,
      $$ReligionsTableUpdateCompanionBuilder,
      (ReligionData, $$ReligionsTableReferences),
      ReligionData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$NationalitiesTableCreateCompanionBuilder =
    NationalitiesCompanion Function({
      Value<int> nationality_id,
      required String name,
    });
typedef $$NationalitiesTableUpdateCompanionBuilder =
    NationalitiesCompanion Function({
      Value<int> nationality_id,
      Value<String> name,
    });

final class $$NationalitiesTableReferences
    extends
        BaseReferences<_$AppDatabase, $NationalitiesTable, NationalityData> {
  $$NationalitiesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.nationalities.nationality_id,
      db.persons.nationality_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.nationality_id.nationality_id.sqlEquals(
        $_itemColumn<int>('nationality_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$NationalitiesTableFilterComposer
    extends Composer<_$AppDatabase, $NationalitiesTable> {
  $$NationalitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get nationality_id => $composableBuilder(
    column: $table.nationality_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.nationality_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.nationality_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$NationalitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $NationalitiesTable> {
  $$NationalitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get nationality_id => $composableBuilder(
    column: $table.nationality_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$NationalitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $NationalitiesTable> {
  $$NationalitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get nationality_id => $composableBuilder(
    column: $table.nationality_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.nationality_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.nationality_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$NationalitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $NationalitiesTable,
          NationalityData,
          $$NationalitiesTableFilterComposer,
          $$NationalitiesTableOrderingComposer,
          $$NationalitiesTableAnnotationComposer,
          $$NationalitiesTableCreateCompanionBuilder,
          $$NationalitiesTableUpdateCompanionBuilder,
          (NationalityData, $$NationalitiesTableReferences),
          NationalityData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$NationalitiesTableTableManager(_$AppDatabase db, $NationalitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$NationalitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$NationalitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$NationalitiesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> nationality_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => NationalitiesCompanion(
                nationality_id: nationality_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> nationality_id = const Value.absent(),
                required String name,
              }) => NationalitiesCompanion.insert(
                nationality_id: nationality_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$NationalitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      NationalityData,
                      $NationalitiesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$NationalitiesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$NationalitiesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.nationality_id == item.nationality_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$NationalitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $NationalitiesTable,
      NationalityData,
      $$NationalitiesTableFilterComposer,
      $$NationalitiesTableOrderingComposer,
      $$NationalitiesTableAnnotationComposer,
      $$NationalitiesTableCreateCompanionBuilder,
      $$NationalitiesTableUpdateCompanionBuilder,
      (NationalityData, $$NationalitiesTableReferences),
      NationalityData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$EthnicitiesTableCreateCompanionBuilder =
    EthnicitiesCompanion Function({
      Value<int> ethnicity_id,
      required String name,
    });
typedef $$EthnicitiesTableUpdateCompanionBuilder =
    EthnicitiesCompanion Function({
      Value<int> ethnicity_id,
      Value<String> name,
    });

final class $$EthnicitiesTableReferences
    extends BaseReferences<_$AppDatabase, $EthnicitiesTable, EthnicityData> {
  $$EthnicitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.ethnicities.ethnicity_id,
      db.persons.ethnicity_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.ethnicity_id.ethnicity_id.sqlEquals(
        $_itemColumn<int>('ethnicity_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$EthnicitiesTableFilterComposer
    extends Composer<_$AppDatabase, $EthnicitiesTable> {
  $$EthnicitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get ethnicity_id => $composableBuilder(
    column: $table.ethnicity_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ethnicity_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.ethnicity_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EthnicitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $EthnicitiesTable> {
  $$EthnicitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get ethnicity_id => $composableBuilder(
    column: $table.ethnicity_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$EthnicitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $EthnicitiesTable> {
  $$EthnicitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get ethnicity_id => $composableBuilder(
    column: $table.ethnicity_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ethnicity_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.ethnicity_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EthnicitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EthnicitiesTable,
          EthnicityData,
          $$EthnicitiesTableFilterComposer,
          $$EthnicitiesTableOrderingComposer,
          $$EthnicitiesTableAnnotationComposer,
          $$EthnicitiesTableCreateCompanionBuilder,
          $$EthnicitiesTableUpdateCompanionBuilder,
          (EthnicityData, $$EthnicitiesTableReferences),
          EthnicityData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$EthnicitiesTableTableManager(_$AppDatabase db, $EthnicitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$EthnicitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$EthnicitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$EthnicitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> ethnicity_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) =>
                  EthnicitiesCompanion(ethnicity_id: ethnicity_id, name: name),
          createCompanionCallback:
              ({
                Value<int> ethnicity_id = const Value.absent(),
                required String name,
              }) => EthnicitiesCompanion.insert(
                ethnicity_id: ethnicity_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$EthnicitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      EthnicityData,
                      $EthnicitiesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$EthnicitiesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$EthnicitiesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.ethnicity_id == item.ethnicity_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$EthnicitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EthnicitiesTable,
      EthnicityData,
      $$EthnicitiesTableFilterComposer,
      $$EthnicitiesTableOrderingComposer,
      $$EthnicitiesTableAnnotationComposer,
      $$EthnicitiesTableCreateCompanionBuilder,
      $$EthnicitiesTableUpdateCompanionBuilder,
      (EthnicityData, $$EthnicitiesTableReferences),
      EthnicityData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$BloodTypesTableCreateCompanionBuilder =
    BloodTypesCompanion Function({
      Value<int> blood_type_id,
      required String type,
    });
typedef $$BloodTypesTableUpdateCompanionBuilder =
    BloodTypesCompanion Function({
      Value<int> blood_type_id,
      Value<String> type,
    });

final class $$BloodTypesTableReferences
    extends BaseReferences<_$AppDatabase, $BloodTypesTable, BloodTypeData> {
  $$BloodTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.bloodTypes.blood_type_id,
      db.persons.blood_type_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.blood_type_id.blood_type_id.sqlEquals(
        $_itemColumn<int>('blood_type_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BloodTypesTableFilterComposer
    extends Composer<_$AppDatabase, $BloodTypesTable> {
  $$BloodTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get blood_type_id => $composableBuilder(
    column: $table.blood_type_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.blood_type_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.blood_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BloodTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $BloodTypesTable> {
  $$BloodTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get blood_type_id => $composableBuilder(
    column: $table.blood_type_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BloodTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $BloodTypesTable> {
  $$BloodTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get blood_type_id => $composableBuilder(
    column: $table.blood_type_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.blood_type_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.blood_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BloodTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BloodTypesTable,
          BloodTypeData,
          $$BloodTypesTableFilterComposer,
          $$BloodTypesTableOrderingComposer,
          $$BloodTypesTableAnnotationComposer,
          $$BloodTypesTableCreateCompanionBuilder,
          $$BloodTypesTableUpdateCompanionBuilder,
          (BloodTypeData, $$BloodTypesTableReferences),
          BloodTypeData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$BloodTypesTableTableManager(_$AppDatabase db, $BloodTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$BloodTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$BloodTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$BloodTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> blood_type_id = const Value.absent(),
                Value<String> type = const Value.absent(),
              }) =>
                  BloodTypesCompanion(blood_type_id: blood_type_id, type: type),
          createCompanionCallback:
              ({
                Value<int> blood_type_id = const Value.absent(),
                required String type,
              }) => BloodTypesCompanion.insert(
                blood_type_id: blood_type_id,
                type: type,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$BloodTypesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      BloodTypeData,
                      $BloodTypesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$BloodTypesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$BloodTypesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.blood_type_id == item.blood_type_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$BloodTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BloodTypesTable,
      BloodTypeData,
      $$BloodTypesTableFilterComposer,
      $$BloodTypesTableOrderingComposer,
      $$BloodTypesTableAnnotationComposer,
      $$BloodTypesTableCreateCompanionBuilder,
      $$BloodTypesTableUpdateCompanionBuilder,
      (BloodTypeData, $$BloodTypesTableReferences),
      BloodTypeData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$AddressesTableCreateCompanionBuilder =
    AddressesCompanion Function({
      Value<int> address_id,
      Value<String?> zone,
      Value<String?> street,
      Value<String?> block,
      Value<String?> lot,
    });
typedef $$AddressesTableUpdateCompanionBuilder =
    AddressesCompanion Function({
      Value<int> address_id,
      Value<String?> zone,
      Value<String?> street,
      Value<String?> block,
      Value<String?> lot,
    });

final class $$AddressesTableReferences
    extends BaseReferences<_$AppDatabase, $AddressesTable, AddressData> {
  $$AddressesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$HouseholdsTable, List<HouseholdData>>
  _householdsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.households,
    aliasName: $_aliasNameGenerator(
      db.addresses.address_id,
      db.households.address_id,
    ),
  );

  $$HouseholdsTableProcessedTableManager get householdsRefs {
    final manager = $$HouseholdsTableTableManager($_db, $_db.households).filter(
      (f) =>
          f.address_id.address_id.sqlEquals($_itemColumn<int>('address_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_householdsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.addresses.address_id,
      db.persons.address_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) =>
          f.address_id.address_id.sqlEquals($_itemColumn<int>('address_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$AddressesTableFilterComposer
    extends Composer<_$AppDatabase, $AddressesTable> {
  $$AddressesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get address_id => $composableBuilder(
    column: $table.address_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get zone => $composableBuilder(
    column: $table.zone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get street => $composableBuilder(
    column: $table.street,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get block => $composableBuilder(
    column: $table.block,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lot => $composableBuilder(
    column: $table.lot,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> householdsRefs(
    Expression<bool> Function($$HouseholdsTableFilterComposer f) f,
  ) {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AddressesTableOrderingComposer
    extends Composer<_$AppDatabase, $AddressesTable> {
  $$AddressesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get address_id => $composableBuilder(
    column: $table.address_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get zone => $composableBuilder(
    column: $table.zone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get street => $composableBuilder(
    column: $table.street,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get block => $composableBuilder(
    column: $table.block,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lot => $composableBuilder(
    column: $table.lot,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AddressesTableAnnotationComposer
    extends Composer<_$AppDatabase, $AddressesTable> {
  $$AddressesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get address_id => $composableBuilder(
    column: $table.address_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get zone =>
      $composableBuilder(column: $table.zone, builder: (column) => column);

  GeneratedColumn<String> get street =>
      $composableBuilder(column: $table.street, builder: (column) => column);

  GeneratedColumn<String> get block =>
      $composableBuilder(column: $table.block, builder: (column) => column);

  GeneratedColumn<String> get lot =>
      $composableBuilder(column: $table.lot, builder: (column) => column);

  Expression<T> householdsRefs<T extends Object>(
    Expression<T> Function($$HouseholdsTableAnnotationComposer a) f,
  ) {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AddressesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AddressesTable,
          AddressData,
          $$AddressesTableFilterComposer,
          $$AddressesTableOrderingComposer,
          $$AddressesTableAnnotationComposer,
          $$AddressesTableCreateCompanionBuilder,
          $$AddressesTableUpdateCompanionBuilder,
          (AddressData, $$AddressesTableReferences),
          AddressData,
          PrefetchHooks Function({bool householdsRefs, bool personsRefs})
        > {
  $$AddressesTableTableManager(_$AppDatabase db, $AddressesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$AddressesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$AddressesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$AddressesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> address_id = const Value.absent(),
                Value<String?> zone = const Value.absent(),
                Value<String?> street = const Value.absent(),
                Value<String?> block = const Value.absent(),
                Value<String?> lot = const Value.absent(),
              }) => AddressesCompanion(
                address_id: address_id,
                zone: zone,
                street: street,
                block: block,
                lot: lot,
              ),
          createCompanionCallback:
              ({
                Value<int> address_id = const Value.absent(),
                Value<String?> zone = const Value.absent(),
                Value<String?> street = const Value.absent(),
                Value<String?> block = const Value.absent(),
                Value<String?> lot = const Value.absent(),
              }) => AddressesCompanion.insert(
                address_id: address_id,
                zone: zone,
                street: street,
                block: block,
                lot: lot,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$AddressesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            householdsRefs = false,
            personsRefs = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (householdsRefs) db.households,
                if (personsRefs) db.persons,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (householdsRefs)
                    await $_getPrefetchedData<
                      AddressData,
                      $AddressesTable,
                      HouseholdData
                    >(
                      currentTable: table,
                      referencedTable: $$AddressesTableReferences
                          ._householdsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$AddressesTableReferences(
                                db,
                                table,
                                p0,
                              ).householdsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.address_id == item.address_id,
                          ),
                      typedResults: items,
                    ),
                  if (personsRefs)
                    await $_getPrefetchedData<
                      AddressData,
                      $AddressesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$AddressesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$AddressesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.address_id == item.address_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$AddressesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AddressesTable,
      AddressData,
      $$AddressesTableFilterComposer,
      $$AddressesTableOrderingComposer,
      $$AddressesTableAnnotationComposer,
      $$AddressesTableCreateCompanionBuilder,
      $$AddressesTableUpdateCompanionBuilder,
      (AddressData, $$AddressesTableReferences),
      AddressData,
      PrefetchHooks Function({bool householdsRefs, bool personsRefs})
    >;
typedef $$BuildingTypesTableCreateCompanionBuilder =
    BuildingTypesCompanion Function({
      Value<int> building_type_id,
      required String type,
    });
typedef $$BuildingTypesTableUpdateCompanionBuilder =
    BuildingTypesCompanion Function({
      Value<int> building_type_id,
      Value<String> type,
    });

final class $$BuildingTypesTableReferences
    extends
        BaseReferences<_$AppDatabase, $BuildingTypesTable, BuildingTypeData> {
  $$BuildingTypesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$HouseholdsTable, List<HouseholdData>>
  _householdsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.households,
    aliasName: $_aliasNameGenerator(
      db.buildingTypes.building_type_id,
      db.households.building_type_id,
    ),
  );

  $$HouseholdsTableProcessedTableManager get householdsRefs {
    final manager = $$HouseholdsTableTableManager($_db, $_db.households).filter(
      (f) => f.building_type_id.building_type_id.sqlEquals(
        $_itemColumn<int>('building_type_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_householdsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BuildingTypesTableFilterComposer
    extends Composer<_$AppDatabase, $BuildingTypesTable> {
  $$BuildingTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get building_type_id => $composableBuilder(
    column: $table.building_type_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> householdsRefs(
    Expression<bool> Function($$HouseholdsTableFilterComposer f) f,
  ) {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.building_type_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.building_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BuildingTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $BuildingTypesTable> {
  $$BuildingTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get building_type_id => $composableBuilder(
    column: $table.building_type_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BuildingTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $BuildingTypesTable> {
  $$BuildingTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get building_type_id => $composableBuilder(
    column: $table.building_type_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  Expression<T> householdsRefs<T extends Object>(
    Expression<T> Function($$HouseholdsTableAnnotationComposer a) f,
  ) {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.building_type_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.building_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BuildingTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BuildingTypesTable,
          BuildingTypeData,
          $$BuildingTypesTableFilterComposer,
          $$BuildingTypesTableOrderingComposer,
          $$BuildingTypesTableAnnotationComposer,
          $$BuildingTypesTableCreateCompanionBuilder,
          $$BuildingTypesTableUpdateCompanionBuilder,
          (BuildingTypeData, $$BuildingTypesTableReferences),
          BuildingTypeData,
          PrefetchHooks Function({bool householdsRefs})
        > {
  $$BuildingTypesTableTableManager(_$AppDatabase db, $BuildingTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$BuildingTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$BuildingTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$BuildingTypesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> building_type_id = const Value.absent(),
                Value<String> type = const Value.absent(),
              }) => BuildingTypesCompanion(
                building_type_id: building_type_id,
                type: type,
              ),
          createCompanionCallback:
              ({
                Value<int> building_type_id = const Value.absent(),
                required String type,
              }) => BuildingTypesCompanion.insert(
                building_type_id: building_type_id,
                type: type,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$BuildingTypesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({householdsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (householdsRefs) db.households],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (householdsRefs)
                    await $_getPrefetchedData<
                      BuildingTypeData,
                      $BuildingTypesTable,
                      HouseholdData
                    >(
                      currentTable: table,
                      referencedTable: $$BuildingTypesTableReferences
                          ._householdsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$BuildingTypesTableReferences(
                                db,
                                table,
                                p0,
                              ).householdsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.building_type_id == item.building_type_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$BuildingTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BuildingTypesTable,
      BuildingTypeData,
      $$BuildingTypesTableFilterComposer,
      $$BuildingTypesTableOrderingComposer,
      $$BuildingTypesTableAnnotationComposer,
      $$BuildingTypesTableCreateCompanionBuilder,
      $$BuildingTypesTableUpdateCompanionBuilder,
      (BuildingTypeData, $$BuildingTypesTableReferences),
      BuildingTypeData,
      PrefetchHooks Function({bool householdsRefs})
    >;
typedef $$HouseholdsTableCreateCompanionBuilder =
    HouseholdsCompanion Function({
      Value<int> household_id,
      Value<String?> head,
      Value<int?> address_id,
      Value<HouseholdTypes?> household_type_id,
      Value<int?> building_type_id,
      Value<OwnershipTypes?> ownership_type_id,
      Value<int?> household_members_num,
      Value<bool?> female_mortality,
      Value<bool?> child_mortality,
      Value<DateTime?> registration_date,
      required RegistrationStatus registration_status,
    });
typedef $$HouseholdsTableUpdateCompanionBuilder =
    HouseholdsCompanion Function({
      Value<int> household_id,
      Value<String?> head,
      Value<int?> address_id,
      Value<HouseholdTypes?> household_type_id,
      Value<int?> building_type_id,
      Value<OwnershipTypes?> ownership_type_id,
      Value<int?> household_members_num,
      Value<bool?> female_mortality,
      Value<bool?> child_mortality,
      Value<DateTime?> registration_date,
      Value<RegistrationStatus> registration_status,
    });

final class $$HouseholdsTableReferences
    extends BaseReferences<_$AppDatabase, $HouseholdsTable, HouseholdData> {
  $$HouseholdsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $AddressesTable _address_idTable(_$AppDatabase db) =>
      db.addresses.createAlias(
        $_aliasNameGenerator(db.households.address_id, db.addresses.address_id),
      );

  $$AddressesTableProcessedTableManager? get address_id {
    final $_column = $_itemColumn<int>('address_id');
    if ($_column == null) return null;
    final manager = $$AddressesTableTableManager(
      $_db,
      $_db.addresses,
    ).filter((f) => f.address_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_address_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BuildingTypesTable _building_type_idTable(_$AppDatabase db) =>
      db.buildingTypes.createAlias(
        $_aliasNameGenerator(
          db.households.building_type_id,
          db.buildingTypes.building_type_id,
        ),
      );

  $$BuildingTypesTableProcessedTableManager? get building_type_id {
    final $_column = $_itemColumn<int>('building_type_id');
    if ($_column == null) return null;
    final manager = $$BuildingTypesTableTableManager(
      $_db,
      $_db.buildingTypes,
    ).filter((f) => f.building_type_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_building_type_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.households.household_id,
      db.persons.household_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $HouseholdRelationshipsTable,
    List<HouseholdRelationship>
  >
  _householdRelationshipsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.householdRelationships,
        aliasName: $_aliasNameGenerator(
          db.households.household_id,
          db.householdRelationships.household_id,
        ),
      );

  $$HouseholdRelationshipsTableProcessedTableManager
  get householdRelationshipsRefs {
    final manager = $$HouseholdRelationshipsTableTableManager(
      $_db,
      $_db.householdRelationships,
    ).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _householdRelationshipsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ServicesTable, List<ServiceData>>
  _servicesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.services,
    aliasName: $_aliasNameGenerator(
      db.households.household_id,
      db.services.household_id,
    ),
  );

  $$ServicesTableProcessedTableManager get servicesRefs {
    final manager = $$ServicesTableTableManager($_db, $_db.services).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_servicesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PrimaryNeedsTable, List<PrimaryNeedData>>
  _primaryNeedsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.primaryNeeds,
    aliasName: $_aliasNameGenerator(
      db.households.household_id,
      db.primaryNeeds.household_id,
    ),
  );

  $$PrimaryNeedsTableProcessedTableManager get primaryNeedsRefs {
    final manager = $$PrimaryNeedsTableTableManager(
      $_db,
      $_db.primaryNeeds,
    ).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_primaryNeedsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FemaleMortalitiesTable, List<FemaleMortalityData>>
  _femaleMortalitiesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.femaleMortalities,
        aliasName: $_aliasNameGenerator(
          db.households.household_id,
          db.femaleMortalities.household_id,
        ),
      );

  $$FemaleMortalitiesTableProcessedTableManager get femaleMortalitiesRefs {
    final manager = $$FemaleMortalitiesTableTableManager(
      $_db,
      $_db.femaleMortalities,
    ).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _femaleMortalitiesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ChildMortalitiesTable, List<ChildMortalityData>>
  _childMortalitiesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.childMortalities,
    aliasName: $_aliasNameGenerator(
      db.households.household_id,
      db.childMortalities.household_id,
    ),
  );

  $$ChildMortalitiesTableProcessedTableManager get childMortalitiesRefs {
    final manager = $$ChildMortalitiesTableTableManager(
      $_db,
      $_db.childMortalities,
    ).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _childMortalitiesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FutureResidenciesTable, List<FutureResidency>>
  _futureResidenciesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.futureResidencies,
        aliasName: $_aliasNameGenerator(
          db.households.household_id,
          db.futureResidencies.household_id,
        ),
      );

  $$FutureResidenciesTableProcessedTableManager get futureResidenciesRefs {
    final manager = $$FutureResidenciesTableTableManager(
      $_db,
      $_db.futureResidencies,
    ).filter(
      (f) => f.household_id.household_id.sqlEquals(
        $_itemColumn<int>('household_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _futureResidenciesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$HouseholdsTableFilterComposer
    extends Composer<_$AppDatabase, $HouseholdsTable> {
  $$HouseholdsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get household_id => $composableBuilder(
    column: $table.household_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get head => $composableBuilder(
    column: $table.head,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<HouseholdTypes?, HouseholdTypes, String>
  get household_type_id => $composableBuilder(
    column: $table.household_type_id,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnWithTypeConverterFilters<OwnershipTypes?, OwnershipTypes, String>
  get ownership_type_id => $composableBuilder(
    column: $table.ownership_type_id,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<int> get household_members_num => $composableBuilder(
    column: $table.household_members_num,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get female_mortality => $composableBuilder(
    column: $table.female_mortality,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get child_mortality => $composableBuilder(
    column: $table.child_mortality,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<RegistrationStatus, RegistrationStatus, String>
  get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  $$AddressesTableFilterComposer get address_id {
    final $$AddressesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableFilterComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BuildingTypesTableFilterComposer get building_type_id {
    final $$BuildingTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.building_type_id,
      referencedTable: $db.buildingTypes,
      getReferencedColumn: (t) => t.building_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BuildingTypesTableFilterComposer(
            $db: $db,
            $table: $db.buildingTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> householdRelationshipsRefs(
    Expression<bool> Function($$HouseholdRelationshipsTableFilterComposer f) f,
  ) {
    final $$HouseholdRelationshipsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.household_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.household_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableFilterComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> servicesRefs(
    Expression<bool> Function($$ServicesTableFilterComposer f) f,
  ) {
    final $$ServicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.services,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ServicesTableFilterComposer(
            $db: $db,
            $table: $db.services,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> primaryNeedsRefs(
    Expression<bool> Function($$PrimaryNeedsTableFilterComposer f) f,
  ) {
    final $$PrimaryNeedsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.primaryNeeds,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PrimaryNeedsTableFilterComposer(
            $db: $db,
            $table: $db.primaryNeeds,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> femaleMortalitiesRefs(
    Expression<bool> Function($$FemaleMortalitiesTableFilterComposer f) f,
  ) {
    final $$FemaleMortalitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.femaleMortalities,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FemaleMortalitiesTableFilterComposer(
            $db: $db,
            $table: $db.femaleMortalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> childMortalitiesRefs(
    Expression<bool> Function($$ChildMortalitiesTableFilterComposer f) f,
  ) {
    final $$ChildMortalitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.childMortalities,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChildMortalitiesTableFilterComposer(
            $db: $db,
            $table: $db.childMortalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> futureResidenciesRefs(
    Expression<bool> Function($$FutureResidenciesTableFilterComposer f) f,
  ) {
    final $$FutureResidenciesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.futureResidencies,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FutureResidenciesTableFilterComposer(
            $db: $db,
            $table: $db.futureResidencies,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$HouseholdsTableOrderingComposer
    extends Composer<_$AppDatabase, $HouseholdsTable> {
  $$HouseholdsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get household_id => $composableBuilder(
    column: $table.household_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get head => $composableBuilder(
    column: $table.head,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get household_type_id => $composableBuilder(
    column: $table.household_type_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownership_type_id => $composableBuilder(
    column: $table.ownership_type_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get household_members_num => $composableBuilder(
    column: $table.household_members_num,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get female_mortality => $composableBuilder(
    column: $table.female_mortality,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get child_mortality => $composableBuilder(
    column: $table.child_mortality,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => ColumnOrderings(column),
  );

  $$AddressesTableOrderingComposer get address_id {
    final $$AddressesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableOrderingComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BuildingTypesTableOrderingComposer get building_type_id {
    final $$BuildingTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.building_type_id,
      referencedTable: $db.buildingTypes,
      getReferencedColumn: (t) => t.building_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BuildingTypesTableOrderingComposer(
            $db: $db,
            $table: $db.buildingTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdsTableAnnotationComposer
    extends Composer<_$AppDatabase, $HouseholdsTable> {
  $$HouseholdsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get household_id => $composableBuilder(
    column: $table.household_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get head =>
      $composableBuilder(column: $table.head, builder: (column) => column);

  GeneratedColumnWithTypeConverter<HouseholdTypes?, String>
  get household_type_id => $composableBuilder(
    column: $table.household_type_id,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<OwnershipTypes?, String>
  get ownership_type_id => $composableBuilder(
    column: $table.ownership_type_id,
    builder: (column) => column,
  );

  GeneratedColumn<int> get household_members_num => $composableBuilder(
    column: $table.household_members_num,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get female_mortality => $composableBuilder(
    column: $table.female_mortality,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get child_mortality => $composableBuilder(
    column: $table.child_mortality,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<RegistrationStatus, String>
  get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => column,
  );

  $$AddressesTableAnnotationComposer get address_id {
    final $$AddressesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableAnnotationComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BuildingTypesTableAnnotationComposer get building_type_id {
    final $$BuildingTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.building_type_id,
      referencedTable: $db.buildingTypes,
      getReferencedColumn: (t) => t.building_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BuildingTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.buildingTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> householdRelationshipsRefs<T extends Object>(
    Expression<T> Function($$HouseholdRelationshipsTableAnnotationComposer a) f,
  ) {
    final $$HouseholdRelationshipsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.household_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.household_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableAnnotationComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> servicesRefs<T extends Object>(
    Expression<T> Function($$ServicesTableAnnotationComposer a) f,
  ) {
    final $$ServicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.services,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ServicesTableAnnotationComposer(
            $db: $db,
            $table: $db.services,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> primaryNeedsRefs<T extends Object>(
    Expression<T> Function($$PrimaryNeedsTableAnnotationComposer a) f,
  ) {
    final $$PrimaryNeedsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.primaryNeeds,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PrimaryNeedsTableAnnotationComposer(
            $db: $db,
            $table: $db.primaryNeeds,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> femaleMortalitiesRefs<T extends Object>(
    Expression<T> Function($$FemaleMortalitiesTableAnnotationComposer a) f,
  ) {
    final $$FemaleMortalitiesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.household_id,
          referencedTable: $db.femaleMortalities,
          getReferencedColumn: (t) => t.household_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FemaleMortalitiesTableAnnotationComposer(
                $db: $db,
                $table: $db.femaleMortalities,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> childMortalitiesRefs<T extends Object>(
    Expression<T> Function($$ChildMortalitiesTableAnnotationComposer a) f,
  ) {
    final $$ChildMortalitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.childMortalities,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ChildMortalitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.childMortalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> futureResidenciesRefs<T extends Object>(
    Expression<T> Function($$FutureResidenciesTableAnnotationComposer a) f,
  ) {
    final $$FutureResidenciesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.household_id,
          referencedTable: $db.futureResidencies,
          getReferencedColumn: (t) => t.household_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$FutureResidenciesTableAnnotationComposer(
                $db: $db,
                $table: $db.futureResidencies,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$HouseholdsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HouseholdsTable,
          HouseholdData,
          $$HouseholdsTableFilterComposer,
          $$HouseholdsTableOrderingComposer,
          $$HouseholdsTableAnnotationComposer,
          $$HouseholdsTableCreateCompanionBuilder,
          $$HouseholdsTableUpdateCompanionBuilder,
          (HouseholdData, $$HouseholdsTableReferences),
          HouseholdData,
          PrefetchHooks Function({
            bool address_id,
            bool building_type_id,
            bool personsRefs,
            bool householdRelationshipsRefs,
            bool servicesRefs,
            bool primaryNeedsRefs,
            bool femaleMortalitiesRefs,
            bool childMortalitiesRefs,
            bool futureResidenciesRefs,
          })
        > {
  $$HouseholdsTableTableManager(_$AppDatabase db, $HouseholdsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$HouseholdsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$HouseholdsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$HouseholdsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> household_id = const Value.absent(),
                Value<String?> head = const Value.absent(),
                Value<int?> address_id = const Value.absent(),
                Value<HouseholdTypes?> household_type_id = const Value.absent(),
                Value<int?> building_type_id = const Value.absent(),
                Value<OwnershipTypes?> ownership_type_id = const Value.absent(),
                Value<int?> household_members_num = const Value.absent(),
                Value<bool?> female_mortality = const Value.absent(),
                Value<bool?> child_mortality = const Value.absent(),
                Value<DateTime?> registration_date = const Value.absent(),
                Value<RegistrationStatus> registration_status =
                    const Value.absent(),
              }) => HouseholdsCompanion(
                household_id: household_id,
                head: head,
                address_id: address_id,
                household_type_id: household_type_id,
                building_type_id: building_type_id,
                ownership_type_id: ownership_type_id,
                household_members_num: household_members_num,
                female_mortality: female_mortality,
                child_mortality: child_mortality,
                registration_date: registration_date,
                registration_status: registration_status,
              ),
          createCompanionCallback:
              ({
                Value<int> household_id = const Value.absent(),
                Value<String?> head = const Value.absent(),
                Value<int?> address_id = const Value.absent(),
                Value<HouseholdTypes?> household_type_id = const Value.absent(),
                Value<int?> building_type_id = const Value.absent(),
                Value<OwnershipTypes?> ownership_type_id = const Value.absent(),
                Value<int?> household_members_num = const Value.absent(),
                Value<bool?> female_mortality = const Value.absent(),
                Value<bool?> child_mortality = const Value.absent(),
                Value<DateTime?> registration_date = const Value.absent(),
                required RegistrationStatus registration_status,
              }) => HouseholdsCompanion.insert(
                household_id: household_id,
                head: head,
                address_id: address_id,
                household_type_id: household_type_id,
                building_type_id: building_type_id,
                ownership_type_id: ownership_type_id,
                household_members_num: household_members_num,
                female_mortality: female_mortality,
                child_mortality: child_mortality,
                registration_date: registration_date,
                registration_status: registration_status,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$HouseholdsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            address_id = false,
            building_type_id = false,
            personsRefs = false,
            householdRelationshipsRefs = false,
            servicesRefs = false,
            primaryNeedsRefs = false,
            femaleMortalitiesRefs = false,
            childMortalitiesRefs = false,
            futureResidenciesRefs = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (personsRefs) db.persons,
                if (householdRelationshipsRefs) db.householdRelationships,
                if (servicesRefs) db.services,
                if (primaryNeedsRefs) db.primaryNeeds,
                if (femaleMortalitiesRefs) db.femaleMortalities,
                if (childMortalitiesRefs) db.childMortalities,
                if (futureResidenciesRefs) db.futureResidencies,
              ],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (address_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.address_id,
                            referencedTable: $$HouseholdsTableReferences
                                ._address_idTable(db),
                            referencedColumn:
                                $$HouseholdsTableReferences
                                    ._address_idTable(db)
                                    .address_id,
                          )
                          as T;
                }
                if (building_type_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.building_type_id,
                            referencedTable: $$HouseholdsTableReferences
                                ._building_type_idTable(db),
                            referencedColumn:
                                $$HouseholdsTableReferences
                                    ._building_type_idTable(db)
                                    .building_type_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (householdRelationshipsRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      HouseholdRelationship
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._householdRelationshipsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).householdRelationshipsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (servicesRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      ServiceData
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._servicesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).servicesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (primaryNeedsRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      PrimaryNeedData
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._primaryNeedsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).primaryNeedsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (femaleMortalitiesRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      FemaleMortalityData
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._femaleMortalitiesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).femaleMortalitiesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (childMortalitiesRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      ChildMortalityData
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._childMortalitiesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).childMortalitiesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                  if (futureResidenciesRefs)
                    await $_getPrefetchedData<
                      HouseholdData,
                      $HouseholdsTable,
                      FutureResidency
                    >(
                      currentTable: table,
                      referencedTable: $$HouseholdsTableReferences
                          ._futureResidenciesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$HouseholdsTableReferences(
                                db,
                                table,
                                p0,
                              ).futureResidenciesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.household_id == item.household_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$HouseholdsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HouseholdsTable,
      HouseholdData,
      $$HouseholdsTableFilterComposer,
      $$HouseholdsTableOrderingComposer,
      $$HouseholdsTableAnnotationComposer,
      $$HouseholdsTableCreateCompanionBuilder,
      $$HouseholdsTableUpdateCompanionBuilder,
      (HouseholdData, $$HouseholdsTableReferences),
      HouseholdData,
      PrefetchHooks Function({
        bool address_id,
        bool building_type_id,
        bool personsRefs,
        bool householdRelationshipsRefs,
        bool servicesRefs,
        bool primaryNeedsRefs,
        bool femaleMortalitiesRefs,
        bool childMortalitiesRefs,
        bool futureResidenciesRefs,
      })
    >;
typedef $$MonthlyIncomesTableCreateCompanionBuilder =
    MonthlyIncomesCompanion Function({
      Value<int> monthly_income_id,
      required String range,
    });
typedef $$MonthlyIncomesTableUpdateCompanionBuilder =
    MonthlyIncomesCompanion Function({
      Value<int> monthly_income_id,
      Value<String> range,
    });

final class $$MonthlyIncomesTableReferences
    extends
        BaseReferences<_$AppDatabase, $MonthlyIncomesTable, MonthlyIncomeData> {
  $$MonthlyIncomesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.monthlyIncomes.monthly_income_id,
      db.persons.monthly_income_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.monthly_income_id.monthly_income_id.sqlEquals(
        $_itemColumn<int>('monthly_income_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$MonthlyIncomesTableFilterComposer
    extends Composer<_$AppDatabase, $MonthlyIncomesTable> {
  $$MonthlyIncomesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get monthly_income_id => $composableBuilder(
    column: $table.monthly_income_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get range => $composableBuilder(
    column: $table.range,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.monthly_income_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.monthly_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MonthlyIncomesTableOrderingComposer
    extends Composer<_$AppDatabase, $MonthlyIncomesTable> {
  $$MonthlyIncomesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get monthly_income_id => $composableBuilder(
    column: $table.monthly_income_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get range => $composableBuilder(
    column: $table.range,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MonthlyIncomesTableAnnotationComposer
    extends Composer<_$AppDatabase, $MonthlyIncomesTable> {
  $$MonthlyIncomesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get monthly_income_id => $composableBuilder(
    column: $table.monthly_income_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get range =>
      $composableBuilder(column: $table.range, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.monthly_income_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.monthly_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MonthlyIncomesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MonthlyIncomesTable,
          MonthlyIncomeData,
          $$MonthlyIncomesTableFilterComposer,
          $$MonthlyIncomesTableOrderingComposer,
          $$MonthlyIncomesTableAnnotationComposer,
          $$MonthlyIncomesTableCreateCompanionBuilder,
          $$MonthlyIncomesTableUpdateCompanionBuilder,
          (MonthlyIncomeData, $$MonthlyIncomesTableReferences),
          MonthlyIncomeData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$MonthlyIncomesTableTableManager(
    _$AppDatabase db,
    $MonthlyIncomesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$MonthlyIncomesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$MonthlyIncomesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$MonthlyIncomesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> monthly_income_id = const Value.absent(),
                Value<String> range = const Value.absent(),
              }) => MonthlyIncomesCompanion(
                monthly_income_id: monthly_income_id,
                range: range,
              ),
          createCompanionCallback:
              ({
                Value<int> monthly_income_id = const Value.absent(),
                required String range,
              }) => MonthlyIncomesCompanion.insert(
                monthly_income_id: monthly_income_id,
                range: range,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$MonthlyIncomesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      MonthlyIncomeData,
                      $MonthlyIncomesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$MonthlyIncomesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$MonthlyIncomesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) =>
                                e.monthly_income_id == item.monthly_income_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$MonthlyIncomesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MonthlyIncomesTable,
      MonthlyIncomeData,
      $$MonthlyIncomesTableFilterComposer,
      $$MonthlyIncomesTableOrderingComposer,
      $$MonthlyIncomesTableAnnotationComposer,
      $$MonthlyIncomesTableCreateCompanionBuilder,
      $$MonthlyIncomesTableUpdateCompanionBuilder,
      (MonthlyIncomeData, $$MonthlyIncomesTableReferences),
      MonthlyIncomeData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$DailyIncomesTableCreateCompanionBuilder =
    DailyIncomesCompanion Function({
      Value<int> daily_income_id,
      required String range,
    });
typedef $$DailyIncomesTableUpdateCompanionBuilder =
    DailyIncomesCompanion Function({
      Value<int> daily_income_id,
      Value<String> range,
    });

final class $$DailyIncomesTableReferences
    extends BaseReferences<_$AppDatabase, $DailyIncomesTable, DailyIncomeData> {
  $$DailyIncomesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.dailyIncomes.daily_income_id,
      db.persons.daily_income_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.daily_income_id.daily_income_id.sqlEquals(
        $_itemColumn<int>('daily_income_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$DailyIncomesTableFilterComposer
    extends Composer<_$AppDatabase, $DailyIncomesTable> {
  $$DailyIncomesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get daily_income_id => $composableBuilder(
    column: $table.daily_income_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get range => $composableBuilder(
    column: $table.range,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.daily_income_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.daily_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DailyIncomesTableOrderingComposer
    extends Composer<_$AppDatabase, $DailyIncomesTable> {
  $$DailyIncomesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get daily_income_id => $composableBuilder(
    column: $table.daily_income_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get range => $composableBuilder(
    column: $table.range,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DailyIncomesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DailyIncomesTable> {
  $$DailyIncomesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get daily_income_id => $composableBuilder(
    column: $table.daily_income_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get range =>
      $composableBuilder(column: $table.range, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.daily_income_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.daily_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DailyIncomesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DailyIncomesTable,
          DailyIncomeData,
          $$DailyIncomesTableFilterComposer,
          $$DailyIncomesTableOrderingComposer,
          $$DailyIncomesTableAnnotationComposer,
          $$DailyIncomesTableCreateCompanionBuilder,
          $$DailyIncomesTableUpdateCompanionBuilder,
          (DailyIncomeData, $$DailyIncomesTableReferences),
          DailyIncomeData,
          PrefetchHooks Function({bool personsRefs})
        > {
  $$DailyIncomesTableTableManager(_$AppDatabase db, $DailyIncomesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$DailyIncomesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$DailyIncomesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$DailyIncomesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> daily_income_id = const Value.absent(),
                Value<String> range = const Value.absent(),
              }) => DailyIncomesCompanion(
                daily_income_id: daily_income_id,
                range: range,
              ),
          createCompanionCallback:
              ({
                Value<int> daily_income_id = const Value.absent(),
                required String range,
              }) => DailyIncomesCompanion.insert(
                daily_income_id: daily_income_id,
                range: range,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$DailyIncomesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (personsRefs) db.persons],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      DailyIncomeData,
                      $DailyIncomesTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$DailyIncomesTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$DailyIncomesTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.daily_income_id == item.daily_income_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$DailyIncomesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DailyIncomesTable,
      DailyIncomeData,
      $$DailyIncomesTableFilterComposer,
      $$DailyIncomesTableOrderingComposer,
      $$DailyIncomesTableAnnotationComposer,
      $$DailyIncomesTableCreateCompanionBuilder,
      $$DailyIncomesTableUpdateCompanionBuilder,
      (DailyIncomeData, $$DailyIncomesTableReferences),
      DailyIncomeData,
      PrefetchHooks Function({bool personsRefs})
    >;
typedef $$EducationTableCreateCompanionBuilder =
    EducationCompanion Function({
      Value<int> education_id,
      required String level,
    });
typedef $$EducationTableUpdateCompanionBuilder =
    EducationCompanion Function({Value<int> education_id, Value<String> level});

final class $$EducationTableReferences
    extends BaseReferences<_$AppDatabase, $EducationTable, EducationData> {
  $$EducationTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PersonsTable, List<PersonData>> _personsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.persons,
    aliasName: $_aliasNameGenerator(
      db.education.education_id,
      db.persons.education_id,
    ),
  );

  $$PersonsTableProcessedTableManager get personsRefs {
    final manager = $$PersonsTableTableManager($_db, $_db.persons).filter(
      (f) => f.education_id.education_id.sqlEquals(
        $_itemColumn<int>('education_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_personsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$EnrolledTable, List<EnrolledData>>
  _enrolledRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.enrolled,
    aliasName: $_aliasNameGenerator(
      db.education.education_id,
      db.enrolled.education_id,
    ),
  );

  $$EnrolledTableProcessedTableManager get enrolledRefs {
    final manager = $$EnrolledTableTableManager($_db, $_db.enrolled).filter(
      (f) => f.education_id.education_id.sqlEquals(
        $_itemColumn<int>('education_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_enrolledRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$EducationTableFilterComposer
    extends Composer<_$AppDatabase, $EducationTable> {
  $$EducationTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get education_id => $composableBuilder(
    column: $table.education_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> personsRefs(
    Expression<bool> Function($$PersonsTableFilterComposer f) f,
  ) {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> enrolledRefs(
    Expression<bool> Function($$EnrolledTableFilterComposer f) f,
  ) {
    final $$EnrolledTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.enrolled,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EnrolledTableFilterComposer(
            $db: $db,
            $table: $db.enrolled,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EducationTableOrderingComposer
    extends Composer<_$AppDatabase, $EducationTable> {
  $$EducationTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get education_id => $composableBuilder(
    column: $table.education_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$EducationTableAnnotationComposer
    extends Composer<_$AppDatabase, $EducationTable> {
  $$EducationTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get education_id => $composableBuilder(
    column: $table.education_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get level =>
      $composableBuilder(column: $table.level, builder: (column) => column);

  Expression<T> personsRefs<T extends Object>(
    Expression<T> Function($$PersonsTableAnnotationComposer a) f,
  ) {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> enrolledRefs<T extends Object>(
    Expression<T> Function($$EnrolledTableAnnotationComposer a) f,
  ) {
    final $$EnrolledTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.enrolled,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EnrolledTableAnnotationComposer(
            $db: $db,
            $table: $db.enrolled,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$EducationTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EducationTable,
          EducationData,
          $$EducationTableFilterComposer,
          $$EducationTableOrderingComposer,
          $$EducationTableAnnotationComposer,
          $$EducationTableCreateCompanionBuilder,
          $$EducationTableUpdateCompanionBuilder,
          (EducationData, $$EducationTableReferences),
          EducationData,
          PrefetchHooks Function({bool personsRefs, bool enrolledRefs})
        > {
  $$EducationTableTableManager(_$AppDatabase db, $EducationTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$EducationTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$EducationTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$EducationTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> education_id = const Value.absent(),
                Value<String> level = const Value.absent(),
              }) =>
                  EducationCompanion(education_id: education_id, level: level),
          createCompanionCallback:
              ({
                Value<int> education_id = const Value.absent(),
                required String level,
              }) => EducationCompanion.insert(
                education_id: education_id,
                level: level,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$EducationTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({personsRefs = false, enrolledRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (personsRefs) db.persons,
                if (enrolledRefs) db.enrolled,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (personsRefs)
                    await $_getPrefetchedData<
                      EducationData,
                      $EducationTable,
                      PersonData
                    >(
                      currentTable: table,
                      referencedTable: $$EducationTableReferences
                          ._personsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$EducationTableReferences(
                                db,
                                table,
                                p0,
                              ).personsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.education_id == item.education_id,
                          ),
                      typedResults: items,
                    ),
                  if (enrolledRefs)
                    await $_getPrefetchedData<
                      EducationData,
                      $EducationTable,
                      EnrolledData
                    >(
                      currentTable: table,
                      referencedTable: $$EducationTableReferences
                          ._enrolledRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$EducationTableReferences(
                                db,
                                table,
                                p0,
                              ).enrolledRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.education_id == item.education_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$EducationTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EducationTable,
      EducationData,
      $$EducationTableFilterComposer,
      $$EducationTableOrderingComposer,
      $$EducationTableAnnotationComposer,
      $$EducationTableCreateCompanionBuilder,
      $$EducationTableUpdateCompanionBuilder,
      (EducationData, $$EducationTableReferences),
      EducationData,
      PrefetchHooks Function({bool personsRefs, bool enrolledRefs})
    >;
typedef $$PersonsTableCreateCompanionBuilder =
    PersonsCompanion Function({
      Value<int> person_id,
      required String last_name,
      required String first_name,
      Value<String?> middle_name,
      Value<String?> suffix,
      Value<Sex?> sex,
      Value<int?> age,
      Value<DateTime?> birth_date,
      Value<String?> birth_place,
      Value<CivilStatus?> civil_status,
      Value<int?> religion_id,
      Value<int?> nationality_id,
      Value<int?> ethnicity_id,
      Value<int?> blood_type_id,
      Value<int?> household_id,
      Value<int?> address_id,
      Value<String?> registration_place,
      Value<Residency?> residency,
      Value<int?> years_of_residency,
      Value<Transient?> transient_type,
      Value<int?> monthly_income_id,
      Value<int?> daily_income_id,
      Value<SoloParent?> solo_parent,
      Value<bool?> ofw,
      Value<bool?> literate,
      Value<bool?> pwd,
      Value<bool?> registered_voter,
      Value<CurrentlyEnrolled?> currently_enrolled,
      Value<int?> education_id,
      Value<bool?> deceased,
      Value<DateTime?> death_date,
      Value<DateTime?> registration_date,
      required RegistrationStatus registration_status,
    });
typedef $$PersonsTableUpdateCompanionBuilder =
    PersonsCompanion Function({
      Value<int> person_id,
      Value<String> last_name,
      Value<String> first_name,
      Value<String?> middle_name,
      Value<String?> suffix,
      Value<Sex?> sex,
      Value<int?> age,
      Value<DateTime?> birth_date,
      Value<String?> birth_place,
      Value<CivilStatus?> civil_status,
      Value<int?> religion_id,
      Value<int?> nationality_id,
      Value<int?> ethnicity_id,
      Value<int?> blood_type_id,
      Value<int?> household_id,
      Value<int?> address_id,
      Value<String?> registration_place,
      Value<Residency?> residency,
      Value<int?> years_of_residency,
      Value<Transient?> transient_type,
      Value<int?> monthly_income_id,
      Value<int?> daily_income_id,
      Value<SoloParent?> solo_parent,
      Value<bool?> ofw,
      Value<bool?> literate,
      Value<bool?> pwd,
      Value<bool?> registered_voter,
      Value<CurrentlyEnrolled?> currently_enrolled,
      Value<int?> education_id,
      Value<bool?> deceased,
      Value<DateTime?> death_date,
      Value<DateTime?> registration_date,
      Value<RegistrationStatus> registration_status,
    });

final class $$PersonsTableReferences
    extends BaseReferences<_$AppDatabase, $PersonsTable, PersonData> {
  $$PersonsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ReligionsTable _religion_idTable(_$AppDatabase db) =>
      db.religions.createAlias(
        $_aliasNameGenerator(db.persons.religion_id, db.religions.religion_id),
      );

  $$ReligionsTableProcessedTableManager? get religion_id {
    final $_column = $_itemColumn<int>('religion_id');
    if ($_column == null) return null;
    final manager = $$ReligionsTableTableManager(
      $_db,
      $_db.religions,
    ).filter((f) => f.religion_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_religion_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $NationalitiesTable _nationality_idTable(_$AppDatabase db) =>
      db.nationalities.createAlias(
        $_aliasNameGenerator(
          db.persons.nationality_id,
          db.nationalities.nationality_id,
        ),
      );

  $$NationalitiesTableProcessedTableManager? get nationality_id {
    final $_column = $_itemColumn<int>('nationality_id');
    if ($_column == null) return null;
    final manager = $$NationalitiesTableTableManager(
      $_db,
      $_db.nationalities,
    ).filter((f) => f.nationality_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_nationality_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $EthnicitiesTable _ethnicity_idTable(_$AppDatabase db) =>
      db.ethnicities.createAlias(
        $_aliasNameGenerator(
          db.persons.ethnicity_id,
          db.ethnicities.ethnicity_id,
        ),
      );

  $$EthnicitiesTableProcessedTableManager? get ethnicity_id {
    final $_column = $_itemColumn<int>('ethnicity_id');
    if ($_column == null) return null;
    final manager = $$EthnicitiesTableTableManager(
      $_db,
      $_db.ethnicities,
    ).filter((f) => f.ethnicity_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ethnicity_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BloodTypesTable _blood_type_idTable(_$AppDatabase db) =>
      db.bloodTypes.createAlias(
        $_aliasNameGenerator(
          db.persons.blood_type_id,
          db.bloodTypes.blood_type_id,
        ),
      );

  $$BloodTypesTableProcessedTableManager? get blood_type_id {
    final $_column = $_itemColumn<int>('blood_type_id');
    if ($_column == null) return null;
    final manager = $$BloodTypesTableTableManager(
      $_db,
      $_db.bloodTypes,
    ).filter((f) => f.blood_type_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_blood_type_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.persons.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager? get household_id {
    final $_column = $_itemColumn<int>('household_id');
    if ($_column == null) return null;
    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $AddressesTable _address_idTable(_$AppDatabase db) =>
      db.addresses.createAlias(
        $_aliasNameGenerator(db.persons.address_id, db.addresses.address_id),
      );

  $$AddressesTableProcessedTableManager? get address_id {
    final $_column = $_itemColumn<int>('address_id');
    if ($_column == null) return null;
    final manager = $$AddressesTableTableManager(
      $_db,
      $_db.addresses,
    ).filter((f) => f.address_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_address_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $MonthlyIncomesTable _monthly_income_idTable(_$AppDatabase db) =>
      db.monthlyIncomes.createAlias(
        $_aliasNameGenerator(
          db.persons.monthly_income_id,
          db.monthlyIncomes.monthly_income_id,
        ),
      );

  $$MonthlyIncomesTableProcessedTableManager? get monthly_income_id {
    final $_column = $_itemColumn<int>('monthly_income_id');
    if ($_column == null) return null;
    final manager = $$MonthlyIncomesTableTableManager(
      $_db,
      $_db.monthlyIncomes,
    ).filter((f) => f.monthly_income_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_monthly_income_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $DailyIncomesTable _daily_income_idTable(_$AppDatabase db) =>
      db.dailyIncomes.createAlias(
        $_aliasNameGenerator(
          db.persons.daily_income_id,
          db.dailyIncomes.daily_income_id,
        ),
      );

  $$DailyIncomesTableProcessedTableManager? get daily_income_id {
    final $_column = $_itemColumn<int>('daily_income_id');
    if ($_column == null) return null;
    final manager = $$DailyIncomesTableTableManager(
      $_db,
      $_db.dailyIncomes,
    ).filter((f) => f.daily_income_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_daily_income_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $EducationTable _education_idTable(_$AppDatabase db) =>
      db.education.createAlias(
        $_aliasNameGenerator(
          db.persons.education_id,
          db.education.education_id,
        ),
      );

  $$EducationTableProcessedTableManager? get education_id {
    final $_column = $_itemColumn<int>('education_id');
    if ($_column == null) return null;
    final manager = $$EducationTableTableManager(
      $_db,
      $_db.education,
    ).filter((f) => f.education_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_education_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OccupationsTable, List<OccupationData>>
  _occupationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.occupations,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.occupations.person_id,
    ),
  );

  $$OccupationsTableProcessedTableManager get occupationsRefs {
    final manager = $$OccupationsTableTableManager(
      $_db,
      $_db.occupations,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_occupationsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$EmailsTable, List<EmailData>> _emailsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.emails,
    aliasName: $_aliasNameGenerator(db.persons.person_id, db.emails.person_id),
  );

  $$EmailsTableProcessedTableManager get emailsRefs {
    final manager = $$EmailsTableTableManager($_db, $_db.emails).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_emailsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PhoneNumbersTable, List<PhoneNumberData>>
  _phoneNumbersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.phoneNumbers,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.phoneNumbers.person_id,
    ),
  );

  $$PhoneNumbersTableProcessedTableManager get phoneNumbersRefs {
    final manager = $$PhoneNumbersTableTableManager(
      $_db,
      $_db.phoneNumbers,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_phoneNumbersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$GadgetsTable, List<GadgetData>> _gadgetsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.gadgets,
    aliasName: $_aliasNameGenerator(db.persons.person_id, db.gadgets.person_id),
  );

  $$GadgetsTableProcessedTableManager get gadgetsRefs {
    final manager = $$GadgetsTableTableManager($_db, $_db.gadgets).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_gadgetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $GovermentProgramsTable,
    List<GovernmentProgramData>
  >
  _govermentProgramsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.govermentPrograms,
        aliasName: $_aliasNameGenerator(
          db.persons.person_id,
          db.govermentPrograms.person_id,
        ),
      );

  $$GovermentProgramsTableProcessedTableManager get govermentProgramsRefs {
    final manager = $$GovermentProgramsTableTableManager(
      $_db,
      $_db.govermentPrograms,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _govermentProgramsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$VoterRegistriesTable, List<VoterRegistryData>>
  _voterRegistriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.voterRegistries,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.voterRegistries.person_id,
    ),
  );

  $$VoterRegistriesTableProcessedTableManager get voterRegistriesRefs {
    final manager = $$VoterRegistriesTableTableManager(
      $_db,
      $_db.voterRegistries,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _voterRegistriesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $RegisteredSeniorsTable,
    List<RegisteredSeniorData>
  >
  _registeredSeniorsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.registeredSeniors,
        aliasName: $_aliasNameGenerator(
          db.persons.person_id,
          db.registeredSeniors.person_id,
        ),
      );

  $$RegisteredSeniorsTableProcessedTableManager get registeredSeniorsRefs {
    final manager = $$RegisteredSeniorsTableTableManager(
      $_db,
      $_db.registeredSeniors,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _registeredSeniorsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$DisabilitiesTable, List<DisabilityData>>
  _disabilitiesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.disabilities,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.disabilities.person_id,
    ),
  );

  $$DisabilitiesTableProcessedTableManager get disabilitiesRefs {
    final manager = $$DisabilitiesTableTableManager(
      $_db,
      $_db.disabilities,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_disabilitiesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$EnrolledTable, List<EnrolledData>>
  _enrolledRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.enrolled,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.enrolled.person_id,
    ),
  );

  $$EnrolledTableProcessedTableManager get enrolledRefs {
    final manager = $$EnrolledTableTableManager($_db, $_db.enrolled).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_enrolledRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CTCRecordsTable, List<CTCRecordData>>
  _cTCRecordsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.cTCRecords,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.cTCRecords.person_id,
    ),
  );

  $$CTCRecordsTableProcessedTableManager get cTCRecordsRefs {
    final manager = $$CTCRecordsTableTableManager($_db, $_db.cTCRecords).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_cTCRecordsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$BrgyHistoriesTable, List<BrgyHistoryData>>
  _brgyHistoriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.brgyHistories,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.brgyHistories.person_id,
    ),
  );

  $$BrgyHistoriesTableProcessedTableManager get brgyHistoriesRefs {
    final manager = $$BrgyHistoriesTableTableManager(
      $_db,
      $_db.brgyHistories,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_brgyHistoriesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $MigrantTransientsTable,
    List<MigrantTransientData>
  >
  _migrantTransientsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.migrantTransients,
        aliasName: $_aliasNameGenerator(
          db.persons.person_id,
          db.migrantTransients.person_id,
        ),
      );

  $$MigrantTransientsTableProcessedTableManager get migrantTransientsRefs {
    final manager = $$MigrantTransientsTableTableManager(
      $_db,
      $_db.migrantTransients,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _migrantTransientsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $HouseholdRelationshipsTable,
    List<HouseholdRelationship>
  >
  _householdRelationshipsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.householdRelationships,
        aliasName: $_aliasNameGenerator(
          db.persons.person_id,
          db.householdRelationships.person_id,
        ),
      );

  $$HouseholdRelationshipsTableProcessedTableManager
  get householdRelationshipsRefs {
    final manager = $$HouseholdRelationshipsTableTableManager(
      $_db,
      $_db.householdRelationships,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _householdRelationshipsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FishingTable, List<FishingData>>
  _fishingRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.fishing,
    aliasName: $_aliasNameGenerator(db.persons.person_id, db.fishing.person_id),
  );

  $$FishingTableProcessedTableManager get fishingRefs {
    final manager = $$FishingTableTableManager($_db, $_db.fishing).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_fishingRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AgricultureTable, List<AgricultureData>>
  _agricultureRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.agriculture,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.agriculture.person_id,
    ),
  );

  $$AgricultureTableProcessedTableManager get agricultureRefs {
    final manager = $$AgricultureTableTableManager(
      $_db,
      $_db.agriculture,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_agricultureRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LivestockTable, List<LivestockData>>
  _livestockRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.livestock,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.livestock.person_id,
    ),
  );

  $$LivestockTableProcessedTableManager get livestockRefs {
    final manager = $$LivestockTableTableManager($_db, $_db.livestock).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_livestockRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FamilyPlansTable, List<FamilyPlanData>>
  _familyPlansRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.familyPlans,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.familyPlans.person_id,
    ),
  );

  $$FamilyPlansTableProcessedTableManager get familyPlansRefs {
    final manager = $$FamilyPlansTableTableManager(
      $_db,
      $_db.familyPlans,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_familyPlansRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$MaternalInfosTable, List<MaternalInfoData>>
  _maternalInfosRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.maternalInfos,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.maternalInfos.person_id,
    ),
  );

  $$MaternalInfosTableProcessedTableManager get maternalInfosRefs {
    final manager = $$MaternalInfosTableTableManager(
      $_db,
      $_db.maternalInfos,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_maternalInfosRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$VisitedFacilitiesTable, List<VisitedFacilityData>>
  _visitedFacilitiesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.visitedFacilities,
        aliasName: $_aliasNameGenerator(
          db.persons.person_id,
          db.visitedFacilities.person_id,
        ),
      );

  $$VisitedFacilitiesTableProcessedTableManager get visitedFacilitiesRefs {
    final manager = $$VisitedFacilitiesTableTableManager(
      $_db,
      $_db.visitedFacilities,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _visitedFacilitiesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$HealthInsurancesTable, List<HealthInsuranceData>>
  _healthInsurancesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.healthInsurances,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.healthInsurances.person_id,
    ),
  );

  $$HealthInsurancesTableProcessedTableManager get healthInsurancesRefs {
    final manager = $$HealthInsurancesTableTableManager(
      $_db,
      $_db.healthInsurances,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _healthInsurancesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$NewbornInfosTable, List<NewbornInfoData>>
  _newbornInfosRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.newbornInfos,
    aliasName: $_aliasNameGenerator(
      db.persons.person_id,
      db.newbornInfos.person_id,
    ),
  );

  $$NewbornInfosTableProcessedTableManager get newbornInfosRefs {
    final manager = $$NewbornInfosTableTableManager(
      $_db,
      $_db.newbornInfos,
    ).filter(
      (f) => f.person_id.person_id.sqlEquals($_itemColumn<int>('person_id')!),
    );

    final cache = $_typedResult.readTableOrNull(_newbornInfosRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PersonsTableFilterComposer
    extends Composer<_$AppDatabase, $PersonsTable> {
  $$PersonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get person_id => $composableBuilder(
    column: $table.person_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get last_name => $composableBuilder(
    column: $table.last_name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get first_name => $composableBuilder(
    column: $table.first_name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get middle_name => $composableBuilder(
    column: $table.middle_name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Sex?, Sex, String> get sex =>
      $composableBuilder(
        column: $table.sex,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get birth_date => $composableBuilder(
    column: $table.birth_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get birth_place => $composableBuilder(
    column: $table.birth_place,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<CivilStatus?, CivilStatus, String>
  get civil_status => $composableBuilder(
    column: $table.civil_status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get registration_place => $composableBuilder(
    column: $table.registration_place,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Residency?, Residency, String> get residency =>
      $composableBuilder(
        column: $table.residency,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<int> get years_of_residency => $composableBuilder(
    column: $table.years_of_residency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Transient?, Transient, String>
  get transient_type => $composableBuilder(
    column: $table.transient_type,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnWithTypeConverterFilters<SoloParent?, SoloParent, String>
  get solo_parent => $composableBuilder(
    column: $table.solo_parent,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get ofw => $composableBuilder(
    column: $table.ofw,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get literate => $composableBuilder(
    column: $table.literate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get pwd => $composableBuilder(
    column: $table.pwd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get registered_voter => $composableBuilder(
    column: $table.registered_voter,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<CurrentlyEnrolled?, CurrentlyEnrolled, String>
  get currently_enrolled => $composableBuilder(
    column: $table.currently_enrolled,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get deceased => $composableBuilder(
    column: $table.deceased,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get death_date => $composableBuilder(
    column: $table.death_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<RegistrationStatus, RegistrationStatus, String>
  get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  $$ReligionsTableFilterComposer get religion_id {
    final $$ReligionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.religion_id,
      referencedTable: $db.religions,
      getReferencedColumn: (t) => t.religion_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ReligionsTableFilterComposer(
            $db: $db,
            $table: $db.religions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$NationalitiesTableFilterComposer get nationality_id {
    final $$NationalitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.nationality_id,
      referencedTable: $db.nationalities,
      getReferencedColumn: (t) => t.nationality_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NationalitiesTableFilterComposer(
            $db: $db,
            $table: $db.nationalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EthnicitiesTableFilterComposer get ethnicity_id {
    final $$EthnicitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ethnicity_id,
      referencedTable: $db.ethnicities,
      getReferencedColumn: (t) => t.ethnicity_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EthnicitiesTableFilterComposer(
            $db: $db,
            $table: $db.ethnicities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BloodTypesTableFilterComposer get blood_type_id {
    final $$BloodTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.blood_type_id,
      referencedTable: $db.bloodTypes,
      getReferencedColumn: (t) => t.blood_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BloodTypesTableFilterComposer(
            $db: $db,
            $table: $db.bloodTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AddressesTableFilterComposer get address_id {
    final $$AddressesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableFilterComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MonthlyIncomesTableFilterComposer get monthly_income_id {
    final $$MonthlyIncomesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.monthly_income_id,
      referencedTable: $db.monthlyIncomes,
      getReferencedColumn: (t) => t.monthly_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MonthlyIncomesTableFilterComposer(
            $db: $db,
            $table: $db.monthlyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DailyIncomesTableFilterComposer get daily_income_id {
    final $$DailyIncomesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.daily_income_id,
      referencedTable: $db.dailyIncomes,
      getReferencedColumn: (t) => t.daily_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DailyIncomesTableFilterComposer(
            $db: $db,
            $table: $db.dailyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableFilterComposer get education_id {
    final $$EducationTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableFilterComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> occupationsRefs(
    Expression<bool> Function($$OccupationsTableFilterComposer f) f,
  ) {
    final $$OccupationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.occupations,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OccupationsTableFilterComposer(
            $db: $db,
            $table: $db.occupations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> emailsRefs(
    Expression<bool> Function($$EmailsTableFilterComposer f) f,
  ) {
    final $$EmailsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.emails,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EmailsTableFilterComposer(
            $db: $db,
            $table: $db.emails,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> phoneNumbersRefs(
    Expression<bool> Function($$PhoneNumbersTableFilterComposer f) f,
  ) {
    final $$PhoneNumbersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.phoneNumbers,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PhoneNumbersTableFilterComposer(
            $db: $db,
            $table: $db.phoneNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> gadgetsRefs(
    Expression<bool> Function($$GadgetsTableFilterComposer f) f,
  ) {
    final $$GadgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.gadgets,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GadgetsTableFilterComposer(
            $db: $db,
            $table: $db.gadgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> govermentProgramsRefs(
    Expression<bool> Function($$GovermentProgramsTableFilterComposer f) f,
  ) {
    final $$GovermentProgramsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.govermentPrograms,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GovermentProgramsTableFilterComposer(
            $db: $db,
            $table: $db.govermentPrograms,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> voterRegistriesRefs(
    Expression<bool> Function($$VoterRegistriesTableFilterComposer f) f,
  ) {
    final $$VoterRegistriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.voterRegistries,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VoterRegistriesTableFilterComposer(
            $db: $db,
            $table: $db.voterRegistries,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> registeredSeniorsRefs(
    Expression<bool> Function($$RegisteredSeniorsTableFilterComposer f) f,
  ) {
    final $$RegisteredSeniorsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.registeredSeniors,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegisteredSeniorsTableFilterComposer(
            $db: $db,
            $table: $db.registeredSeniors,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> disabilitiesRefs(
    Expression<bool> Function($$DisabilitiesTableFilterComposer f) f,
  ) {
    final $$DisabilitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.disabilities,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DisabilitiesTableFilterComposer(
            $db: $db,
            $table: $db.disabilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> enrolledRefs(
    Expression<bool> Function($$EnrolledTableFilterComposer f) f,
  ) {
    final $$EnrolledTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.enrolled,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EnrolledTableFilterComposer(
            $db: $db,
            $table: $db.enrolled,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> cTCRecordsRefs(
    Expression<bool> Function($$CTCRecordsTableFilterComposer f) f,
  ) {
    final $$CTCRecordsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.cTCRecords,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CTCRecordsTableFilterComposer(
            $db: $db,
            $table: $db.cTCRecords,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> brgyHistoriesRefs(
    Expression<bool> Function($$BrgyHistoriesTableFilterComposer f) f,
  ) {
    final $$BrgyHistoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.brgyHistories,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrgyHistoriesTableFilterComposer(
            $db: $db,
            $table: $db.brgyHistories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> migrantTransientsRefs(
    Expression<bool> Function($$MigrantTransientsTableFilterComposer f) f,
  ) {
    final $$MigrantTransientsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.migrantTransients,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MigrantTransientsTableFilterComposer(
            $db: $db,
            $table: $db.migrantTransients,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> householdRelationshipsRefs(
    Expression<bool> Function($$HouseholdRelationshipsTableFilterComposer f) f,
  ) {
    final $$HouseholdRelationshipsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableFilterComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> fishingRefs(
    Expression<bool> Function($$FishingTableFilterComposer f) f,
  ) {
    final $$FishingTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.fishing,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingTableFilterComposer(
            $db: $db,
            $table: $db.fishing,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> agricultureRefs(
    Expression<bool> Function($$AgricultureTableFilterComposer f) f,
  ) {
    final $$AgricultureTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.agriculture,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgricultureTableFilterComposer(
            $db: $db,
            $table: $db.agriculture,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> livestockRefs(
    Expression<bool> Function($$LivestockTableFilterComposer f) f,
  ) {
    final $$LivestockTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.livestock,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockTableFilterComposer(
            $db: $db,
            $table: $db.livestock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> familyPlansRefs(
    Expression<bool> Function($$FamilyPlansTableFilterComposer f) f,
  ) {
    final $$FamilyPlansTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableFilterComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> maternalInfosRefs(
    Expression<bool> Function($$MaternalInfosTableFilterComposer f) f,
  ) {
    final $$MaternalInfosTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.maternalInfos,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MaternalInfosTableFilterComposer(
            $db: $db,
            $table: $db.maternalInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> visitedFacilitiesRefs(
    Expression<bool> Function($$VisitedFacilitiesTableFilterComposer f) f,
  ) {
    final $$VisitedFacilitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.visitedFacilities,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VisitedFacilitiesTableFilterComposer(
            $db: $db,
            $table: $db.visitedFacilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> healthInsurancesRefs(
    Expression<bool> Function($$HealthInsurancesTableFilterComposer f) f,
  ) {
    final $$HealthInsurancesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.healthInsurances,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HealthInsurancesTableFilterComposer(
            $db: $db,
            $table: $db.healthInsurances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> newbornInfosRefs(
    Expression<bool> Function($$NewbornInfosTableFilterComposer f) f,
  ) {
    final $$NewbornInfosTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableFilterComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PersonsTableOrderingComposer
    extends Composer<_$AppDatabase, $PersonsTable> {
  $$PersonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get person_id => $composableBuilder(
    column: $table.person_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get last_name => $composableBuilder(
    column: $table.last_name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get first_name => $composableBuilder(
    column: $table.first_name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get middle_name => $composableBuilder(
    column: $table.middle_name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sex => $composableBuilder(
    column: $table.sex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get birth_date => $composableBuilder(
    column: $table.birth_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get birth_place => $composableBuilder(
    column: $table.birth_place,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get civil_status => $composableBuilder(
    column: $table.civil_status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get registration_place => $composableBuilder(
    column: $table.registration_place,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get residency => $composableBuilder(
    column: $table.residency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get years_of_residency => $composableBuilder(
    column: $table.years_of_residency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transient_type => $composableBuilder(
    column: $table.transient_type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get solo_parent => $composableBuilder(
    column: $table.solo_parent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get ofw => $composableBuilder(
    column: $table.ofw,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get literate => $composableBuilder(
    column: $table.literate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get pwd => $composableBuilder(
    column: $table.pwd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get registered_voter => $composableBuilder(
    column: $table.registered_voter,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currently_enrolled => $composableBuilder(
    column: $table.currently_enrolled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get deceased => $composableBuilder(
    column: $table.deceased,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get death_date => $composableBuilder(
    column: $table.death_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => ColumnOrderings(column),
  );

  $$ReligionsTableOrderingComposer get religion_id {
    final $$ReligionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.religion_id,
      referencedTable: $db.religions,
      getReferencedColumn: (t) => t.religion_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ReligionsTableOrderingComposer(
            $db: $db,
            $table: $db.religions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$NationalitiesTableOrderingComposer get nationality_id {
    final $$NationalitiesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.nationality_id,
      referencedTable: $db.nationalities,
      getReferencedColumn: (t) => t.nationality_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NationalitiesTableOrderingComposer(
            $db: $db,
            $table: $db.nationalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EthnicitiesTableOrderingComposer get ethnicity_id {
    final $$EthnicitiesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ethnicity_id,
      referencedTable: $db.ethnicities,
      getReferencedColumn: (t) => t.ethnicity_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EthnicitiesTableOrderingComposer(
            $db: $db,
            $table: $db.ethnicities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BloodTypesTableOrderingComposer get blood_type_id {
    final $$BloodTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.blood_type_id,
      referencedTable: $db.bloodTypes,
      getReferencedColumn: (t) => t.blood_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BloodTypesTableOrderingComposer(
            $db: $db,
            $table: $db.bloodTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AddressesTableOrderingComposer get address_id {
    final $$AddressesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableOrderingComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MonthlyIncomesTableOrderingComposer get monthly_income_id {
    final $$MonthlyIncomesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.monthly_income_id,
      referencedTable: $db.monthlyIncomes,
      getReferencedColumn: (t) => t.monthly_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MonthlyIncomesTableOrderingComposer(
            $db: $db,
            $table: $db.monthlyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DailyIncomesTableOrderingComposer get daily_income_id {
    final $$DailyIncomesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.daily_income_id,
      referencedTable: $db.dailyIncomes,
      getReferencedColumn: (t) => t.daily_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DailyIncomesTableOrderingComposer(
            $db: $db,
            $table: $db.dailyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableOrderingComposer get education_id {
    final $$EducationTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableOrderingComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PersonsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PersonsTable> {
  $$PersonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get person_id =>
      $composableBuilder(column: $table.person_id, builder: (column) => column);

  GeneratedColumn<String> get last_name =>
      $composableBuilder(column: $table.last_name, builder: (column) => column);

  GeneratedColumn<String> get first_name => $composableBuilder(
    column: $table.first_name,
    builder: (column) => column,
  );

  GeneratedColumn<String> get middle_name => $composableBuilder(
    column: $table.middle_name,
    builder: (column) => column,
  );

  GeneratedColumn<String> get suffix =>
      $composableBuilder(column: $table.suffix, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Sex?, String> get sex =>
      $composableBuilder(column: $table.sex, builder: (column) => column);

  GeneratedColumn<int> get age =>
      $composableBuilder(column: $table.age, builder: (column) => column);

  GeneratedColumn<DateTime> get birth_date => $composableBuilder(
    column: $table.birth_date,
    builder: (column) => column,
  );

  GeneratedColumn<String> get birth_place => $composableBuilder(
    column: $table.birth_place,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<CivilStatus?, String> get civil_status =>
      $composableBuilder(
        column: $table.civil_status,
        builder: (column) => column,
      );

  GeneratedColumn<String> get registration_place => $composableBuilder(
    column: $table.registration_place,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Residency?, String> get residency =>
      $composableBuilder(column: $table.residency, builder: (column) => column);

  GeneratedColumn<int> get years_of_residency => $composableBuilder(
    column: $table.years_of_residency,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Transient?, String> get transient_type =>
      $composableBuilder(
        column: $table.transient_type,
        builder: (column) => column,
      );

  GeneratedColumnWithTypeConverter<SoloParent?, String> get solo_parent =>
      $composableBuilder(
        column: $table.solo_parent,
        builder: (column) => column,
      );

  GeneratedColumn<bool> get ofw =>
      $composableBuilder(column: $table.ofw, builder: (column) => column);

  GeneratedColumn<bool> get literate =>
      $composableBuilder(column: $table.literate, builder: (column) => column);

  GeneratedColumn<bool> get pwd =>
      $composableBuilder(column: $table.pwd, builder: (column) => column);

  GeneratedColumn<bool> get registered_voter => $composableBuilder(
    column: $table.registered_voter,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<CurrentlyEnrolled?, String>
  get currently_enrolled => $composableBuilder(
    column: $table.currently_enrolled,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get deceased =>
      $composableBuilder(column: $table.deceased, builder: (column) => column);

  GeneratedColumn<DateTime> get death_date => $composableBuilder(
    column: $table.death_date,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get registration_date => $composableBuilder(
    column: $table.registration_date,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<RegistrationStatus, String>
  get registration_status => $composableBuilder(
    column: $table.registration_status,
    builder: (column) => column,
  );

  $$ReligionsTableAnnotationComposer get religion_id {
    final $$ReligionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.religion_id,
      referencedTable: $db.religions,
      getReferencedColumn: (t) => t.religion_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ReligionsTableAnnotationComposer(
            $db: $db,
            $table: $db.religions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$NationalitiesTableAnnotationComposer get nationality_id {
    final $$NationalitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.nationality_id,
      referencedTable: $db.nationalities,
      getReferencedColumn: (t) => t.nationality_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NationalitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.nationalities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EthnicitiesTableAnnotationComposer get ethnicity_id {
    final $$EthnicitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ethnicity_id,
      referencedTable: $db.ethnicities,
      getReferencedColumn: (t) => t.ethnicity_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EthnicitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.ethnicities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BloodTypesTableAnnotationComposer get blood_type_id {
    final $$BloodTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.blood_type_id,
      referencedTable: $db.bloodTypes,
      getReferencedColumn: (t) => t.blood_type_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BloodTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.bloodTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AddressesTableAnnotationComposer get address_id {
    final $$AddressesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.address_id,
      referencedTable: $db.addresses,
      getReferencedColumn: (t) => t.address_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AddressesTableAnnotationComposer(
            $db: $db,
            $table: $db.addresses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MonthlyIncomesTableAnnotationComposer get monthly_income_id {
    final $$MonthlyIncomesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.monthly_income_id,
      referencedTable: $db.monthlyIncomes,
      getReferencedColumn: (t) => t.monthly_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MonthlyIncomesTableAnnotationComposer(
            $db: $db,
            $table: $db.monthlyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DailyIncomesTableAnnotationComposer get daily_income_id {
    final $$DailyIncomesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.daily_income_id,
      referencedTable: $db.dailyIncomes,
      getReferencedColumn: (t) => t.daily_income_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DailyIncomesTableAnnotationComposer(
            $db: $db,
            $table: $db.dailyIncomes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableAnnotationComposer get education_id {
    final $$EducationTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableAnnotationComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> occupationsRefs<T extends Object>(
    Expression<T> Function($$OccupationsTableAnnotationComposer a) f,
  ) {
    final $$OccupationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.occupations,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OccupationsTableAnnotationComposer(
            $db: $db,
            $table: $db.occupations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> emailsRefs<T extends Object>(
    Expression<T> Function($$EmailsTableAnnotationComposer a) f,
  ) {
    final $$EmailsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.emails,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EmailsTableAnnotationComposer(
            $db: $db,
            $table: $db.emails,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> phoneNumbersRefs<T extends Object>(
    Expression<T> Function($$PhoneNumbersTableAnnotationComposer a) f,
  ) {
    final $$PhoneNumbersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.phoneNumbers,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PhoneNumbersTableAnnotationComposer(
            $db: $db,
            $table: $db.phoneNumbers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> gadgetsRefs<T extends Object>(
    Expression<T> Function($$GadgetsTableAnnotationComposer a) f,
  ) {
    final $$GadgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.gadgets,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GadgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.gadgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> govermentProgramsRefs<T extends Object>(
    Expression<T> Function($$GovermentProgramsTableAnnotationComposer a) f,
  ) {
    final $$GovermentProgramsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.govermentPrograms,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$GovermentProgramsTableAnnotationComposer(
                $db: $db,
                $table: $db.govermentPrograms,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> voterRegistriesRefs<T extends Object>(
    Expression<T> Function($$VoterRegistriesTableAnnotationComposer a) f,
  ) {
    final $$VoterRegistriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.voterRegistries,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VoterRegistriesTableAnnotationComposer(
            $db: $db,
            $table: $db.voterRegistries,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> registeredSeniorsRefs<T extends Object>(
    Expression<T> Function($$RegisteredSeniorsTableAnnotationComposer a) f,
  ) {
    final $$RegisteredSeniorsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.registeredSeniors,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RegisteredSeniorsTableAnnotationComposer(
                $db: $db,
                $table: $db.registeredSeniors,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> disabilitiesRefs<T extends Object>(
    Expression<T> Function($$DisabilitiesTableAnnotationComposer a) f,
  ) {
    final $$DisabilitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.disabilities,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DisabilitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.disabilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> enrolledRefs<T extends Object>(
    Expression<T> Function($$EnrolledTableAnnotationComposer a) f,
  ) {
    final $$EnrolledTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.enrolled,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EnrolledTableAnnotationComposer(
            $db: $db,
            $table: $db.enrolled,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> cTCRecordsRefs<T extends Object>(
    Expression<T> Function($$CTCRecordsTableAnnotationComposer a) f,
  ) {
    final $$CTCRecordsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.cTCRecords,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CTCRecordsTableAnnotationComposer(
            $db: $db,
            $table: $db.cTCRecords,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> brgyHistoriesRefs<T extends Object>(
    Expression<T> Function($$BrgyHistoriesTableAnnotationComposer a) f,
  ) {
    final $$BrgyHistoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.brgyHistories,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrgyHistoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.brgyHistories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> migrantTransientsRefs<T extends Object>(
    Expression<T> Function($$MigrantTransientsTableAnnotationComposer a) f,
  ) {
    final $$MigrantTransientsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.migrantTransients,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$MigrantTransientsTableAnnotationComposer(
                $db: $db,
                $table: $db.migrantTransients,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> householdRelationshipsRefs<T extends Object>(
    Expression<T> Function($$HouseholdRelationshipsTableAnnotationComposer a) f,
  ) {
    final $$HouseholdRelationshipsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableAnnotationComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> fishingRefs<T extends Object>(
    Expression<T> Function($$FishingTableAnnotationComposer a) f,
  ) {
    final $$FishingTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.fishing,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingTableAnnotationComposer(
            $db: $db,
            $table: $db.fishing,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> agricultureRefs<T extends Object>(
    Expression<T> Function($$AgricultureTableAnnotationComposer a) f,
  ) {
    final $$AgricultureTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.agriculture,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgricultureTableAnnotationComposer(
            $db: $db,
            $table: $db.agriculture,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> livestockRefs<T extends Object>(
    Expression<T> Function($$LivestockTableAnnotationComposer a) f,
  ) {
    final $$LivestockTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.livestock,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockTableAnnotationComposer(
            $db: $db,
            $table: $db.livestock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> familyPlansRefs<T extends Object>(
    Expression<T> Function($$FamilyPlansTableAnnotationComposer a) f,
  ) {
    final $$FamilyPlansTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableAnnotationComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> maternalInfosRefs<T extends Object>(
    Expression<T> Function($$MaternalInfosTableAnnotationComposer a) f,
  ) {
    final $$MaternalInfosTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.maternalInfos,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MaternalInfosTableAnnotationComposer(
            $db: $db,
            $table: $db.maternalInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> visitedFacilitiesRefs<T extends Object>(
    Expression<T> Function($$VisitedFacilitiesTableAnnotationComposer a) f,
  ) {
    final $$VisitedFacilitiesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.person_id,
          referencedTable: $db.visitedFacilities,
          getReferencedColumn: (t) => t.person_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$VisitedFacilitiesTableAnnotationComposer(
                $db: $db,
                $table: $db.visitedFacilities,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> healthInsurancesRefs<T extends Object>(
    Expression<T> Function($$HealthInsurancesTableAnnotationComposer a) f,
  ) {
    final $$HealthInsurancesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.healthInsurances,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HealthInsurancesTableAnnotationComposer(
            $db: $db,
            $table: $db.healthInsurances,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> newbornInfosRefs<T extends Object>(
    Expression<T> Function($$NewbornInfosTableAnnotationComposer a) f,
  ) {
    final $$NewbornInfosTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableAnnotationComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PersonsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PersonsTable,
          PersonData,
          $$PersonsTableFilterComposer,
          $$PersonsTableOrderingComposer,
          $$PersonsTableAnnotationComposer,
          $$PersonsTableCreateCompanionBuilder,
          $$PersonsTableUpdateCompanionBuilder,
          (PersonData, $$PersonsTableReferences),
          PersonData,
          PrefetchHooks Function({
            bool religion_id,
            bool nationality_id,
            bool ethnicity_id,
            bool blood_type_id,
            bool household_id,
            bool address_id,
            bool monthly_income_id,
            bool daily_income_id,
            bool education_id,
            bool occupationsRefs,
            bool emailsRefs,
            bool phoneNumbersRefs,
            bool gadgetsRefs,
            bool govermentProgramsRefs,
            bool voterRegistriesRefs,
            bool registeredSeniorsRefs,
            bool disabilitiesRefs,
            bool enrolledRefs,
            bool cTCRecordsRefs,
            bool brgyHistoriesRefs,
            bool migrantTransientsRefs,
            bool householdRelationshipsRefs,
            bool fishingRefs,
            bool agricultureRefs,
            bool livestockRefs,
            bool familyPlansRefs,
            bool maternalInfosRefs,
            bool visitedFacilitiesRefs,
            bool healthInsurancesRefs,
            bool newbornInfosRefs,
          })
        > {
  $$PersonsTableTableManager(_$AppDatabase db, $PersonsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$PersonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$PersonsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$PersonsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> person_id = const Value.absent(),
                Value<String> last_name = const Value.absent(),
                Value<String> first_name = const Value.absent(),
                Value<String?> middle_name = const Value.absent(),
                Value<String?> suffix = const Value.absent(),
                Value<Sex?> sex = const Value.absent(),
                Value<int?> age = const Value.absent(),
                Value<DateTime?> birth_date = const Value.absent(),
                Value<String?> birth_place = const Value.absent(),
                Value<CivilStatus?> civil_status = const Value.absent(),
                Value<int?> religion_id = const Value.absent(),
                Value<int?> nationality_id = const Value.absent(),
                Value<int?> ethnicity_id = const Value.absent(),
                Value<int?> blood_type_id = const Value.absent(),
                Value<int?> household_id = const Value.absent(),
                Value<int?> address_id = const Value.absent(),
                Value<String?> registration_place = const Value.absent(),
                Value<Residency?> residency = const Value.absent(),
                Value<int?> years_of_residency = const Value.absent(),
                Value<Transient?> transient_type = const Value.absent(),
                Value<int?> monthly_income_id = const Value.absent(),
                Value<int?> daily_income_id = const Value.absent(),
                Value<SoloParent?> solo_parent = const Value.absent(),
                Value<bool?> ofw = const Value.absent(),
                Value<bool?> literate = const Value.absent(),
                Value<bool?> pwd = const Value.absent(),
                Value<bool?> registered_voter = const Value.absent(),
                Value<CurrentlyEnrolled?> currently_enrolled =
                    const Value.absent(),
                Value<int?> education_id = const Value.absent(),
                Value<bool?> deceased = const Value.absent(),
                Value<DateTime?> death_date = const Value.absent(),
                Value<DateTime?> registration_date = const Value.absent(),
                Value<RegistrationStatus> registration_status =
                    const Value.absent(),
              }) => PersonsCompanion(
                person_id: person_id,
                last_name: last_name,
                first_name: first_name,
                middle_name: middle_name,
                suffix: suffix,
                sex: sex,
                age: age,
                birth_date: birth_date,
                birth_place: birth_place,
                civil_status: civil_status,
                religion_id: religion_id,
                nationality_id: nationality_id,
                ethnicity_id: ethnicity_id,
                blood_type_id: blood_type_id,
                household_id: household_id,
                address_id: address_id,
                registration_place: registration_place,
                residency: residency,
                years_of_residency: years_of_residency,
                transient_type: transient_type,
                monthly_income_id: monthly_income_id,
                daily_income_id: daily_income_id,
                solo_parent: solo_parent,
                ofw: ofw,
                literate: literate,
                pwd: pwd,
                registered_voter: registered_voter,
                currently_enrolled: currently_enrolled,
                education_id: education_id,
                deceased: deceased,
                death_date: death_date,
                registration_date: registration_date,
                registration_status: registration_status,
              ),
          createCompanionCallback:
              ({
                Value<int> person_id = const Value.absent(),
                required String last_name,
                required String first_name,
                Value<String?> middle_name = const Value.absent(),
                Value<String?> suffix = const Value.absent(),
                Value<Sex?> sex = const Value.absent(),
                Value<int?> age = const Value.absent(),
                Value<DateTime?> birth_date = const Value.absent(),
                Value<String?> birth_place = const Value.absent(),
                Value<CivilStatus?> civil_status = const Value.absent(),
                Value<int?> religion_id = const Value.absent(),
                Value<int?> nationality_id = const Value.absent(),
                Value<int?> ethnicity_id = const Value.absent(),
                Value<int?> blood_type_id = const Value.absent(),
                Value<int?> household_id = const Value.absent(),
                Value<int?> address_id = const Value.absent(),
                Value<String?> registration_place = const Value.absent(),
                Value<Residency?> residency = const Value.absent(),
                Value<int?> years_of_residency = const Value.absent(),
                Value<Transient?> transient_type = const Value.absent(),
                Value<int?> monthly_income_id = const Value.absent(),
                Value<int?> daily_income_id = const Value.absent(),
                Value<SoloParent?> solo_parent = const Value.absent(),
                Value<bool?> ofw = const Value.absent(),
                Value<bool?> literate = const Value.absent(),
                Value<bool?> pwd = const Value.absent(),
                Value<bool?> registered_voter = const Value.absent(),
                Value<CurrentlyEnrolled?> currently_enrolled =
                    const Value.absent(),
                Value<int?> education_id = const Value.absent(),
                Value<bool?> deceased = const Value.absent(),
                Value<DateTime?> death_date = const Value.absent(),
                Value<DateTime?> registration_date = const Value.absent(),
                required RegistrationStatus registration_status,
              }) => PersonsCompanion.insert(
                person_id: person_id,
                last_name: last_name,
                first_name: first_name,
                middle_name: middle_name,
                suffix: suffix,
                sex: sex,
                age: age,
                birth_date: birth_date,
                birth_place: birth_place,
                civil_status: civil_status,
                religion_id: religion_id,
                nationality_id: nationality_id,
                ethnicity_id: ethnicity_id,
                blood_type_id: blood_type_id,
                household_id: household_id,
                address_id: address_id,
                registration_place: registration_place,
                residency: residency,
                years_of_residency: years_of_residency,
                transient_type: transient_type,
                monthly_income_id: monthly_income_id,
                daily_income_id: daily_income_id,
                solo_parent: solo_parent,
                ofw: ofw,
                literate: literate,
                pwd: pwd,
                registered_voter: registered_voter,
                currently_enrolled: currently_enrolled,
                education_id: education_id,
                deceased: deceased,
                death_date: death_date,
                registration_date: registration_date,
                registration_status: registration_status,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$PersonsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            religion_id = false,
            nationality_id = false,
            ethnicity_id = false,
            blood_type_id = false,
            household_id = false,
            address_id = false,
            monthly_income_id = false,
            daily_income_id = false,
            education_id = false,
            occupationsRefs = false,
            emailsRefs = false,
            phoneNumbersRefs = false,
            gadgetsRefs = false,
            govermentProgramsRefs = false,
            voterRegistriesRefs = false,
            registeredSeniorsRefs = false,
            disabilitiesRefs = false,
            enrolledRefs = false,
            cTCRecordsRefs = false,
            brgyHistoriesRefs = false,
            migrantTransientsRefs = false,
            householdRelationshipsRefs = false,
            fishingRefs = false,
            agricultureRefs = false,
            livestockRefs = false,
            familyPlansRefs = false,
            maternalInfosRefs = false,
            visitedFacilitiesRefs = false,
            healthInsurancesRefs = false,
            newbornInfosRefs = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (occupationsRefs) db.occupations,
                if (emailsRefs) db.emails,
                if (phoneNumbersRefs) db.phoneNumbers,
                if (gadgetsRefs) db.gadgets,
                if (govermentProgramsRefs) db.govermentPrograms,
                if (voterRegistriesRefs) db.voterRegistries,
                if (registeredSeniorsRefs) db.registeredSeniors,
                if (disabilitiesRefs) db.disabilities,
                if (enrolledRefs) db.enrolled,
                if (cTCRecordsRefs) db.cTCRecords,
                if (brgyHistoriesRefs) db.brgyHistories,
                if (migrantTransientsRefs) db.migrantTransients,
                if (householdRelationshipsRefs) db.householdRelationships,
                if (fishingRefs) db.fishing,
                if (agricultureRefs) db.agriculture,
                if (livestockRefs) db.livestock,
                if (familyPlansRefs) db.familyPlans,
                if (maternalInfosRefs) db.maternalInfos,
                if (visitedFacilitiesRefs) db.visitedFacilities,
                if (healthInsurancesRefs) db.healthInsurances,
                if (newbornInfosRefs) db.newbornInfos,
              ],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (religion_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.religion_id,
                            referencedTable: $$PersonsTableReferences
                                ._religion_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._religion_idTable(db)
                                    .religion_id,
                          )
                          as T;
                }
                if (nationality_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.nationality_id,
                            referencedTable: $$PersonsTableReferences
                                ._nationality_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._nationality_idTable(db)
                                    .nationality_id,
                          )
                          as T;
                }
                if (ethnicity_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.ethnicity_id,
                            referencedTable: $$PersonsTableReferences
                                ._ethnicity_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._ethnicity_idTable(db)
                                    .ethnicity_id,
                          )
                          as T;
                }
                if (blood_type_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.blood_type_id,
                            referencedTable: $$PersonsTableReferences
                                ._blood_type_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._blood_type_idTable(db)
                                    .blood_type_id,
                          )
                          as T;
                }
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$PersonsTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }
                if (address_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.address_id,
                            referencedTable: $$PersonsTableReferences
                                ._address_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._address_idTable(db)
                                    .address_id,
                          )
                          as T;
                }
                if (monthly_income_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.monthly_income_id,
                            referencedTable: $$PersonsTableReferences
                                ._monthly_income_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._monthly_income_idTable(db)
                                    .monthly_income_id,
                          )
                          as T;
                }
                if (daily_income_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.daily_income_id,
                            referencedTable: $$PersonsTableReferences
                                ._daily_income_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._daily_income_idTable(db)
                                    .daily_income_id,
                          )
                          as T;
                }
                if (education_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.education_id,
                            referencedTable: $$PersonsTableReferences
                                ._education_idTable(db),
                            referencedColumn:
                                $$PersonsTableReferences
                                    ._education_idTable(db)
                                    .education_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (occupationsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      OccupationData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._occupationsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).occupationsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (emailsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      EmailData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._emailsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).emailsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (phoneNumbersRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      PhoneNumberData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._phoneNumbersRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).phoneNumbersRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (gadgetsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      GadgetData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._gadgetsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).gadgetsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (govermentProgramsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      GovernmentProgramData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._govermentProgramsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).govermentProgramsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (voterRegistriesRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      VoterRegistryData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._voterRegistriesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).voterRegistriesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (registeredSeniorsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      RegisteredSeniorData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._registeredSeniorsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).registeredSeniorsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (disabilitiesRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      DisabilityData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._disabilitiesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).disabilitiesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (enrolledRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      EnrolledData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._enrolledRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).enrolledRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (cTCRecordsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      CTCRecordData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._cTCRecordsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).cTCRecordsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (brgyHistoriesRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      BrgyHistoryData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._brgyHistoriesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).brgyHistoriesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (migrantTransientsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      MigrantTransientData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._migrantTransientsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).migrantTransientsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (householdRelationshipsRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      HouseholdRelationship
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._householdRelationshipsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).householdRelationshipsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (fishingRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      FishingData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._fishingRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).fishingRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (agricultureRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      AgricultureData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._agricultureRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).agricultureRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (livestockRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      LivestockData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._livestockRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).livestockRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (familyPlansRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      FamilyPlanData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._familyPlansRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).familyPlansRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (maternalInfosRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      MaternalInfoData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._maternalInfosRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).maternalInfosRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (visitedFacilitiesRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      VisitedFacilityData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._visitedFacilitiesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).visitedFacilitiesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (healthInsurancesRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      HealthInsuranceData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._healthInsurancesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).healthInsurancesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                  if (newbornInfosRefs)
                    await $_getPrefetchedData<
                      PersonData,
                      $PersonsTable,
                      NewbornInfoData
                    >(
                      currentTable: table,
                      referencedTable: $$PersonsTableReferences
                          ._newbornInfosRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$PersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).newbornInfosRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.person_id == item.person_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$PersonsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PersonsTable,
      PersonData,
      $$PersonsTableFilterComposer,
      $$PersonsTableOrderingComposer,
      $$PersonsTableAnnotationComposer,
      $$PersonsTableCreateCompanionBuilder,
      $$PersonsTableUpdateCompanionBuilder,
      (PersonData, $$PersonsTableReferences),
      PersonData,
      PrefetchHooks Function({
        bool religion_id,
        bool nationality_id,
        bool ethnicity_id,
        bool blood_type_id,
        bool household_id,
        bool address_id,
        bool monthly_income_id,
        bool daily_income_id,
        bool education_id,
        bool occupationsRefs,
        bool emailsRefs,
        bool phoneNumbersRefs,
        bool gadgetsRefs,
        bool govermentProgramsRefs,
        bool voterRegistriesRefs,
        bool registeredSeniorsRefs,
        bool disabilitiesRefs,
        bool enrolledRefs,
        bool cTCRecordsRefs,
        bool brgyHistoriesRefs,
        bool migrantTransientsRefs,
        bool householdRelationshipsRefs,
        bool fishingRefs,
        bool agricultureRefs,
        bool livestockRefs,
        bool familyPlansRefs,
        bool maternalInfosRefs,
        bool visitedFacilitiesRefs,
        bool healthInsurancesRefs,
        bool newbornInfosRefs,
      })
    >;
typedef $$OccupationsTableCreateCompanionBuilder =
    OccupationsCompanion Function({
      Value<int> occupation_id,
      required int person_id,
      required String occupation,
      Value<OccupationType?> occupation_type,
      Value<OccupationStatus?> occupation_status,
      Value<String?> place,
    });
typedef $$OccupationsTableUpdateCompanionBuilder =
    OccupationsCompanion Function({
      Value<int> occupation_id,
      Value<int> person_id,
      Value<String> occupation,
      Value<OccupationType?> occupation_type,
      Value<OccupationStatus?> occupation_status,
      Value<String?> place,
    });

final class $$OccupationsTableReferences
    extends BaseReferences<_$AppDatabase, $OccupationsTable, OccupationData> {
  $$OccupationsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.occupations.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OccupationsTableFilterComposer
    extends Composer<_$AppDatabase, $OccupationsTable> {
  $$OccupationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get occupation_id => $composableBuilder(
    column: $table.occupation_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get occupation => $composableBuilder(
    column: $table.occupation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<OccupationType?, OccupationType, String>
  get occupation_type => $composableBuilder(
    column: $table.occupation_type,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnWithTypeConverterFilters<OccupationStatus?, OccupationStatus, String>
  get occupation_status => $composableBuilder(
    column: $table.occupation_status,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get place => $composableBuilder(
    column: $table.place,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OccupationsTableOrderingComposer
    extends Composer<_$AppDatabase, $OccupationsTable> {
  $$OccupationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get occupation_id => $composableBuilder(
    column: $table.occupation_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get occupation => $composableBuilder(
    column: $table.occupation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get occupation_type => $composableBuilder(
    column: $table.occupation_type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get occupation_status => $composableBuilder(
    column: $table.occupation_status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get place => $composableBuilder(
    column: $table.place,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OccupationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OccupationsTable> {
  $$OccupationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get occupation_id => $composableBuilder(
    column: $table.occupation_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get occupation => $composableBuilder(
    column: $table.occupation,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<OccupationType?, String>
  get occupation_type => $composableBuilder(
    column: $table.occupation_type,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<OccupationStatus?, String>
  get occupation_status => $composableBuilder(
    column: $table.occupation_status,
    builder: (column) => column,
  );

  GeneratedColumn<String> get place =>
      $composableBuilder(column: $table.place, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OccupationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OccupationsTable,
          OccupationData,
          $$OccupationsTableFilterComposer,
          $$OccupationsTableOrderingComposer,
          $$OccupationsTableAnnotationComposer,
          $$OccupationsTableCreateCompanionBuilder,
          $$OccupationsTableUpdateCompanionBuilder,
          (OccupationData, $$OccupationsTableReferences),
          OccupationData,
          PrefetchHooks Function({bool person_id})
        > {
  $$OccupationsTableTableManager(_$AppDatabase db, $OccupationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$OccupationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$OccupationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$OccupationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> occupation_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> occupation = const Value.absent(),
                Value<OccupationType?> occupation_type = const Value.absent(),
                Value<OccupationStatus?> occupation_status =
                    const Value.absent(),
                Value<String?> place = const Value.absent(),
              }) => OccupationsCompanion(
                occupation_id: occupation_id,
                person_id: person_id,
                occupation: occupation,
                occupation_type: occupation_type,
                occupation_status: occupation_status,
                place: place,
              ),
          createCompanionCallback:
              ({
                Value<int> occupation_id = const Value.absent(),
                required int person_id,
                required String occupation,
                Value<OccupationType?> occupation_type = const Value.absent(),
                Value<OccupationStatus?> occupation_status =
                    const Value.absent(),
                Value<String?> place = const Value.absent(),
              }) => OccupationsCompanion.insert(
                occupation_id: occupation_id,
                person_id: person_id,
                occupation: occupation,
                occupation_type: occupation_type,
                occupation_status: occupation_status,
                place: place,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$OccupationsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$OccupationsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$OccupationsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$OccupationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OccupationsTable,
      OccupationData,
      $$OccupationsTableFilterComposer,
      $$OccupationsTableOrderingComposer,
      $$OccupationsTableAnnotationComposer,
      $$OccupationsTableCreateCompanionBuilder,
      $$OccupationsTableUpdateCompanionBuilder,
      (OccupationData, $$OccupationsTableReferences),
      OccupationData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$EmailsTableCreateCompanionBuilder =
    EmailsCompanion Function({
      Value<int> email_id,
      required int person_id,
      required String email_address,
    });
typedef $$EmailsTableUpdateCompanionBuilder =
    EmailsCompanion Function({
      Value<int> email_id,
      Value<int> person_id,
      Value<String> email_address,
    });

final class $$EmailsTableReferences
    extends BaseReferences<_$AppDatabase, $EmailsTable, EmailData> {
  $$EmailsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.emails.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$EmailsTableFilterComposer
    extends Composer<_$AppDatabase, $EmailsTable> {
  $$EmailsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get email_id => $composableBuilder(
    column: $table.email_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email_address => $composableBuilder(
    column: $table.email_address,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EmailsTableOrderingComposer
    extends Composer<_$AppDatabase, $EmailsTable> {
  $$EmailsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get email_id => $composableBuilder(
    column: $table.email_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email_address => $composableBuilder(
    column: $table.email_address,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EmailsTableAnnotationComposer
    extends Composer<_$AppDatabase, $EmailsTable> {
  $$EmailsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get email_id =>
      $composableBuilder(column: $table.email_id, builder: (column) => column);

  GeneratedColumn<String> get email_address => $composableBuilder(
    column: $table.email_address,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EmailsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EmailsTable,
          EmailData,
          $$EmailsTableFilterComposer,
          $$EmailsTableOrderingComposer,
          $$EmailsTableAnnotationComposer,
          $$EmailsTableCreateCompanionBuilder,
          $$EmailsTableUpdateCompanionBuilder,
          (EmailData, $$EmailsTableReferences),
          EmailData,
          PrefetchHooks Function({bool person_id})
        > {
  $$EmailsTableTableManager(_$AppDatabase db, $EmailsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$EmailsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$EmailsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$EmailsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> email_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> email_address = const Value.absent(),
              }) => EmailsCompanion(
                email_id: email_id,
                person_id: person_id,
                email_address: email_address,
              ),
          createCompanionCallback:
              ({
                Value<int> email_id = const Value.absent(),
                required int person_id,
                required String email_address,
              }) => EmailsCompanion.insert(
                email_id: email_id,
                person_id: person_id,
                email_address: email_address,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$EmailsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$EmailsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$EmailsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$EmailsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EmailsTable,
      EmailData,
      $$EmailsTableFilterComposer,
      $$EmailsTableOrderingComposer,
      $$EmailsTableAnnotationComposer,
      $$EmailsTableCreateCompanionBuilder,
      $$EmailsTableUpdateCompanionBuilder,
      (EmailData, $$EmailsTableReferences),
      EmailData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$PhoneNumbersTableCreateCompanionBuilder =
    PhoneNumbersCompanion Function({
      Value<int> phone_number_id,
      required int person_id,
      required int phone_num,
    });
typedef $$PhoneNumbersTableUpdateCompanionBuilder =
    PhoneNumbersCompanion Function({
      Value<int> phone_number_id,
      Value<int> person_id,
      Value<int> phone_num,
    });

final class $$PhoneNumbersTableReferences
    extends BaseReferences<_$AppDatabase, $PhoneNumbersTable, PhoneNumberData> {
  $$PhoneNumbersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.phoneNumbers.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PhoneNumbersTableFilterComposer
    extends Composer<_$AppDatabase, $PhoneNumbersTable> {
  $$PhoneNumbersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get phone_number_id => $composableBuilder(
    column: $table.phone_number_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get phone_num => $composableBuilder(
    column: $table.phone_num,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PhoneNumbersTableOrderingComposer
    extends Composer<_$AppDatabase, $PhoneNumbersTable> {
  $$PhoneNumbersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get phone_number_id => $composableBuilder(
    column: $table.phone_number_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get phone_num => $composableBuilder(
    column: $table.phone_num,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PhoneNumbersTableAnnotationComposer
    extends Composer<_$AppDatabase, $PhoneNumbersTable> {
  $$PhoneNumbersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get phone_number_id => $composableBuilder(
    column: $table.phone_number_id,
    builder: (column) => column,
  );

  GeneratedColumn<int> get phone_num =>
      $composableBuilder(column: $table.phone_num, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PhoneNumbersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PhoneNumbersTable,
          PhoneNumberData,
          $$PhoneNumbersTableFilterComposer,
          $$PhoneNumbersTableOrderingComposer,
          $$PhoneNumbersTableAnnotationComposer,
          $$PhoneNumbersTableCreateCompanionBuilder,
          $$PhoneNumbersTableUpdateCompanionBuilder,
          (PhoneNumberData, $$PhoneNumbersTableReferences),
          PhoneNumberData,
          PrefetchHooks Function({bool person_id})
        > {
  $$PhoneNumbersTableTableManager(_$AppDatabase db, $PhoneNumbersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$PhoneNumbersTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$PhoneNumbersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$PhoneNumbersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> phone_number_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int> phone_num = const Value.absent(),
              }) => PhoneNumbersCompanion(
                phone_number_id: phone_number_id,
                person_id: person_id,
                phone_num: phone_num,
              ),
          createCompanionCallback:
              ({
                Value<int> phone_number_id = const Value.absent(),
                required int person_id,
                required int phone_num,
              }) => PhoneNumbersCompanion.insert(
                phone_number_id: phone_number_id,
                person_id: person_id,
                phone_num: phone_num,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$PhoneNumbersTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$PhoneNumbersTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$PhoneNumbersTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PhoneNumbersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PhoneNumbersTable,
      PhoneNumberData,
      $$PhoneNumbersTableFilterComposer,
      $$PhoneNumbersTableOrderingComposer,
      $$PhoneNumbersTableAnnotationComposer,
      $$PhoneNumbersTableCreateCompanionBuilder,
      $$PhoneNumbersTableUpdateCompanionBuilder,
      (PhoneNumberData, $$PhoneNumbersTableReferences),
      PhoneNumberData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$GadgetsTableCreateCompanionBuilder =
    GadgetsCompanion Function({
      Value<int> gadget_id,
      required int person_id,
      Value<Gadget?> gadget,
    });
typedef $$GadgetsTableUpdateCompanionBuilder =
    GadgetsCompanion Function({
      Value<int> gadget_id,
      Value<int> person_id,
      Value<Gadget?> gadget,
    });

final class $$GadgetsTableReferences
    extends BaseReferences<_$AppDatabase, $GadgetsTable, GadgetData> {
  $$GadgetsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.gadgets.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$GadgetsTableFilterComposer
    extends Composer<_$AppDatabase, $GadgetsTable> {
  $$GadgetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get gadget_id => $composableBuilder(
    column: $table.gadget_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Gadget?, Gadget, String> get gadget =>
      $composableBuilder(
        column: $table.gadget,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GadgetsTableOrderingComposer
    extends Composer<_$AppDatabase, $GadgetsTable> {
  $$GadgetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get gadget_id => $composableBuilder(
    column: $table.gadget_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get gadget => $composableBuilder(
    column: $table.gadget,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GadgetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $GadgetsTable> {
  $$GadgetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get gadget_id =>
      $composableBuilder(column: $table.gadget_id, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Gadget?, String> get gadget =>
      $composableBuilder(column: $table.gadget, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GadgetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GadgetsTable,
          GadgetData,
          $$GadgetsTableFilterComposer,
          $$GadgetsTableOrderingComposer,
          $$GadgetsTableAnnotationComposer,
          $$GadgetsTableCreateCompanionBuilder,
          $$GadgetsTableUpdateCompanionBuilder,
          (GadgetData, $$GadgetsTableReferences),
          GadgetData,
          PrefetchHooks Function({bool person_id})
        > {
  $$GadgetsTableTableManager(_$AppDatabase db, $GadgetsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$GadgetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$GadgetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$GadgetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> gadget_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<Gadget?> gadget = const Value.absent(),
              }) => GadgetsCompanion(
                gadget_id: gadget_id,
                person_id: person_id,
                gadget: gadget,
              ),
          createCompanionCallback:
              ({
                Value<int> gadget_id = const Value.absent(),
                required int person_id,
                Value<Gadget?> gadget = const Value.absent(),
              }) => GadgetsCompanion.insert(
                gadget_id: gadget_id,
                person_id: person_id,
                gadget: gadget,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$GadgetsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$GadgetsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$GadgetsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$GadgetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GadgetsTable,
      GadgetData,
      $$GadgetsTableFilterComposer,
      $$GadgetsTableOrderingComposer,
      $$GadgetsTableAnnotationComposer,
      $$GadgetsTableCreateCompanionBuilder,
      $$GadgetsTableUpdateCompanionBuilder,
      (GadgetData, $$GadgetsTableReferences),
      GadgetData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$GovermentProgramsTableCreateCompanionBuilder =
    GovermentProgramsCompanion Function({
      Value<int> government_program_id,
      required int person_id,
      required String name,
    });
typedef $$GovermentProgramsTableUpdateCompanionBuilder =
    GovermentProgramsCompanion Function({
      Value<int> government_program_id,
      Value<int> person_id,
      Value<String> name,
    });

final class $$GovermentProgramsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $GovermentProgramsTable,
          GovernmentProgramData
        > {
  $$GovermentProgramsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.govermentPrograms.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$GovermentProgramsTableFilterComposer
    extends Composer<_$AppDatabase, $GovermentProgramsTable> {
  $$GovermentProgramsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get government_program_id => $composableBuilder(
    column: $table.government_program_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GovermentProgramsTableOrderingComposer
    extends Composer<_$AppDatabase, $GovermentProgramsTable> {
  $$GovermentProgramsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get government_program_id => $composableBuilder(
    column: $table.government_program_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GovermentProgramsTableAnnotationComposer
    extends Composer<_$AppDatabase, $GovermentProgramsTable> {
  $$GovermentProgramsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get government_program_id => $composableBuilder(
    column: $table.government_program_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GovermentProgramsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GovermentProgramsTable,
          GovernmentProgramData,
          $$GovermentProgramsTableFilterComposer,
          $$GovermentProgramsTableOrderingComposer,
          $$GovermentProgramsTableAnnotationComposer,
          $$GovermentProgramsTableCreateCompanionBuilder,
          $$GovermentProgramsTableUpdateCompanionBuilder,
          (GovernmentProgramData, $$GovermentProgramsTableReferences),
          GovernmentProgramData,
          PrefetchHooks Function({bool person_id})
        > {
  $$GovermentProgramsTableTableManager(
    _$AppDatabase db,
    $GovermentProgramsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$GovermentProgramsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$GovermentProgramsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$GovermentProgramsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> government_program_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => GovermentProgramsCompanion(
                government_program_id: government_program_id,
                person_id: person_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> government_program_id = const Value.absent(),
                required int person_id,
                required String name,
              }) => GovermentProgramsCompanion.insert(
                government_program_id: government_program_id,
                person_id: person_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$GovermentProgramsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$GovermentProgramsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$GovermentProgramsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$GovermentProgramsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GovermentProgramsTable,
      GovernmentProgramData,
      $$GovermentProgramsTableFilterComposer,
      $$GovermentProgramsTableOrderingComposer,
      $$GovermentProgramsTableAnnotationComposer,
      $$GovermentProgramsTableCreateCompanionBuilder,
      $$GovermentProgramsTableUpdateCompanionBuilder,
      (GovernmentProgramData, $$GovermentProgramsTableReferences),
      GovernmentProgramData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$VoterRegistriesTableCreateCompanionBuilder =
    VoterRegistriesCompanion Function({
      Value<int> voter_registry_id,
      required int person_id,
      required String place_of_vote_registry,
    });
typedef $$VoterRegistriesTableUpdateCompanionBuilder =
    VoterRegistriesCompanion Function({
      Value<int> voter_registry_id,
      Value<int> person_id,
      Value<String> place_of_vote_registry,
    });

final class $$VoterRegistriesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $VoterRegistriesTable,
          VoterRegistryData
        > {
  $$VoterRegistriesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.voterRegistries.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$VoterRegistriesTableFilterComposer
    extends Composer<_$AppDatabase, $VoterRegistriesTable> {
  $$VoterRegistriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get voter_registry_id => $composableBuilder(
    column: $table.voter_registry_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get place_of_vote_registry => $composableBuilder(
    column: $table.place_of_vote_registry,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VoterRegistriesTableOrderingComposer
    extends Composer<_$AppDatabase, $VoterRegistriesTable> {
  $$VoterRegistriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get voter_registry_id => $composableBuilder(
    column: $table.voter_registry_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get place_of_vote_registry => $composableBuilder(
    column: $table.place_of_vote_registry,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VoterRegistriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VoterRegistriesTable> {
  $$VoterRegistriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get voter_registry_id => $composableBuilder(
    column: $table.voter_registry_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get place_of_vote_registry => $composableBuilder(
    column: $table.place_of_vote_registry,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VoterRegistriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VoterRegistriesTable,
          VoterRegistryData,
          $$VoterRegistriesTableFilterComposer,
          $$VoterRegistriesTableOrderingComposer,
          $$VoterRegistriesTableAnnotationComposer,
          $$VoterRegistriesTableCreateCompanionBuilder,
          $$VoterRegistriesTableUpdateCompanionBuilder,
          (VoterRegistryData, $$VoterRegistriesTableReferences),
          VoterRegistryData,
          PrefetchHooks Function({bool person_id})
        > {
  $$VoterRegistriesTableTableManager(
    _$AppDatabase db,
    $VoterRegistriesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$VoterRegistriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$VoterRegistriesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$VoterRegistriesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> voter_registry_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> place_of_vote_registry = const Value.absent(),
              }) => VoterRegistriesCompanion(
                voter_registry_id: voter_registry_id,
                person_id: person_id,
                place_of_vote_registry: place_of_vote_registry,
              ),
          createCompanionCallback:
              ({
                Value<int> voter_registry_id = const Value.absent(),
                required int person_id,
                required String place_of_vote_registry,
              }) => VoterRegistriesCompanion.insert(
                voter_registry_id: voter_registry_id,
                person_id: person_id,
                place_of_vote_registry: place_of_vote_registry,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$VoterRegistriesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$VoterRegistriesTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$VoterRegistriesTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$VoterRegistriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VoterRegistriesTable,
      VoterRegistryData,
      $$VoterRegistriesTableFilterComposer,
      $$VoterRegistriesTableOrderingComposer,
      $$VoterRegistriesTableAnnotationComposer,
      $$VoterRegistriesTableCreateCompanionBuilder,
      $$VoterRegistriesTableUpdateCompanionBuilder,
      (VoterRegistryData, $$VoterRegistriesTableReferences),
      VoterRegistryData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$RegisteredSeniorsTableCreateCompanionBuilder =
    RegisteredSeniorsCompanion Function({
      Value<int> registered_senior_id,
      required int person_id,
    });
typedef $$RegisteredSeniorsTableUpdateCompanionBuilder =
    RegisteredSeniorsCompanion Function({
      Value<int> registered_senior_id,
      Value<int> person_id,
    });

final class $$RegisteredSeniorsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $RegisteredSeniorsTable,
          RegisteredSeniorData
        > {
  $$RegisteredSeniorsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.registeredSeniors.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$RegisteredSeniorsTableFilterComposer
    extends Composer<_$AppDatabase, $RegisteredSeniorsTable> {
  $$RegisteredSeniorsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get registered_senior_id => $composableBuilder(
    column: $table.registered_senior_id,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RegisteredSeniorsTableOrderingComposer
    extends Composer<_$AppDatabase, $RegisteredSeniorsTable> {
  $$RegisteredSeniorsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get registered_senior_id => $composableBuilder(
    column: $table.registered_senior_id,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RegisteredSeniorsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RegisteredSeniorsTable> {
  $$RegisteredSeniorsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get registered_senior_id => $composableBuilder(
    column: $table.registered_senior_id,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RegisteredSeniorsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RegisteredSeniorsTable,
          RegisteredSeniorData,
          $$RegisteredSeniorsTableFilterComposer,
          $$RegisteredSeniorsTableOrderingComposer,
          $$RegisteredSeniorsTableAnnotationComposer,
          $$RegisteredSeniorsTableCreateCompanionBuilder,
          $$RegisteredSeniorsTableUpdateCompanionBuilder,
          (RegisteredSeniorData, $$RegisteredSeniorsTableReferences),
          RegisteredSeniorData,
          PrefetchHooks Function({bool person_id})
        > {
  $$RegisteredSeniorsTableTableManager(
    _$AppDatabase db,
    $RegisteredSeniorsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$RegisteredSeniorsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$RegisteredSeniorsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$RegisteredSeniorsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> registered_senior_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
              }) => RegisteredSeniorsCompanion(
                registered_senior_id: registered_senior_id,
                person_id: person_id,
              ),
          createCompanionCallback:
              ({
                Value<int> registered_senior_id = const Value.absent(),
                required int person_id,
              }) => RegisteredSeniorsCompanion.insert(
                registered_senior_id: registered_senior_id,
                person_id: person_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$RegisteredSeniorsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$RegisteredSeniorsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$RegisteredSeniorsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$RegisteredSeniorsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RegisteredSeniorsTable,
      RegisteredSeniorData,
      $$RegisteredSeniorsTableFilterComposer,
      $$RegisteredSeniorsTableOrderingComposer,
      $$RegisteredSeniorsTableAnnotationComposer,
      $$RegisteredSeniorsTableCreateCompanionBuilder,
      $$RegisteredSeniorsTableUpdateCompanionBuilder,
      (RegisteredSeniorData, $$RegisteredSeniorsTableReferences),
      RegisteredSeniorData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$DisabilitiesTableCreateCompanionBuilder =
    DisabilitiesCompanion Function({
      Value<int> disability_id,
      required int person_id,
      required String name,
      Value<String?> type,
    });
typedef $$DisabilitiesTableUpdateCompanionBuilder =
    DisabilitiesCompanion Function({
      Value<int> disability_id,
      Value<int> person_id,
      Value<String> name,
      Value<String?> type,
    });

final class $$DisabilitiesTableReferences
    extends BaseReferences<_$AppDatabase, $DisabilitiesTable, DisabilityData> {
  $$DisabilitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.disabilities.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$DisabilitiesTableFilterComposer
    extends Composer<_$AppDatabase, $DisabilitiesTable> {
  $$DisabilitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DisabilitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $DisabilitiesTable> {
  $$DisabilitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DisabilitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DisabilitiesTable> {
  $$DisabilitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$DisabilitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DisabilitiesTable,
          DisabilityData,
          $$DisabilitiesTableFilterComposer,
          $$DisabilitiesTableOrderingComposer,
          $$DisabilitiesTableAnnotationComposer,
          $$DisabilitiesTableCreateCompanionBuilder,
          $$DisabilitiesTableUpdateCompanionBuilder,
          (DisabilityData, $$DisabilitiesTableReferences),
          DisabilityData,
          PrefetchHooks Function({bool person_id})
        > {
  $$DisabilitiesTableTableManager(_$AppDatabase db, $DisabilitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$DisabilitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$DisabilitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$DisabilitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> disability_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> type = const Value.absent(),
              }) => DisabilitiesCompanion(
                disability_id: disability_id,
                person_id: person_id,
                name: name,
                type: type,
              ),
          createCompanionCallback:
              ({
                Value<int> disability_id = const Value.absent(),
                required int person_id,
                required String name,
                Value<String?> type = const Value.absent(),
              }) => DisabilitiesCompanion.insert(
                disability_id: disability_id,
                person_id: person_id,
                name: name,
                type: type,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$DisabilitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$DisabilitiesTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$DisabilitiesTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$DisabilitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DisabilitiesTable,
      DisabilityData,
      $$DisabilitiesTableFilterComposer,
      $$DisabilitiesTableOrderingComposer,
      $$DisabilitiesTableAnnotationComposer,
      $$DisabilitiesTableCreateCompanionBuilder,
      $$DisabilitiesTableUpdateCompanionBuilder,
      (DisabilityData, $$DisabilitiesTableReferences),
      DisabilityData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$EnrolledTableCreateCompanionBuilder =
    EnrolledCompanion Function({
      Value<int> enrolled_id,
      required int person_id,
      required String school,
      required int education_id,
    });
typedef $$EnrolledTableUpdateCompanionBuilder =
    EnrolledCompanion Function({
      Value<int> enrolled_id,
      Value<int> person_id,
      Value<String> school,
      Value<int> education_id,
    });

final class $$EnrolledTableReferences
    extends BaseReferences<_$AppDatabase, $EnrolledTable, EnrolledData> {
  $$EnrolledTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.enrolled.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $EducationTable _education_idTable(_$AppDatabase db) =>
      db.education.createAlias(
        $_aliasNameGenerator(
          db.enrolled.education_id,
          db.education.education_id,
        ),
      );

  $$EducationTableProcessedTableManager get education_id {
    final $_column = $_itemColumn<int>('education_id')!;

    final manager = $$EducationTableTableManager(
      $_db,
      $_db.education,
    ).filter((f) => f.education_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_education_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$EnrolledTableFilterComposer
    extends Composer<_$AppDatabase, $EnrolledTable> {
  $$EnrolledTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get enrolled_id => $composableBuilder(
    column: $table.enrolled_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get school => $composableBuilder(
    column: $table.school,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableFilterComposer get education_id {
    final $$EducationTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableFilterComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EnrolledTableOrderingComposer
    extends Composer<_$AppDatabase, $EnrolledTable> {
  $$EnrolledTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get enrolled_id => $composableBuilder(
    column: $table.enrolled_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get school => $composableBuilder(
    column: $table.school,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableOrderingComposer get education_id {
    final $$EducationTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableOrderingComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EnrolledTableAnnotationComposer
    extends Composer<_$AppDatabase, $EnrolledTable> {
  $$EnrolledTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get enrolled_id => $composableBuilder(
    column: $table.enrolled_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get school =>
      $composableBuilder(column: $table.school, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$EducationTableAnnotationComposer get education_id {
    final $$EducationTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.education_id,
      referencedTable: $db.education,
      getReferencedColumn: (t) => t.education_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$EducationTableAnnotationComposer(
            $db: $db,
            $table: $db.education,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$EnrolledTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EnrolledTable,
          EnrolledData,
          $$EnrolledTableFilterComposer,
          $$EnrolledTableOrderingComposer,
          $$EnrolledTableAnnotationComposer,
          $$EnrolledTableCreateCompanionBuilder,
          $$EnrolledTableUpdateCompanionBuilder,
          (EnrolledData, $$EnrolledTableReferences),
          EnrolledData,
          PrefetchHooks Function({bool person_id, bool education_id})
        > {
  $$EnrolledTableTableManager(_$AppDatabase db, $EnrolledTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$EnrolledTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$EnrolledTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$EnrolledTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> enrolled_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> school = const Value.absent(),
                Value<int> education_id = const Value.absent(),
              }) => EnrolledCompanion(
                enrolled_id: enrolled_id,
                person_id: person_id,
                school: school,
                education_id: education_id,
              ),
          createCompanionCallback:
              ({
                Value<int> enrolled_id = const Value.absent(),
                required int person_id,
                required String school,
                required int education_id,
              }) => EnrolledCompanion.insert(
                enrolled_id: enrolled_id,
                person_id: person_id,
                school: school,
                education_id: education_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$EnrolledTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false, education_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$EnrolledTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$EnrolledTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (education_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.education_id,
                            referencedTable: $$EnrolledTableReferences
                                ._education_idTable(db),
                            referencedColumn:
                                $$EnrolledTableReferences
                                    ._education_idTable(db)
                                    .education_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$EnrolledTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EnrolledTable,
      EnrolledData,
      $$EnrolledTableFilterComposer,
      $$EnrolledTableOrderingComposer,
      $$EnrolledTableAnnotationComposer,
      $$EnrolledTableCreateCompanionBuilder,
      $$EnrolledTableUpdateCompanionBuilder,
      (EnrolledData, $$EnrolledTableReferences),
      EnrolledData,
      PrefetchHooks Function({bool person_id, bool education_id})
    >;
typedef $$CTCRecordsTableCreateCompanionBuilder =
    CTCRecordsCompanion Function({
      Value<int> ctc_record_id,
      required int person_id,
      required int issue_num,
      Value<String?> place_of_issue,
      Value<DateTime?> date_of_issue,
    });
typedef $$CTCRecordsTableUpdateCompanionBuilder =
    CTCRecordsCompanion Function({
      Value<int> ctc_record_id,
      Value<int> person_id,
      Value<int> issue_num,
      Value<String?> place_of_issue,
      Value<DateTime?> date_of_issue,
    });

final class $$CTCRecordsTableReferences
    extends BaseReferences<_$AppDatabase, $CTCRecordsTable, CTCRecordData> {
  $$CTCRecordsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.cTCRecords.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CTCRecordsTableFilterComposer
    extends Composer<_$AppDatabase, $CTCRecordsTable> {
  $$CTCRecordsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get ctc_record_id => $composableBuilder(
    column: $table.ctc_record_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get issue_num => $composableBuilder(
    column: $table.issue_num,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get place_of_issue => $composableBuilder(
    column: $table.place_of_issue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date_of_issue => $composableBuilder(
    column: $table.date_of_issue,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CTCRecordsTableOrderingComposer
    extends Composer<_$AppDatabase, $CTCRecordsTable> {
  $$CTCRecordsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get ctc_record_id => $composableBuilder(
    column: $table.ctc_record_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get issue_num => $composableBuilder(
    column: $table.issue_num,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get place_of_issue => $composableBuilder(
    column: $table.place_of_issue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date_of_issue => $composableBuilder(
    column: $table.date_of_issue,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CTCRecordsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CTCRecordsTable> {
  $$CTCRecordsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get ctc_record_id => $composableBuilder(
    column: $table.ctc_record_id,
    builder: (column) => column,
  );

  GeneratedColumn<int> get issue_num =>
      $composableBuilder(column: $table.issue_num, builder: (column) => column);

  GeneratedColumn<String> get place_of_issue => $composableBuilder(
    column: $table.place_of_issue,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get date_of_issue => $composableBuilder(
    column: $table.date_of_issue,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CTCRecordsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CTCRecordsTable,
          CTCRecordData,
          $$CTCRecordsTableFilterComposer,
          $$CTCRecordsTableOrderingComposer,
          $$CTCRecordsTableAnnotationComposer,
          $$CTCRecordsTableCreateCompanionBuilder,
          $$CTCRecordsTableUpdateCompanionBuilder,
          (CTCRecordData, $$CTCRecordsTableReferences),
          CTCRecordData,
          PrefetchHooks Function({bool person_id})
        > {
  $$CTCRecordsTableTableManager(_$AppDatabase db, $CTCRecordsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$CTCRecordsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$CTCRecordsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$CTCRecordsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> ctc_record_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int> issue_num = const Value.absent(),
                Value<String?> place_of_issue = const Value.absent(),
                Value<DateTime?> date_of_issue = const Value.absent(),
              }) => CTCRecordsCompanion(
                ctc_record_id: ctc_record_id,
                person_id: person_id,
                issue_num: issue_num,
                place_of_issue: place_of_issue,
                date_of_issue: date_of_issue,
              ),
          createCompanionCallback:
              ({
                Value<int> ctc_record_id = const Value.absent(),
                required int person_id,
                required int issue_num,
                Value<String?> place_of_issue = const Value.absent(),
                Value<DateTime?> date_of_issue = const Value.absent(),
              }) => CTCRecordsCompanion.insert(
                ctc_record_id: ctc_record_id,
                person_id: person_id,
                issue_num: issue_num,
                place_of_issue: place_of_issue,
                date_of_issue: date_of_issue,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$CTCRecordsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$CTCRecordsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$CTCRecordsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CTCRecordsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CTCRecordsTable,
      CTCRecordData,
      $$CTCRecordsTableFilterComposer,
      $$CTCRecordsTableOrderingComposer,
      $$CTCRecordsTableAnnotationComposer,
      $$CTCRecordsTableCreateCompanionBuilder,
      $$CTCRecordsTableUpdateCompanionBuilder,
      (CTCRecordData, $$CTCRecordsTableReferences),
      CTCRecordData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$BrgyHistoriesTableCreateCompanionBuilder =
    BrgyHistoriesCompanion Function({
      Value<int> disability_id,
      required int person_id,
      Value<DateTime?> start_date,
      Value<DateTime?> end_date,
      required String brgy,
    });
typedef $$BrgyHistoriesTableUpdateCompanionBuilder =
    BrgyHistoriesCompanion Function({
      Value<int> disability_id,
      Value<int> person_id,
      Value<DateTime?> start_date,
      Value<DateTime?> end_date,
      Value<String> brgy,
    });

final class $$BrgyHistoriesTableReferences
    extends
        BaseReferences<_$AppDatabase, $BrgyHistoriesTable, BrgyHistoryData> {
  $$BrgyHistoriesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.brgyHistories.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BrgyHistoriesTableFilterComposer
    extends Composer<_$AppDatabase, $BrgyHistoriesTable> {
  $$BrgyHistoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get start_date => $composableBuilder(
    column: $table.start_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get end_date => $composableBuilder(
    column: $table.end_date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brgy => $composableBuilder(
    column: $table.brgy,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrgyHistoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $BrgyHistoriesTable> {
  $$BrgyHistoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get start_date => $composableBuilder(
    column: $table.start_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get end_date => $composableBuilder(
    column: $table.end_date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brgy => $composableBuilder(
    column: $table.brgy,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrgyHistoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $BrgyHistoriesTable> {
  $$BrgyHistoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get disability_id => $composableBuilder(
    column: $table.disability_id,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get start_date => $composableBuilder(
    column: $table.start_date,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get end_date =>
      $composableBuilder(column: $table.end_date, builder: (column) => column);

  GeneratedColumn<String> get brgy =>
      $composableBuilder(column: $table.brgy, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrgyHistoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BrgyHistoriesTable,
          BrgyHistoryData,
          $$BrgyHistoriesTableFilterComposer,
          $$BrgyHistoriesTableOrderingComposer,
          $$BrgyHistoriesTableAnnotationComposer,
          $$BrgyHistoriesTableCreateCompanionBuilder,
          $$BrgyHistoriesTableUpdateCompanionBuilder,
          (BrgyHistoryData, $$BrgyHistoriesTableReferences),
          BrgyHistoryData,
          PrefetchHooks Function({bool person_id})
        > {
  $$BrgyHistoriesTableTableManager(_$AppDatabase db, $BrgyHistoriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$BrgyHistoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$BrgyHistoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$BrgyHistoriesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> disability_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<DateTime?> start_date = const Value.absent(),
                Value<DateTime?> end_date = const Value.absent(),
                Value<String> brgy = const Value.absent(),
              }) => BrgyHistoriesCompanion(
                disability_id: disability_id,
                person_id: person_id,
                start_date: start_date,
                end_date: end_date,
                brgy: brgy,
              ),
          createCompanionCallback:
              ({
                Value<int> disability_id = const Value.absent(),
                required int person_id,
                Value<DateTime?> start_date = const Value.absent(),
                Value<DateTime?> end_date = const Value.absent(),
                required String brgy,
              }) => BrgyHistoriesCompanion.insert(
                disability_id: disability_id,
                person_id: person_id,
                start_date: start_date,
                end_date: end_date,
                brgy: brgy,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$BrgyHistoriesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$BrgyHistoriesTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$BrgyHistoriesTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BrgyHistoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BrgyHistoriesTable,
      BrgyHistoryData,
      $$BrgyHistoriesTableFilterComposer,
      $$BrgyHistoriesTableOrderingComposer,
      $$BrgyHistoriesTableAnnotationComposer,
      $$BrgyHistoriesTableCreateCompanionBuilder,
      $$BrgyHistoriesTableUpdateCompanionBuilder,
      (BrgyHistoryData, $$BrgyHistoriesTableReferences),
      BrgyHistoryData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$MigrantTransientsTableCreateCompanionBuilder =
    MigrantTransientsCompanion Function({
      Value<int> migrant_transient_id,
      required int person_id,
      Value<DateTime?> date,
      Value<Transient?> type,
      Value<String?> reason_of_leaving,
      Value<String?> reason_of_transfer,
      Value<int?> stay_duration,
    });
typedef $$MigrantTransientsTableUpdateCompanionBuilder =
    MigrantTransientsCompanion Function({
      Value<int> migrant_transient_id,
      Value<int> person_id,
      Value<DateTime?> date,
      Value<Transient?> type,
      Value<String?> reason_of_leaving,
      Value<String?> reason_of_transfer,
      Value<int?> stay_duration,
    });

final class $$MigrantTransientsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $MigrantTransientsTable,
          MigrantTransientData
        > {
  $$MigrantTransientsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.migrantTransients.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$MigrantTransientsTableFilterComposer
    extends Composer<_$AppDatabase, $MigrantTransientsTable> {
  $$MigrantTransientsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get migrant_transient_id => $composableBuilder(
    column: $table.migrant_transient_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Transient?, Transient, String> get type =>
      $composableBuilder(
        column: $table.type,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<String> get reason_of_leaving => $composableBuilder(
    column: $table.reason_of_leaving,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason_of_transfer => $composableBuilder(
    column: $table.reason_of_transfer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get stay_duration => $composableBuilder(
    column: $table.stay_duration,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MigrantTransientsTableOrderingComposer
    extends Composer<_$AppDatabase, $MigrantTransientsTable> {
  $$MigrantTransientsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get migrant_transient_id => $composableBuilder(
    column: $table.migrant_transient_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason_of_leaving => $composableBuilder(
    column: $table.reason_of_leaving,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason_of_transfer => $composableBuilder(
    column: $table.reason_of_transfer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get stay_duration => $composableBuilder(
    column: $table.stay_duration,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MigrantTransientsTableAnnotationComposer
    extends Composer<_$AppDatabase, $MigrantTransientsTable> {
  $$MigrantTransientsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get migrant_transient_id => $composableBuilder(
    column: $table.migrant_transient_id,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Transient?, String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get reason_of_leaving => $composableBuilder(
    column: $table.reason_of_leaving,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reason_of_transfer => $composableBuilder(
    column: $table.reason_of_transfer,
    builder: (column) => column,
  );

  GeneratedColumn<int> get stay_duration => $composableBuilder(
    column: $table.stay_duration,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MigrantTransientsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MigrantTransientsTable,
          MigrantTransientData,
          $$MigrantTransientsTableFilterComposer,
          $$MigrantTransientsTableOrderingComposer,
          $$MigrantTransientsTableAnnotationComposer,
          $$MigrantTransientsTableCreateCompanionBuilder,
          $$MigrantTransientsTableUpdateCompanionBuilder,
          (MigrantTransientData, $$MigrantTransientsTableReferences),
          MigrantTransientData,
          PrefetchHooks Function({bool person_id})
        > {
  $$MigrantTransientsTableTableManager(
    _$AppDatabase db,
    $MigrantTransientsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$MigrantTransientsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$MigrantTransientsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$MigrantTransientsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> migrant_transient_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<DateTime?> date = const Value.absent(),
                Value<Transient?> type = const Value.absent(),
                Value<String?> reason_of_leaving = const Value.absent(),
                Value<String?> reason_of_transfer = const Value.absent(),
                Value<int?> stay_duration = const Value.absent(),
              }) => MigrantTransientsCompanion(
                migrant_transient_id: migrant_transient_id,
                person_id: person_id,
                date: date,
                type: type,
                reason_of_leaving: reason_of_leaving,
                reason_of_transfer: reason_of_transfer,
                stay_duration: stay_duration,
              ),
          createCompanionCallback:
              ({
                Value<int> migrant_transient_id = const Value.absent(),
                required int person_id,
                Value<DateTime?> date = const Value.absent(),
                Value<Transient?> type = const Value.absent(),
                Value<String?> reason_of_leaving = const Value.absent(),
                Value<String?> reason_of_transfer = const Value.absent(),
                Value<int?> stay_duration = const Value.absent(),
              }) => MigrantTransientsCompanion.insert(
                migrant_transient_id: migrant_transient_id,
                person_id: person_id,
                date: date,
                type: type,
                reason_of_leaving: reason_of_leaving,
                reason_of_transfer: reason_of_transfer,
                stay_duration: stay_duration,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$MigrantTransientsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$MigrantTransientsTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$MigrantTransientsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$MigrantTransientsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MigrantTransientsTable,
      MigrantTransientData,
      $$MigrantTransientsTableFilterComposer,
      $$MigrantTransientsTableOrderingComposer,
      $$MigrantTransientsTableAnnotationComposer,
      $$MigrantTransientsTableCreateCompanionBuilder,
      $$MigrantTransientsTableUpdateCompanionBuilder,
      (MigrantTransientData, $$MigrantTransientsTableReferences),
      MigrantTransientData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$RelationshipTypesTableCreateCompanionBuilder =
    RelationshipTypesCompanion Function({
      Value<int> relationship_id,
      required String relationship,
    });
typedef $$RelationshipTypesTableUpdateCompanionBuilder =
    RelationshipTypesCompanion Function({
      Value<int> relationship_id,
      Value<String> relationship,
    });

final class $$RelationshipTypesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $RelationshipTypesTable,
          RelationshipTypeData
        > {
  $$RelationshipTypesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<
    $HouseholdRelationshipsTable,
    List<HouseholdRelationship>
  >
  _householdRelationshipsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.householdRelationships,
        aliasName: $_aliasNameGenerator(
          db.relationshipTypes.relationship_id,
          db.householdRelationships.relationship_id,
        ),
      );

  $$HouseholdRelationshipsTableProcessedTableManager
  get householdRelationshipsRefs {
    final manager = $$HouseholdRelationshipsTableTableManager(
      $_db,
      $_db.householdRelationships,
    ).filter(
      (f) => f.relationship_id.relationship_id.sqlEquals(
        $_itemColumn<int>('relationship_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _householdRelationshipsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RelationshipTypesTableFilterComposer
    extends Composer<_$AppDatabase, $RelationshipTypesTable> {
  $$RelationshipTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get relationship_id => $composableBuilder(
    column: $table.relationship_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get relationship => $composableBuilder(
    column: $table.relationship,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> householdRelationshipsRefs(
    Expression<bool> Function($$HouseholdRelationshipsTableFilterComposer f) f,
  ) {
    final $$HouseholdRelationshipsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.relationship_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.relationship_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableFilterComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$RelationshipTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $RelationshipTypesTable> {
  $$RelationshipTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get relationship_id => $composableBuilder(
    column: $table.relationship_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get relationship => $composableBuilder(
    column: $table.relationship,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RelationshipTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RelationshipTypesTable> {
  $$RelationshipTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get relationship_id => $composableBuilder(
    column: $table.relationship_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get relationship => $composableBuilder(
    column: $table.relationship,
    builder: (column) => column,
  );

  Expression<T> householdRelationshipsRefs<T extends Object>(
    Expression<T> Function($$HouseholdRelationshipsTableAnnotationComposer a) f,
  ) {
    final $$HouseholdRelationshipsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.relationship_id,
          referencedTable: $db.householdRelationships,
          getReferencedColumn: (t) => t.relationship_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdRelationshipsTableAnnotationComposer(
                $db: $db,
                $table: $db.householdRelationships,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$RelationshipTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RelationshipTypesTable,
          RelationshipTypeData,
          $$RelationshipTypesTableFilterComposer,
          $$RelationshipTypesTableOrderingComposer,
          $$RelationshipTypesTableAnnotationComposer,
          $$RelationshipTypesTableCreateCompanionBuilder,
          $$RelationshipTypesTableUpdateCompanionBuilder,
          (RelationshipTypeData, $$RelationshipTypesTableReferences),
          RelationshipTypeData,
          PrefetchHooks Function({bool householdRelationshipsRefs})
        > {
  $$RelationshipTypesTableTableManager(
    _$AppDatabase db,
    $RelationshipTypesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$RelationshipTypesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$RelationshipTypesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$RelationshipTypesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> relationship_id = const Value.absent(),
                Value<String> relationship = const Value.absent(),
              }) => RelationshipTypesCompanion(
                relationship_id: relationship_id,
                relationship: relationship,
              ),
          createCompanionCallback:
              ({
                Value<int> relationship_id = const Value.absent(),
                required String relationship,
              }) => RelationshipTypesCompanion.insert(
                relationship_id: relationship_id,
                relationship: relationship,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$RelationshipTypesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({householdRelationshipsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (householdRelationshipsRefs) db.householdRelationships,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (householdRelationshipsRefs)
                    await $_getPrefetchedData<
                      RelationshipTypeData,
                      $RelationshipTypesTable,
                      HouseholdRelationship
                    >(
                      currentTable: table,
                      referencedTable: $$RelationshipTypesTableReferences
                          ._householdRelationshipsRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$RelationshipTypesTableReferences(
                                db,
                                table,
                                p0,
                              ).householdRelationshipsRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.relationship_id == item.relationship_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$RelationshipTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RelationshipTypesTable,
      RelationshipTypeData,
      $$RelationshipTypesTableFilterComposer,
      $$RelationshipTypesTableOrderingComposer,
      $$RelationshipTypesTableAnnotationComposer,
      $$RelationshipTypesTableCreateCompanionBuilder,
      $$RelationshipTypesTableUpdateCompanionBuilder,
      (RelationshipTypeData, $$RelationshipTypesTableReferences),
      RelationshipTypeData,
      PrefetchHooks Function({bool householdRelationshipsRefs})
    >;
typedef $$HouseholdRelationshipsTableCreateCompanionBuilder =
    HouseholdRelationshipsCompanion Function({
      Value<int> household_relationship_id,
      required int person_id,
      required int household_id,
      Value<int?> relationship_id,
    });
typedef $$HouseholdRelationshipsTableUpdateCompanionBuilder =
    HouseholdRelationshipsCompanion Function({
      Value<int> household_relationship_id,
      Value<int> person_id,
      Value<int> household_id,
      Value<int?> relationship_id,
    });

final class $$HouseholdRelationshipsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $HouseholdRelationshipsTable,
          HouseholdRelationship
        > {
  $$HouseholdRelationshipsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.householdRelationships.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.householdRelationships.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $RelationshipTypesTable _relationship_idTable(_$AppDatabase db) =>
      db.relationshipTypes.createAlias(
        $_aliasNameGenerator(
          db.householdRelationships.relationship_id,
          db.relationshipTypes.relationship_id,
        ),
      );

  $$RelationshipTypesTableProcessedTableManager? get relationship_id {
    final $_column = $_itemColumn<int>('relationship_id');
    if ($_column == null) return null;
    final manager = $$RelationshipTypesTableTableManager(
      $_db,
      $_db.relationshipTypes,
    ).filter((f) => f.relationship_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_relationship_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$HouseholdRelationshipsTableFilterComposer
    extends Composer<_$AppDatabase, $HouseholdRelationshipsTable> {
  $$HouseholdRelationshipsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get household_relationship_id => $composableBuilder(
    column: $table.household_relationship_id,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RelationshipTypesTableFilterComposer get relationship_id {
    final $$RelationshipTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.relationship_id,
      referencedTable: $db.relationshipTypes,
      getReferencedColumn: (t) => t.relationship_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RelationshipTypesTableFilterComposer(
            $db: $db,
            $table: $db.relationshipTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdRelationshipsTableOrderingComposer
    extends Composer<_$AppDatabase, $HouseholdRelationshipsTable> {
  $$HouseholdRelationshipsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get household_relationship_id => $composableBuilder(
    column: $table.household_relationship_id,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RelationshipTypesTableOrderingComposer get relationship_id {
    final $$RelationshipTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.relationship_id,
      referencedTable: $db.relationshipTypes,
      getReferencedColumn: (t) => t.relationship_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RelationshipTypesTableOrderingComposer(
            $db: $db,
            $table: $db.relationshipTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdRelationshipsTableAnnotationComposer
    extends Composer<_$AppDatabase, $HouseholdRelationshipsTable> {
  $$HouseholdRelationshipsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get household_relationship_id => $composableBuilder(
    column: $table.household_relationship_id,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RelationshipTypesTableAnnotationComposer get relationship_id {
    final $$RelationshipTypesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.relationship_id,
          referencedTable: $db.relationshipTypes,
          getReferencedColumn: (t) => t.relationship_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RelationshipTypesTableAnnotationComposer(
                $db: $db,
                $table: $db.relationshipTypes,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }
}

class $$HouseholdRelationshipsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HouseholdRelationshipsTable,
          HouseholdRelationship,
          $$HouseholdRelationshipsTableFilterComposer,
          $$HouseholdRelationshipsTableOrderingComposer,
          $$HouseholdRelationshipsTableAnnotationComposer,
          $$HouseholdRelationshipsTableCreateCompanionBuilder,
          $$HouseholdRelationshipsTableUpdateCompanionBuilder,
          (HouseholdRelationship, $$HouseholdRelationshipsTableReferences),
          HouseholdRelationship,
          PrefetchHooks Function({
            bool person_id,
            bool household_id,
            bool relationship_id,
          })
        > {
  $$HouseholdRelationshipsTableTableManager(
    _$AppDatabase db,
    $HouseholdRelationshipsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$HouseholdRelationshipsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$HouseholdRelationshipsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$HouseholdRelationshipsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> household_relationship_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<int?> relationship_id = const Value.absent(),
              }) => HouseholdRelationshipsCompanion(
                household_relationship_id: household_relationship_id,
                person_id: person_id,
                household_id: household_id,
                relationship_id: relationship_id,
              ),
          createCompanionCallback:
              ({
                Value<int> household_relationship_id = const Value.absent(),
                required int person_id,
                required int household_id,
                Value<int?> relationship_id = const Value.absent(),
              }) => HouseholdRelationshipsCompanion.insert(
                household_relationship_id: household_relationship_id,
                person_id: person_id,
                household_id: household_id,
                relationship_id: relationship_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$HouseholdRelationshipsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            household_id = false,
            relationship_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable:
                                $$HouseholdRelationshipsTableReferences
                                    ._person_idTable(db),
                            referencedColumn:
                                $$HouseholdRelationshipsTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable:
                                $$HouseholdRelationshipsTableReferences
                                    ._household_idTable(db),
                            referencedColumn:
                                $$HouseholdRelationshipsTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }
                if (relationship_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.relationship_id,
                            referencedTable:
                                $$HouseholdRelationshipsTableReferences
                                    ._relationship_idTable(db),
                            referencedColumn:
                                $$HouseholdRelationshipsTableReferences
                                    ._relationship_idTable(db)
                                    .relationship_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$HouseholdRelationshipsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HouseholdRelationshipsTable,
      HouseholdRelationship,
      $$HouseholdRelationshipsTableFilterComposer,
      $$HouseholdRelationshipsTableOrderingComposer,
      $$HouseholdRelationshipsTableAnnotationComposer,
      $$HouseholdRelationshipsTableCreateCompanionBuilder,
      $$HouseholdRelationshipsTableUpdateCompanionBuilder,
      (HouseholdRelationship, $$HouseholdRelationshipsTableReferences),
      HouseholdRelationship,
      PrefetchHooks Function({
        bool person_id,
        bool household_id,
        bool relationship_id,
      })
    >;
typedef $$ServicesTableCreateCompanionBuilder =
    ServicesCompanion Function({
      Value<int> service_id,
      required String service,
      required int household_id,
      Value<ClientTypes?> client_type_id,
      Value<int?> ave_client_num,
    });
typedef $$ServicesTableUpdateCompanionBuilder =
    ServicesCompanion Function({
      Value<int> service_id,
      Value<String> service,
      Value<int> household_id,
      Value<ClientTypes?> client_type_id,
      Value<int?> ave_client_num,
    });

final class $$ServicesTableReferences
    extends BaseReferences<_$AppDatabase, $ServicesTable, ServiceData> {
  $$ServicesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.services.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ServicesTableFilterComposer
    extends Composer<_$AppDatabase, $ServicesTable> {
  $$ServicesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get service_id => $composableBuilder(
    column: $table.service_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get service => $composableBuilder(
    column: $table.service,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<ClientTypes?, ClientTypes, String>
  get client_type_id => $composableBuilder(
    column: $table.client_type_id,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<int> get ave_client_num => $composableBuilder(
    column: $table.ave_client_num,
    builder: (column) => ColumnFilters(column),
  );

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ServicesTableOrderingComposer
    extends Composer<_$AppDatabase, $ServicesTable> {
  $$ServicesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get service_id => $composableBuilder(
    column: $table.service_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get service => $composableBuilder(
    column: $table.service,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get client_type_id => $composableBuilder(
    column: $table.client_type_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get ave_client_num => $composableBuilder(
    column: $table.ave_client_num,
    builder: (column) => ColumnOrderings(column),
  );

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ServicesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ServicesTable> {
  $$ServicesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get service_id => $composableBuilder(
    column: $table.service_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get service =>
      $composableBuilder(column: $table.service, builder: (column) => column);

  GeneratedColumnWithTypeConverter<ClientTypes?, String> get client_type_id =>
      $composableBuilder(
        column: $table.client_type_id,
        builder: (column) => column,
      );

  GeneratedColumn<int> get ave_client_num => $composableBuilder(
    column: $table.ave_client_num,
    builder: (column) => column,
  );

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ServicesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ServicesTable,
          ServiceData,
          $$ServicesTableFilterComposer,
          $$ServicesTableOrderingComposer,
          $$ServicesTableAnnotationComposer,
          $$ServicesTableCreateCompanionBuilder,
          $$ServicesTableUpdateCompanionBuilder,
          (ServiceData, $$ServicesTableReferences),
          ServiceData,
          PrefetchHooks Function({bool household_id})
        > {
  $$ServicesTableTableManager(_$AppDatabase db, $ServicesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$ServicesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$ServicesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$ServicesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> service_id = const Value.absent(),
                Value<String> service = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<ClientTypes?> client_type_id = const Value.absent(),
                Value<int?> ave_client_num = const Value.absent(),
              }) => ServicesCompanion(
                service_id: service_id,
                service: service,
                household_id: household_id,
                client_type_id: client_type_id,
                ave_client_num: ave_client_num,
              ),
          createCompanionCallback:
              ({
                Value<int> service_id = const Value.absent(),
                required String service,
                required int household_id,
                Value<ClientTypes?> client_type_id = const Value.absent(),
                Value<int?> ave_client_num = const Value.absent(),
              }) => ServicesCompanion.insert(
                service_id: service_id,
                service: service,
                household_id: household_id,
                client_type_id: client_type_id,
                ave_client_num: ave_client_num,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$ServicesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({household_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$ServicesTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$ServicesTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ServicesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ServicesTable,
      ServiceData,
      $$ServicesTableFilterComposer,
      $$ServicesTableOrderingComposer,
      $$ServicesTableAnnotationComposer,
      $$ServicesTableCreateCompanionBuilder,
      $$ServicesTableUpdateCompanionBuilder,
      (ServiceData, $$ServicesTableReferences),
      ServiceData,
      PrefetchHooks Function({bool household_id})
    >;
typedef $$PrimaryNeedsTableCreateCompanionBuilder =
    PrimaryNeedsCompanion Function({
      Value<int> primary_need_id,
      required int household_id,
      required String need,
      required int priority,
    });
typedef $$PrimaryNeedsTableUpdateCompanionBuilder =
    PrimaryNeedsCompanion Function({
      Value<int> primary_need_id,
      Value<int> household_id,
      Value<String> need,
      Value<int> priority,
    });

final class $$PrimaryNeedsTableReferences
    extends BaseReferences<_$AppDatabase, $PrimaryNeedsTable, PrimaryNeedData> {
  $$PrimaryNeedsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.primaryNeeds.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PrimaryNeedsTableFilterComposer
    extends Composer<_$AppDatabase, $PrimaryNeedsTable> {
  $$PrimaryNeedsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get primary_need_id => $composableBuilder(
    column: $table.primary_need_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get need => $composableBuilder(
    column: $table.need,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnFilters(column),
  );

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PrimaryNeedsTableOrderingComposer
    extends Composer<_$AppDatabase, $PrimaryNeedsTable> {
  $$PrimaryNeedsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get primary_need_id => $composableBuilder(
    column: $table.primary_need_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get need => $composableBuilder(
    column: $table.need,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnOrderings(column),
  );

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PrimaryNeedsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PrimaryNeedsTable> {
  $$PrimaryNeedsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get primary_need_id => $composableBuilder(
    column: $table.primary_need_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get need =>
      $composableBuilder(column: $table.need, builder: (column) => column);

  GeneratedColumn<int> get priority =>
      $composableBuilder(column: $table.priority, builder: (column) => column);

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PrimaryNeedsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PrimaryNeedsTable,
          PrimaryNeedData,
          $$PrimaryNeedsTableFilterComposer,
          $$PrimaryNeedsTableOrderingComposer,
          $$PrimaryNeedsTableAnnotationComposer,
          $$PrimaryNeedsTableCreateCompanionBuilder,
          $$PrimaryNeedsTableUpdateCompanionBuilder,
          (PrimaryNeedData, $$PrimaryNeedsTableReferences),
          PrimaryNeedData,
          PrefetchHooks Function({bool household_id})
        > {
  $$PrimaryNeedsTableTableManager(_$AppDatabase db, $PrimaryNeedsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$PrimaryNeedsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$PrimaryNeedsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$PrimaryNeedsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> primary_need_id = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<String> need = const Value.absent(),
                Value<int> priority = const Value.absent(),
              }) => PrimaryNeedsCompanion(
                primary_need_id: primary_need_id,
                household_id: household_id,
                need: need,
                priority: priority,
              ),
          createCompanionCallback:
              ({
                Value<int> primary_need_id = const Value.absent(),
                required int household_id,
                required String need,
                required int priority,
              }) => PrimaryNeedsCompanion.insert(
                primary_need_id: primary_need_id,
                household_id: household_id,
                need: need,
                priority: priority,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$PrimaryNeedsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({household_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$PrimaryNeedsTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$PrimaryNeedsTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PrimaryNeedsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PrimaryNeedsTable,
      PrimaryNeedData,
      $$PrimaryNeedsTableFilterComposer,
      $$PrimaryNeedsTableOrderingComposer,
      $$PrimaryNeedsTableAnnotationComposer,
      $$PrimaryNeedsTableCreateCompanionBuilder,
      $$PrimaryNeedsTableUpdateCompanionBuilder,
      (PrimaryNeedData, $$PrimaryNeedsTableReferences),
      PrimaryNeedData,
      PrefetchHooks Function({bool household_id})
    >;
typedef $$FemaleMortalitiesTableCreateCompanionBuilder =
    FemaleMortalitiesCompanion Function({
      Value<int> female_mortality_id,
      required int household_id,
      Value<int?> age,
      Value<String?> death_cause,
    });
typedef $$FemaleMortalitiesTableUpdateCompanionBuilder =
    FemaleMortalitiesCompanion Function({
      Value<int> female_mortality_id,
      Value<int> household_id,
      Value<int?> age,
      Value<String?> death_cause,
    });

final class $$FemaleMortalitiesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FemaleMortalitiesTable,
          FemaleMortalityData
        > {
  $$FemaleMortalitiesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.femaleMortalities.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FemaleMortalitiesTableFilterComposer
    extends Composer<_$AppDatabase, $FemaleMortalitiesTable> {
  $$FemaleMortalitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get female_mortality_id => $composableBuilder(
    column: $table.female_mortality_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => ColumnFilters(column),
  );

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FemaleMortalitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $FemaleMortalitiesTable> {
  $$FemaleMortalitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get female_mortality_id => $composableBuilder(
    column: $table.female_mortality_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => ColumnOrderings(column),
  );

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FemaleMortalitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FemaleMortalitiesTable> {
  $$FemaleMortalitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get female_mortality_id => $composableBuilder(
    column: $table.female_mortality_id,
    builder: (column) => column,
  );

  GeneratedColumn<int> get age =>
      $composableBuilder(column: $table.age, builder: (column) => column);

  GeneratedColumn<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => column,
  );

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FemaleMortalitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FemaleMortalitiesTable,
          FemaleMortalityData,
          $$FemaleMortalitiesTableFilterComposer,
          $$FemaleMortalitiesTableOrderingComposer,
          $$FemaleMortalitiesTableAnnotationComposer,
          $$FemaleMortalitiesTableCreateCompanionBuilder,
          $$FemaleMortalitiesTableUpdateCompanionBuilder,
          (FemaleMortalityData, $$FemaleMortalitiesTableReferences),
          FemaleMortalityData,
          PrefetchHooks Function({bool household_id})
        > {
  $$FemaleMortalitiesTableTableManager(
    _$AppDatabase db,
    $FemaleMortalitiesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FemaleMortalitiesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$FemaleMortalitiesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$FemaleMortalitiesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> female_mortality_id = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<int?> age = const Value.absent(),
                Value<String?> death_cause = const Value.absent(),
              }) => FemaleMortalitiesCompanion(
                female_mortality_id: female_mortality_id,
                household_id: household_id,
                age: age,
                death_cause: death_cause,
              ),
          createCompanionCallback:
              ({
                Value<int> female_mortality_id = const Value.absent(),
                required int household_id,
                Value<int?> age = const Value.absent(),
                Value<String?> death_cause = const Value.absent(),
              }) => FemaleMortalitiesCompanion.insert(
                female_mortality_id: female_mortality_id,
                household_id: household_id,
                age: age,
                death_cause: death_cause,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FemaleMortalitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({household_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$FemaleMortalitiesTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$FemaleMortalitiesTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FemaleMortalitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FemaleMortalitiesTable,
      FemaleMortalityData,
      $$FemaleMortalitiesTableFilterComposer,
      $$FemaleMortalitiesTableOrderingComposer,
      $$FemaleMortalitiesTableAnnotationComposer,
      $$FemaleMortalitiesTableCreateCompanionBuilder,
      $$FemaleMortalitiesTableUpdateCompanionBuilder,
      (FemaleMortalityData, $$FemaleMortalitiesTableReferences),
      FemaleMortalityData,
      PrefetchHooks Function({bool household_id})
    >;
typedef $$ChildMortalitiesTableCreateCompanionBuilder =
    ChildMortalitiesCompanion Function({
      Value<int> child_mortality_id,
      required int household_id,
      Value<int?> age,
      Value<Sex?> sex,
      Value<String?> death_cause,
    });
typedef $$ChildMortalitiesTableUpdateCompanionBuilder =
    ChildMortalitiesCompanion Function({
      Value<int> child_mortality_id,
      Value<int> household_id,
      Value<int?> age,
      Value<Sex?> sex,
      Value<String?> death_cause,
    });

final class $$ChildMortalitiesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $ChildMortalitiesTable,
          ChildMortalityData
        > {
  $$ChildMortalitiesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.childMortalities.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ChildMortalitiesTableFilterComposer
    extends Composer<_$AppDatabase, $ChildMortalitiesTable> {
  $$ChildMortalitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get child_mortality_id => $composableBuilder(
    column: $table.child_mortality_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<Sex?, Sex, String> get sex =>
      $composableBuilder(
        column: $table.sex,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => ColumnFilters(column),
  );

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChildMortalitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $ChildMortalitiesTable> {
  $$ChildMortalitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get child_mortality_id => $composableBuilder(
    column: $table.child_mortality_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get age => $composableBuilder(
    column: $table.age,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sex => $composableBuilder(
    column: $table.sex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => ColumnOrderings(column),
  );

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChildMortalitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ChildMortalitiesTable> {
  $$ChildMortalitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get child_mortality_id => $composableBuilder(
    column: $table.child_mortality_id,
    builder: (column) => column,
  );

  GeneratedColumn<int> get age =>
      $composableBuilder(column: $table.age, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Sex?, String> get sex =>
      $composableBuilder(column: $table.sex, builder: (column) => column);

  GeneratedColumn<String> get death_cause => $composableBuilder(
    column: $table.death_cause,
    builder: (column) => column,
  );

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ChildMortalitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ChildMortalitiesTable,
          ChildMortalityData,
          $$ChildMortalitiesTableFilterComposer,
          $$ChildMortalitiesTableOrderingComposer,
          $$ChildMortalitiesTableAnnotationComposer,
          $$ChildMortalitiesTableCreateCompanionBuilder,
          $$ChildMortalitiesTableUpdateCompanionBuilder,
          (ChildMortalityData, $$ChildMortalitiesTableReferences),
          ChildMortalityData,
          PrefetchHooks Function({bool household_id})
        > {
  $$ChildMortalitiesTableTableManager(
    _$AppDatabase db,
    $ChildMortalitiesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$ChildMortalitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$ChildMortalitiesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$ChildMortalitiesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> child_mortality_id = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<int?> age = const Value.absent(),
                Value<Sex?> sex = const Value.absent(),
                Value<String?> death_cause = const Value.absent(),
              }) => ChildMortalitiesCompanion(
                child_mortality_id: child_mortality_id,
                household_id: household_id,
                age: age,
                sex: sex,
                death_cause: death_cause,
              ),
          createCompanionCallback:
              ({
                Value<int> child_mortality_id = const Value.absent(),
                required int household_id,
                Value<int?> age = const Value.absent(),
                Value<Sex?> sex = const Value.absent(),
                Value<String?> death_cause = const Value.absent(),
              }) => ChildMortalitiesCompanion.insert(
                child_mortality_id: child_mortality_id,
                household_id: household_id,
                age: age,
                sex: sex,
                death_cause: death_cause,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$ChildMortalitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({household_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$ChildMortalitiesTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$ChildMortalitiesTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ChildMortalitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ChildMortalitiesTable,
      ChildMortalityData,
      $$ChildMortalitiesTableFilterComposer,
      $$ChildMortalitiesTableOrderingComposer,
      $$ChildMortalitiesTableAnnotationComposer,
      $$ChildMortalitiesTableCreateCompanionBuilder,
      $$ChildMortalitiesTableUpdateCompanionBuilder,
      (ChildMortalityData, $$ChildMortalitiesTableReferences),
      ChildMortalityData,
      PrefetchHooks Function({bool household_id})
    >;
typedef $$FutureResidenciesTableCreateCompanionBuilder =
    FutureResidenciesCompanion Function({
      Value<int> future_residency_id,
      required int household_id,
      Value<String?> barangay,
      Value<String?> municipality,
    });
typedef $$FutureResidenciesTableUpdateCompanionBuilder =
    FutureResidenciesCompanion Function({
      Value<int> future_residency_id,
      Value<int> household_id,
      Value<String?> barangay,
      Value<String?> municipality,
    });

final class $$FutureResidenciesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FutureResidenciesTable,
          FutureResidency
        > {
  $$FutureResidenciesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $HouseholdsTable _household_idTable(_$AppDatabase db) =>
      db.households.createAlias(
        $_aliasNameGenerator(
          db.futureResidencies.household_id,
          db.households.household_id,
        ),
      );

  $$HouseholdsTableProcessedTableManager get household_id {
    final $_column = $_itemColumn<int>('household_id')!;

    final manager = $$HouseholdsTableTableManager(
      $_db,
      $_db.households,
    ).filter((f) => f.household_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_household_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FutureResidenciesTableFilterComposer
    extends Composer<_$AppDatabase, $FutureResidenciesTable> {
  $$FutureResidenciesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get future_residency_id => $composableBuilder(
    column: $table.future_residency_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barangay => $composableBuilder(
    column: $table.barangay,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get municipality => $composableBuilder(
    column: $table.municipality,
    builder: (column) => ColumnFilters(column),
  );

  $$HouseholdsTableFilterComposer get household_id {
    final $$HouseholdsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableFilterComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FutureResidenciesTableOrderingComposer
    extends Composer<_$AppDatabase, $FutureResidenciesTable> {
  $$FutureResidenciesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get future_residency_id => $composableBuilder(
    column: $table.future_residency_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barangay => $composableBuilder(
    column: $table.barangay,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get municipality => $composableBuilder(
    column: $table.municipality,
    builder: (column) => ColumnOrderings(column),
  );

  $$HouseholdsTableOrderingComposer get household_id {
    final $$HouseholdsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableOrderingComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FutureResidenciesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FutureResidenciesTable> {
  $$FutureResidenciesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get future_residency_id => $composableBuilder(
    column: $table.future_residency_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get barangay =>
      $composableBuilder(column: $table.barangay, builder: (column) => column);

  GeneratedColumn<String> get municipality => $composableBuilder(
    column: $table.municipality,
    builder: (column) => column,
  );

  $$HouseholdsTableAnnotationComposer get household_id {
    final $$HouseholdsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.household_id,
      referencedTable: $db.households,
      getReferencedColumn: (t) => t.household_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdsTableAnnotationComposer(
            $db: $db,
            $table: $db.households,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FutureResidenciesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FutureResidenciesTable,
          FutureResidency,
          $$FutureResidenciesTableFilterComposer,
          $$FutureResidenciesTableOrderingComposer,
          $$FutureResidenciesTableAnnotationComposer,
          $$FutureResidenciesTableCreateCompanionBuilder,
          $$FutureResidenciesTableUpdateCompanionBuilder,
          (FutureResidency, $$FutureResidenciesTableReferences),
          FutureResidency,
          PrefetchHooks Function({bool household_id})
        > {
  $$FutureResidenciesTableTableManager(
    _$AppDatabase db,
    $FutureResidenciesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FutureResidenciesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$FutureResidenciesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$FutureResidenciesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> future_residency_id = const Value.absent(),
                Value<int> household_id = const Value.absent(),
                Value<String?> barangay = const Value.absent(),
                Value<String?> municipality = const Value.absent(),
              }) => FutureResidenciesCompanion(
                future_residency_id: future_residency_id,
                household_id: household_id,
                barangay: barangay,
                municipality: municipality,
              ),
          createCompanionCallback:
              ({
                Value<int> future_residency_id = const Value.absent(),
                required int household_id,
                Value<String?> barangay = const Value.absent(),
                Value<String?> municipality = const Value.absent(),
              }) => FutureResidenciesCompanion.insert(
                future_residency_id: future_residency_id,
                household_id: household_id,
                barangay: barangay,
                municipality: municipality,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FutureResidenciesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({household_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (household_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.household_id,
                            referencedTable: $$FutureResidenciesTableReferences
                                ._household_idTable(db),
                            referencedColumn:
                                $$FutureResidenciesTableReferences
                                    ._household_idTable(db)
                                    .household_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FutureResidenciesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FutureResidenciesTable,
      FutureResidency,
      $$FutureResidenciesTableFilterComposer,
      $$FutureResidenciesTableOrderingComposer,
      $$FutureResidenciesTableAnnotationComposer,
      $$FutureResidenciesTableCreateCompanionBuilder,
      $$FutureResidenciesTableUpdateCompanionBuilder,
      (FutureResidency, $$FutureResidenciesTableReferences),
      FutureResidency,
      PrefetchHooks Function({bool household_id})
    >;
typedef $$DeliveryPlacesTableCreateCompanionBuilder =
    DeliveryPlacesCompanion Function({
      Value<int> delivery_place_id,
      Value<String?> place,
    });
typedef $$DeliveryPlacesTableUpdateCompanionBuilder =
    DeliveryPlacesCompanion Function({
      Value<int> delivery_place_id,
      Value<String?> place,
    });

final class $$DeliveryPlacesTableReferences
    extends
        BaseReferences<_$AppDatabase, $DeliveryPlacesTable, DeliveryPlaceData> {
  $$DeliveryPlacesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$NewbornInfosTable, List<NewbornInfoData>>
  _newbornInfosRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.newbornInfos,
    aliasName: $_aliasNameGenerator(
      db.deliveryPlaces.delivery_place_id,
      db.newbornInfos.delivery_place_id,
    ),
  );

  $$NewbornInfosTableProcessedTableManager get newbornInfosRefs {
    final manager = $$NewbornInfosTableTableManager(
      $_db,
      $_db.newbornInfos,
    ).filter(
      (f) => f.delivery_place_id.delivery_place_id.sqlEquals(
        $_itemColumn<int>('delivery_place_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_newbornInfosRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$DeliveryPlacesTableFilterComposer
    extends Composer<_$AppDatabase, $DeliveryPlacesTable> {
  $$DeliveryPlacesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get delivery_place_id => $composableBuilder(
    column: $table.delivery_place_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get place => $composableBuilder(
    column: $table.place,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> newbornInfosRefs(
    Expression<bool> Function($$NewbornInfosTableFilterComposer f) f,
  ) {
    final $$NewbornInfosTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.delivery_place_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.delivery_place_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableFilterComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DeliveryPlacesTableOrderingComposer
    extends Composer<_$AppDatabase, $DeliveryPlacesTable> {
  $$DeliveryPlacesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get delivery_place_id => $composableBuilder(
    column: $table.delivery_place_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get place => $composableBuilder(
    column: $table.place,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DeliveryPlacesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DeliveryPlacesTable> {
  $$DeliveryPlacesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get delivery_place_id => $composableBuilder(
    column: $table.delivery_place_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get place =>
      $composableBuilder(column: $table.place, builder: (column) => column);

  Expression<T> newbornInfosRefs<T extends Object>(
    Expression<T> Function($$NewbornInfosTableAnnotationComposer a) f,
  ) {
    final $$NewbornInfosTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.delivery_place_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.delivery_place_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableAnnotationComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$DeliveryPlacesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DeliveryPlacesTable,
          DeliveryPlaceData,
          $$DeliveryPlacesTableFilterComposer,
          $$DeliveryPlacesTableOrderingComposer,
          $$DeliveryPlacesTableAnnotationComposer,
          $$DeliveryPlacesTableCreateCompanionBuilder,
          $$DeliveryPlacesTableUpdateCompanionBuilder,
          (DeliveryPlaceData, $$DeliveryPlacesTableReferences),
          DeliveryPlaceData,
          PrefetchHooks Function({bool newbornInfosRefs})
        > {
  $$DeliveryPlacesTableTableManager(
    _$AppDatabase db,
    $DeliveryPlacesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$DeliveryPlacesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$DeliveryPlacesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$DeliveryPlacesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> delivery_place_id = const Value.absent(),
                Value<String?> place = const Value.absent(),
              }) => DeliveryPlacesCompanion(
                delivery_place_id: delivery_place_id,
                place: place,
              ),
          createCompanionCallback:
              ({
                Value<int> delivery_place_id = const Value.absent(),
                Value<String?> place = const Value.absent(),
              }) => DeliveryPlacesCompanion.insert(
                delivery_place_id: delivery_place_id,
                place: place,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$DeliveryPlacesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({newbornInfosRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (newbornInfosRefs) db.newbornInfos],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (newbornInfosRefs)
                    await $_getPrefetchedData<
                      DeliveryPlaceData,
                      $DeliveryPlacesTable,
                      NewbornInfoData
                    >(
                      currentTable: table,
                      referencedTable: $$DeliveryPlacesTableReferences
                          ._newbornInfosRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$DeliveryPlacesTableReferences(
                                db,
                                table,
                                p0,
                              ).newbornInfosRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) =>
                                e.delivery_place_id == item.delivery_place_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$DeliveryPlacesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DeliveryPlacesTable,
      DeliveryPlaceData,
      $$DeliveryPlacesTableFilterComposer,
      $$DeliveryPlacesTableOrderingComposer,
      $$DeliveryPlacesTableAnnotationComposer,
      $$DeliveryPlacesTableCreateCompanionBuilder,
      $$DeliveryPlacesTableUpdateCompanionBuilder,
      (DeliveryPlaceData, $$DeliveryPlacesTableReferences),
      DeliveryPlaceData,
      PrefetchHooks Function({bool newbornInfosRefs})
    >;
typedef $$AssistedPersonsTableCreateCompanionBuilder =
    AssistedPersonsCompanion Function({
      Value<int> assisted_person_id,
      Value<String?> name,
    });
typedef $$AssistedPersonsTableUpdateCompanionBuilder =
    AssistedPersonsCompanion Function({
      Value<int> assisted_person_id,
      Value<String?> name,
    });

final class $$AssistedPersonsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $AssistedPersonsTable,
          AssistedPersonData
        > {
  $$AssistedPersonsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$NewbornInfosTable, List<NewbornInfoData>>
  _newbornInfosRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.newbornInfos,
    aliasName: $_aliasNameGenerator(
      db.assistedPersons.assisted_person_id,
      db.newbornInfos.assisted_person_id,
    ),
  );

  $$NewbornInfosTableProcessedTableManager get newbornInfosRefs {
    final manager = $$NewbornInfosTableTableManager(
      $_db,
      $_db.newbornInfos,
    ).filter(
      (f) => f.assisted_person_id.assisted_person_id.sqlEquals(
        $_itemColumn<int>('assisted_person_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_newbornInfosRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$AssistedPersonsTableFilterComposer
    extends Composer<_$AppDatabase, $AssistedPersonsTable> {
  $$AssistedPersonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get assisted_person_id => $composableBuilder(
    column: $table.assisted_person_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> newbornInfosRefs(
    Expression<bool> Function($$NewbornInfosTableFilterComposer f) f,
  ) {
    final $$NewbornInfosTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assisted_person_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.assisted_person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableFilterComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AssistedPersonsTableOrderingComposer
    extends Composer<_$AppDatabase, $AssistedPersonsTable> {
  $$AssistedPersonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get assisted_person_id => $composableBuilder(
    column: $table.assisted_person_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AssistedPersonsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AssistedPersonsTable> {
  $$AssistedPersonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get assisted_person_id => $composableBuilder(
    column: $table.assisted_person_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> newbornInfosRefs<T extends Object>(
    Expression<T> Function($$NewbornInfosTableAnnotationComposer a) f,
  ) {
    final $$NewbornInfosTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assisted_person_id,
      referencedTable: $db.newbornInfos,
      getReferencedColumn: (t) => t.assisted_person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NewbornInfosTableAnnotationComposer(
            $db: $db,
            $table: $db.newbornInfos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AssistedPersonsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AssistedPersonsTable,
          AssistedPersonData,
          $$AssistedPersonsTableFilterComposer,
          $$AssistedPersonsTableOrderingComposer,
          $$AssistedPersonsTableAnnotationComposer,
          $$AssistedPersonsTableCreateCompanionBuilder,
          $$AssistedPersonsTableUpdateCompanionBuilder,
          (AssistedPersonData, $$AssistedPersonsTableReferences),
          AssistedPersonData,
          PrefetchHooks Function({bool newbornInfosRefs})
        > {
  $$AssistedPersonsTableTableManager(
    _$AppDatabase db,
    $AssistedPersonsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$AssistedPersonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$AssistedPersonsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$AssistedPersonsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> assisted_person_id = const Value.absent(),
                Value<String?> name = const Value.absent(),
              }) => AssistedPersonsCompanion(
                assisted_person_id: assisted_person_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> assisted_person_id = const Value.absent(),
                Value<String?> name = const Value.absent(),
              }) => AssistedPersonsCompanion.insert(
                assisted_person_id: assisted_person_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$AssistedPersonsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({newbornInfosRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (newbornInfosRefs) db.newbornInfos],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (newbornInfosRefs)
                    await $_getPrefetchedData<
                      AssistedPersonData,
                      $AssistedPersonsTable,
                      NewbornInfoData
                    >(
                      currentTable: table,
                      referencedTable: $$AssistedPersonsTableReferences
                          ._newbornInfosRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$AssistedPersonsTableReferences(
                                db,
                                table,
                                p0,
                              ).newbornInfosRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) =>
                                e.assisted_person_id == item.assisted_person_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$AssistedPersonsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AssistedPersonsTable,
      AssistedPersonData,
      $$AssistedPersonsTableFilterComposer,
      $$AssistedPersonsTableOrderingComposer,
      $$AssistedPersonsTableAnnotationComposer,
      $$AssistedPersonsTableCreateCompanionBuilder,
      $$AssistedPersonsTableUpdateCompanionBuilder,
      (AssistedPersonData, $$AssistedPersonsTableReferences),
      AssistedPersonData,
      PrefetchHooks Function({bool newbornInfosRefs})
    >;
typedef $$VisitReasonsTableCreateCompanionBuilder =
    VisitReasonsCompanion Function({
      Value<int> visit_reason_id,
      Value<String?> reason,
    });
typedef $$VisitReasonsTableUpdateCompanionBuilder =
    VisitReasonsCompanion Function({
      Value<int> visit_reason_id,
      Value<String?> reason,
    });

final class $$VisitReasonsTableReferences
    extends BaseReferences<_$AppDatabase, $VisitReasonsTable, VisitReasonData> {
  $$VisitReasonsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$VisitedFacilitiesTable, List<VisitedFacilityData>>
  _visitedFacilitiesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.visitedFacilities,
        aliasName: $_aliasNameGenerator(
          db.visitReasons.visit_reason_id,
          db.visitedFacilities.visit_reason_id,
        ),
      );

  $$VisitedFacilitiesTableProcessedTableManager get visitedFacilitiesRefs {
    final manager = $$VisitedFacilitiesTableTableManager(
      $_db,
      $_db.visitedFacilities,
    ).filter(
      (f) => f.visit_reason_id.visit_reason_id.sqlEquals(
        $_itemColumn<int>('visit_reason_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _visitedFacilitiesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$VisitReasonsTableFilterComposer
    extends Composer<_$AppDatabase, $VisitReasonsTable> {
  $$VisitReasonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get visit_reason_id => $composableBuilder(
    column: $table.visit_reason_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> visitedFacilitiesRefs(
    Expression<bool> Function($$VisitedFacilitiesTableFilterComposer f) f,
  ) {
    final $$VisitedFacilitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.visit_reason_id,
      referencedTable: $db.visitedFacilities,
      getReferencedColumn: (t) => t.visit_reason_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VisitedFacilitiesTableFilterComposer(
            $db: $db,
            $table: $db.visitedFacilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$VisitReasonsTableOrderingComposer
    extends Composer<_$AppDatabase, $VisitReasonsTable> {
  $$VisitReasonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get visit_reason_id => $composableBuilder(
    column: $table.visit_reason_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$VisitReasonsTableAnnotationComposer
    extends Composer<_$AppDatabase, $VisitReasonsTable> {
  $$VisitReasonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get visit_reason_id => $composableBuilder(
    column: $table.visit_reason_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  Expression<T> visitedFacilitiesRefs<T extends Object>(
    Expression<T> Function($$VisitedFacilitiesTableAnnotationComposer a) f,
  ) {
    final $$VisitedFacilitiesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.visit_reason_id,
          referencedTable: $db.visitedFacilities,
          getReferencedColumn: (t) => t.visit_reason_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$VisitedFacilitiesTableAnnotationComposer(
                $db: $db,
                $table: $db.visitedFacilities,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$VisitReasonsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VisitReasonsTable,
          VisitReasonData,
          $$VisitReasonsTableFilterComposer,
          $$VisitReasonsTableOrderingComposer,
          $$VisitReasonsTableAnnotationComposer,
          $$VisitReasonsTableCreateCompanionBuilder,
          $$VisitReasonsTableUpdateCompanionBuilder,
          (VisitReasonData, $$VisitReasonsTableReferences),
          VisitReasonData,
          PrefetchHooks Function({bool visitedFacilitiesRefs})
        > {
  $$VisitReasonsTableTableManager(_$AppDatabase db, $VisitReasonsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$VisitReasonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$VisitReasonsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$VisitReasonsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> visit_reason_id = const Value.absent(),
                Value<String?> reason = const Value.absent(),
              }) => VisitReasonsCompanion(
                visit_reason_id: visit_reason_id,
                reason: reason,
              ),
          createCompanionCallback:
              ({
                Value<int> visit_reason_id = const Value.absent(),
                Value<String?> reason = const Value.absent(),
              }) => VisitReasonsCompanion.insert(
                visit_reason_id: visit_reason_id,
                reason: reason,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$VisitReasonsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({visitedFacilitiesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (visitedFacilitiesRefs) db.visitedFacilities,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (visitedFacilitiesRefs)
                    await $_getPrefetchedData<
                      VisitReasonData,
                      $VisitReasonsTable,
                      VisitedFacilityData
                    >(
                      currentTable: table,
                      referencedTable: $$VisitReasonsTableReferences
                          ._visitedFacilitiesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$VisitReasonsTableReferences(
                                db,
                                table,
                                p0,
                              ).visitedFacilitiesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.visit_reason_id == item.visit_reason_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$VisitReasonsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VisitReasonsTable,
      VisitReasonData,
      $$VisitReasonsTableFilterComposer,
      $$VisitReasonsTableOrderingComposer,
      $$VisitReasonsTableAnnotationComposer,
      $$VisitReasonsTableCreateCompanionBuilder,
      $$VisitReasonsTableUpdateCompanionBuilder,
      (VisitReasonData, $$VisitReasonsTableReferences),
      VisitReasonData,
      PrefetchHooks Function({bool visitedFacilitiesRefs})
    >;
typedef $$FpSourcesTableCreateCompanionBuilder =
    FpSourcesCompanion Function({
      Value<int> fp_source_id,
      Value<String?> source,
    });
typedef $$FpSourcesTableUpdateCompanionBuilder =
    FpSourcesCompanion Function({
      Value<int> fp_source_id,
      Value<String?> source,
    });

final class $$FpSourcesTableReferences
    extends BaseReferences<_$AppDatabase, $FpSourcesTable, FpSourceData> {
  $$FpSourcesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$FamilyPlansTable, List<FamilyPlanData>>
  _familyPlansRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.familyPlans,
    aliasName: $_aliasNameGenerator(
      db.fpSources.fp_source_id,
      db.familyPlans.fp_source_id,
    ),
  );

  $$FamilyPlansTableProcessedTableManager get familyPlansRefs {
    final manager = $$FamilyPlansTableTableManager(
      $_db,
      $_db.familyPlans,
    ).filter(
      (f) => f.fp_source_id.fp_source_id.sqlEquals(
        $_itemColumn<int>('fp_source_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_familyPlansRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$FpSourcesTableFilterComposer
    extends Composer<_$AppDatabase, $FpSourcesTable> {
  $$FpSourcesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get fp_source_id => $composableBuilder(
    column: $table.fp_source_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> familyPlansRefs(
    Expression<bool> Function($$FamilyPlansTableFilterComposer f) f,
  ) {
    final $$FamilyPlansTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_source_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.fp_source_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableFilterComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FpSourcesTableOrderingComposer
    extends Composer<_$AppDatabase, $FpSourcesTable> {
  $$FpSourcesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get fp_source_id => $composableBuilder(
    column: $table.fp_source_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FpSourcesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FpSourcesTable> {
  $$FpSourcesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get fp_source_id => $composableBuilder(
    column: $table.fp_source_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  Expression<T> familyPlansRefs<T extends Object>(
    Expression<T> Function($$FamilyPlansTableAnnotationComposer a) f,
  ) {
    final $$FamilyPlansTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_source_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.fp_source_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableAnnotationComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FpSourcesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FpSourcesTable,
          FpSourceData,
          $$FpSourcesTableFilterComposer,
          $$FpSourcesTableOrderingComposer,
          $$FpSourcesTableAnnotationComposer,
          $$FpSourcesTableCreateCompanionBuilder,
          $$FpSourcesTableUpdateCompanionBuilder,
          (FpSourceData, $$FpSourcesTableReferences),
          FpSourceData,
          PrefetchHooks Function({bool familyPlansRefs})
        > {
  $$FpSourcesTableTableManager(_$AppDatabase db, $FpSourcesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FpSourcesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$FpSourcesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$FpSourcesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> fp_source_id = const Value.absent(),
                Value<String?> source = const Value.absent(),
              }) => FpSourcesCompanion(
                fp_source_id: fp_source_id,
                source: source,
              ),
          createCompanionCallback:
              ({
                Value<int> fp_source_id = const Value.absent(),
                Value<String?> source = const Value.absent(),
              }) => FpSourcesCompanion.insert(
                fp_source_id: fp_source_id,
                source: source,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FpSourcesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({familyPlansRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (familyPlansRefs) db.familyPlans],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (familyPlansRefs)
                    await $_getPrefetchedData<
                      FpSourceData,
                      $FpSourcesTable,
                      FamilyPlanData
                    >(
                      currentTable: table,
                      referencedTable: $$FpSourcesTableReferences
                          ._familyPlansRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$FpSourcesTableReferences(
                                db,
                                table,
                                p0,
                              ).familyPlansRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.fp_source_id == item.fp_source_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$FpSourcesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FpSourcesTable,
      FpSourceData,
      $$FpSourcesTableFilterComposer,
      $$FpSourcesTableOrderingComposer,
      $$FpSourcesTableAnnotationComposer,
      $$FpSourcesTableCreateCompanionBuilder,
      $$FpSourcesTableUpdateCompanionBuilder,
      (FpSourceData, $$FpSourcesTableReferences),
      FpSourceData,
      PrefetchHooks Function({bool familyPlansRefs})
    >;
typedef $$FpMethodsTableCreateCompanionBuilder =
    FpMethodsCompanion Function({
      Value<int> fp_method_id,
      Value<String?> method,
    });
typedef $$FpMethodsTableUpdateCompanionBuilder =
    FpMethodsCompanion Function({
      Value<int> fp_method_id,
      Value<String?> method,
    });

final class $$FpMethodsTableReferences
    extends BaseReferences<_$AppDatabase, $FpMethodsTable, FpMethodData> {
  $$FpMethodsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$FamilyPlansTable, List<FamilyPlanData>>
  _familyPlansRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.familyPlans,
    aliasName: $_aliasNameGenerator(
      db.fpMethods.fp_method_id,
      db.familyPlans.fp_method_id,
    ),
  );

  $$FamilyPlansTableProcessedTableManager get familyPlansRefs {
    final manager = $$FamilyPlansTableTableManager(
      $_db,
      $_db.familyPlans,
    ).filter(
      (f) => f.fp_method_id.fp_method_id.sqlEquals(
        $_itemColumn<int>('fp_method_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_familyPlansRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$FpMethodsTableFilterComposer
    extends Composer<_$AppDatabase, $FpMethodsTable> {
  $$FpMethodsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get fp_method_id => $composableBuilder(
    column: $table.fp_method_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> familyPlansRefs(
    Expression<bool> Function($$FamilyPlansTableFilterComposer f) f,
  ) {
    final $$FamilyPlansTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_method_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.fp_method_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableFilterComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FpMethodsTableOrderingComposer
    extends Composer<_$AppDatabase, $FpMethodsTable> {
  $$FpMethodsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get fp_method_id => $composableBuilder(
    column: $table.fp_method_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FpMethodsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FpMethodsTable> {
  $$FpMethodsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get fp_method_id => $composableBuilder(
    column: $table.fp_method_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get method =>
      $composableBuilder(column: $table.method, builder: (column) => column);

  Expression<T> familyPlansRefs<T extends Object>(
    Expression<T> Function($$FamilyPlansTableAnnotationComposer a) f,
  ) {
    final $$FamilyPlansTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_method_id,
      referencedTable: $db.familyPlans,
      getReferencedColumn: (t) => t.fp_method_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyPlansTableAnnotationComposer(
            $db: $db,
            $table: $db.familyPlans,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FpMethodsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FpMethodsTable,
          FpMethodData,
          $$FpMethodsTableFilterComposer,
          $$FpMethodsTableOrderingComposer,
          $$FpMethodsTableAnnotationComposer,
          $$FpMethodsTableCreateCompanionBuilder,
          $$FpMethodsTableUpdateCompanionBuilder,
          (FpMethodData, $$FpMethodsTableReferences),
          FpMethodData,
          PrefetchHooks Function({bool familyPlansRefs})
        > {
  $$FpMethodsTableTableManager(_$AppDatabase db, $FpMethodsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FpMethodsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$FpMethodsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$FpMethodsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> fp_method_id = const Value.absent(),
                Value<String?> method = const Value.absent(),
              }) => FpMethodsCompanion(
                fp_method_id: fp_method_id,
                method: method,
              ),
          createCompanionCallback:
              ({
                Value<int> fp_method_id = const Value.absent(),
                Value<String?> method = const Value.absent(),
              }) => FpMethodsCompanion.insert(
                fp_method_id: fp_method_id,
                method: method,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FpMethodsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({familyPlansRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (familyPlansRefs) db.familyPlans],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (familyPlansRefs)
                    await $_getPrefetchedData<
                      FpMethodData,
                      $FpMethodsTable,
                      FamilyPlanData
                    >(
                      currentTable: table,
                      referencedTable: $$FpMethodsTableReferences
                          ._familyPlansRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$FpMethodsTableReferences(
                                db,
                                table,
                                p0,
                              ).familyPlansRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.fp_method_id == item.fp_method_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$FpMethodsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FpMethodsTable,
      FpMethodData,
      $$FpMethodsTableFilterComposer,
      $$FpMethodsTableOrderingComposer,
      $$FpMethodsTableAnnotationComposer,
      $$FpMethodsTableCreateCompanionBuilder,
      $$FpMethodsTableUpdateCompanionBuilder,
      (FpMethodData, $$FpMethodsTableReferences),
      FpMethodData,
      PrefetchHooks Function({bool familyPlansRefs})
    >;
typedef $$FishingProductsTableCreateCompanionBuilder =
    FishingProductsCompanion Function({
      Value<int> fishing_product_id,
      required String name,
    });
typedef $$FishingProductsTableUpdateCompanionBuilder =
    FishingProductsCompanion Function({
      Value<int> fishing_product_id,
      Value<String> name,
    });

final class $$FishingProductsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $FishingProductsTable,
          FishingProductData
        > {
  $$FishingProductsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$FishingTable, List<FishingData>>
  _fishingRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.fishing,
    aliasName: $_aliasNameGenerator(
      db.fishingProducts.fishing_product_id,
      db.fishing.fishing_product_id,
    ),
  );

  $$FishingTableProcessedTableManager get fishingRefs {
    final manager = $$FishingTableTableManager($_db, $_db.fishing).filter(
      (f) => f.fishing_product_id.fishing_product_id.sqlEquals(
        $_itemColumn<int>('fishing_product_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_fishingRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$FishingProductsTableFilterComposer
    extends Composer<_$AppDatabase, $FishingProductsTable> {
  $$FishingProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get fishing_product_id => $composableBuilder(
    column: $table.fishing_product_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> fishingRefs(
    Expression<bool> Function($$FishingTableFilterComposer f) f,
  ) {
    final $$FishingTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fishing_product_id,
      referencedTable: $db.fishing,
      getReferencedColumn: (t) => t.fishing_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingTableFilterComposer(
            $db: $db,
            $table: $db.fishing,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FishingProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $FishingProductsTable> {
  $$FishingProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get fishing_product_id => $composableBuilder(
    column: $table.fishing_product_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FishingProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FishingProductsTable> {
  $$FishingProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get fishing_product_id => $composableBuilder(
    column: $table.fishing_product_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> fishingRefs<T extends Object>(
    Expression<T> Function($$FishingTableAnnotationComposer a) f,
  ) {
    final $$FishingTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fishing_product_id,
      referencedTable: $db.fishing,
      getReferencedColumn: (t) => t.fishing_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingTableAnnotationComposer(
            $db: $db,
            $table: $db.fishing,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$FishingProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FishingProductsTable,
          FishingProductData,
          $$FishingProductsTableFilterComposer,
          $$FishingProductsTableOrderingComposer,
          $$FishingProductsTableAnnotationComposer,
          $$FishingProductsTableCreateCompanionBuilder,
          $$FishingProductsTableUpdateCompanionBuilder,
          (FishingProductData, $$FishingProductsTableReferences),
          FishingProductData,
          PrefetchHooks Function({bool fishingRefs})
        > {
  $$FishingProductsTableTableManager(
    _$AppDatabase db,
    $FishingProductsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$FishingProductsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$FishingProductsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$FishingProductsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> fishing_product_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => FishingProductsCompanion(
                fishing_product_id: fishing_product_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> fishing_product_id = const Value.absent(),
                required String name,
              }) => FishingProductsCompanion.insert(
                fishing_product_id: fishing_product_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FishingProductsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({fishingRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (fishingRefs) db.fishing],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (fishingRefs)
                    await $_getPrefetchedData<
                      FishingProductData,
                      $FishingProductsTable,
                      FishingData
                    >(
                      currentTable: table,
                      referencedTable: $$FishingProductsTableReferences
                          ._fishingRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$FishingProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).fishingRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) =>
                                e.fishing_product_id == item.fishing_product_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$FishingProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FishingProductsTable,
      FishingProductData,
      $$FishingProductsTableFilterComposer,
      $$FishingProductsTableOrderingComposer,
      $$FishingProductsTableAnnotationComposer,
      $$FishingProductsTableCreateCompanionBuilder,
      $$FishingProductsTableUpdateCompanionBuilder,
      (FishingProductData, $$FishingProductsTableReferences),
      FishingProductData,
      PrefetchHooks Function({bool fishingRefs})
    >;
typedef $$FishingTableCreateCompanionBuilder =
    FishingCompanion Function({
      Value<int> fishing_id,
      required int person_id,
      Value<int?> fishing_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> fisherman_count,
    });
typedef $$FishingTableUpdateCompanionBuilder =
    FishingCompanion Function({
      Value<int> fishing_id,
      Value<int> person_id,
      Value<int?> fishing_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> fisherman_count,
    });

final class $$FishingTableReferences
    extends BaseReferences<_$AppDatabase, $FishingTable, FishingData> {
  $$FishingTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.fishing.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FishingProductsTable _fishing_product_idTable(_$AppDatabase db) =>
      db.fishingProducts.createAlias(
        $_aliasNameGenerator(
          db.fishing.fishing_product_id,
          db.fishingProducts.fishing_product_id,
        ),
      );

  $$FishingProductsTableProcessedTableManager? get fishing_product_id {
    final $_column = $_itemColumn<int>('fishing_product_id');
    if ($_column == null) return null;
    final manager = $$FishingProductsTableTableManager(
      $_db,
      $_db.fishingProducts,
    ).filter((f) => f.fishing_product_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_fishing_product_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FishingTableFilterComposer
    extends Composer<_$AppDatabase, $FishingTable> {
  $$FishingTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get fishing_id => $composableBuilder(
    column: $table.fishing_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fisherman_count => $composableBuilder(
    column: $table.fisherman_count,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FishingProductsTableFilterComposer get fishing_product_id {
    final $$FishingProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fishing_product_id,
      referencedTable: $db.fishingProducts,
      getReferencedColumn: (t) => t.fishing_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingProductsTableFilterComposer(
            $db: $db,
            $table: $db.fishingProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FishingTableOrderingComposer
    extends Composer<_$AppDatabase, $FishingTable> {
  $$FishingTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get fishing_id => $composableBuilder(
    column: $table.fishing_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fisherman_count => $composableBuilder(
    column: $table.fisherman_count,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FishingProductsTableOrderingComposer get fishing_product_id {
    final $$FishingProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fishing_product_id,
      referencedTable: $db.fishingProducts,
      getReferencedColumn: (t) => t.fishing_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingProductsTableOrderingComposer(
            $db: $db,
            $table: $db.fishingProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FishingTableAnnotationComposer
    extends Composer<_$AppDatabase, $FishingTable> {
  $$FishingTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get fishing_id => $composableBuilder(
    column: $table.fishing_id,
    builder: (column) => column,
  );

  GeneratedColumn<double> get area_ha =>
      $composableBuilder(column: $table.area_ha, builder: (column) => column);

  GeneratedColumn<double> get volume_kg =>
      $composableBuilder(column: $table.volume_kg, builder: (column) => column);

  GeneratedColumn<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => column,
  );

  GeneratedColumn<int> get fisherman_count => $composableBuilder(
    column: $table.fisherman_count,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FishingProductsTableAnnotationComposer get fishing_product_id {
    final $$FishingProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fishing_product_id,
      referencedTable: $db.fishingProducts,
      getReferencedColumn: (t) => t.fishing_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FishingProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.fishingProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FishingTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FishingTable,
          FishingData,
          $$FishingTableFilterComposer,
          $$FishingTableOrderingComposer,
          $$FishingTableAnnotationComposer,
          $$FishingTableCreateCompanionBuilder,
          $$FishingTableUpdateCompanionBuilder,
          (FishingData, $$FishingTableReferences),
          FishingData,
          PrefetchHooks Function({bool person_id, bool fishing_product_id})
        > {
  $$FishingTableTableManager(_$AppDatabase db, $FishingTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FishingTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$FishingTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$FishingTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> fishing_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int?> fishing_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> fisherman_count = const Value.absent(),
              }) => FishingCompanion(
                fishing_id: fishing_id,
                person_id: person_id,
                fishing_product_id: fishing_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                fisherman_count: fisherman_count,
              ),
          createCompanionCallback:
              ({
                Value<int> fishing_id = const Value.absent(),
                required int person_id,
                Value<int?> fishing_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> fisherman_count = const Value.absent(),
              }) => FishingCompanion.insert(
                fishing_id: fishing_id,
                person_id: person_id,
                fishing_product_id: fishing_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                fisherman_count: fisherman_count,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FishingTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            fishing_product_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$FishingTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$FishingTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (fishing_product_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.fishing_product_id,
                            referencedTable: $$FishingTableReferences
                                ._fishing_product_idTable(db),
                            referencedColumn:
                                $$FishingTableReferences
                                    ._fishing_product_idTable(db)
                                    .fishing_product_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FishingTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FishingTable,
      FishingData,
      $$FishingTableFilterComposer,
      $$FishingTableOrderingComposer,
      $$FishingTableAnnotationComposer,
      $$FishingTableCreateCompanionBuilder,
      $$FishingTableUpdateCompanionBuilder,
      (FishingData, $$FishingTableReferences),
      FishingData,
      PrefetchHooks Function({bool person_id, bool fishing_product_id})
    >;
typedef $$AgriProductsTableCreateCompanionBuilder =
    AgriProductsCompanion Function({
      Value<int> agri_product_id,
      required String name,
    });
typedef $$AgriProductsTableUpdateCompanionBuilder =
    AgriProductsCompanion Function({
      Value<int> agri_product_id,
      Value<String> name,
    });

final class $$AgriProductsTableReferences
    extends BaseReferences<_$AppDatabase, $AgriProductsTable, AgriProductData> {
  $$AgriProductsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$AgricultureTable, List<AgricultureData>>
  _agricultureRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.agriculture,
    aliasName: $_aliasNameGenerator(
      db.agriProducts.agri_product_id,
      db.agriculture.agri_product_id,
    ),
  );

  $$AgricultureTableProcessedTableManager get agricultureRefs {
    final manager = $$AgricultureTableTableManager(
      $_db,
      $_db.agriculture,
    ).filter(
      (f) => f.agri_product_id.agri_product_id.sqlEquals(
        $_itemColumn<int>('agri_product_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_agricultureRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$AgriProductsTableFilterComposer
    extends Composer<_$AppDatabase, $AgriProductsTable> {
  $$AgriProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get agri_product_id => $composableBuilder(
    column: $table.agri_product_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> agricultureRefs(
    Expression<bool> Function($$AgricultureTableFilterComposer f) f,
  ) {
    final $$AgricultureTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.agri_product_id,
      referencedTable: $db.agriculture,
      getReferencedColumn: (t) => t.agri_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgricultureTableFilterComposer(
            $db: $db,
            $table: $db.agriculture,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AgriProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $AgriProductsTable> {
  $$AgriProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get agri_product_id => $composableBuilder(
    column: $table.agri_product_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AgriProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AgriProductsTable> {
  $$AgriProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get agri_product_id => $composableBuilder(
    column: $table.agri_product_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> agricultureRefs<T extends Object>(
    Expression<T> Function($$AgricultureTableAnnotationComposer a) f,
  ) {
    final $$AgricultureTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.agri_product_id,
      referencedTable: $db.agriculture,
      getReferencedColumn: (t) => t.agri_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgricultureTableAnnotationComposer(
            $db: $db,
            $table: $db.agriculture,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AgriProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AgriProductsTable,
          AgriProductData,
          $$AgriProductsTableFilterComposer,
          $$AgriProductsTableOrderingComposer,
          $$AgriProductsTableAnnotationComposer,
          $$AgriProductsTableCreateCompanionBuilder,
          $$AgriProductsTableUpdateCompanionBuilder,
          (AgriProductData, $$AgriProductsTableReferences),
          AgriProductData,
          PrefetchHooks Function({bool agricultureRefs})
        > {
  $$AgriProductsTableTableManager(_$AppDatabase db, $AgriProductsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$AgriProductsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$AgriProductsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$AgriProductsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> agri_product_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => AgriProductsCompanion(
                agri_product_id: agri_product_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> agri_product_id = const Value.absent(),
                required String name,
              }) => AgriProductsCompanion.insert(
                agri_product_id: agri_product_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$AgriProductsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({agricultureRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (agricultureRefs) db.agriculture],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (agricultureRefs)
                    await $_getPrefetchedData<
                      AgriProductData,
                      $AgriProductsTable,
                      AgricultureData
                    >(
                      currentTable: table,
                      referencedTable: $$AgriProductsTableReferences
                          ._agricultureRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$AgriProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).agricultureRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.agri_product_id == item.agri_product_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$AgriProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AgriProductsTable,
      AgriProductData,
      $$AgriProductsTableFilterComposer,
      $$AgriProductsTableOrderingComposer,
      $$AgriProductsTableAnnotationComposer,
      $$AgriProductsTableCreateCompanionBuilder,
      $$AgriProductsTableUpdateCompanionBuilder,
      (AgriProductData, $$AgriProductsTableReferences),
      AgriProductData,
      PrefetchHooks Function({bool agricultureRefs})
    >;
typedef $$AgricultureTableCreateCompanionBuilder =
    AgricultureCompanion Function({
      Value<int> agriculture_id,
      required int person_id,
      Value<int?> agri_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> farmer_count,
    });
typedef $$AgricultureTableUpdateCompanionBuilder =
    AgricultureCompanion Function({
      Value<int> agriculture_id,
      Value<int> person_id,
      Value<int?> agri_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> farmer_count,
    });

final class $$AgricultureTableReferences
    extends BaseReferences<_$AppDatabase, $AgricultureTable, AgricultureData> {
  $$AgricultureTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.agriculture.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $AgriProductsTable _agri_product_idTable(_$AppDatabase db) =>
      db.agriProducts.createAlias(
        $_aliasNameGenerator(
          db.agriculture.agri_product_id,
          db.agriProducts.agri_product_id,
        ),
      );

  $$AgriProductsTableProcessedTableManager? get agri_product_id {
    final $_column = $_itemColumn<int>('agri_product_id');
    if ($_column == null) return null;
    final manager = $$AgriProductsTableTableManager(
      $_db,
      $_db.agriProducts,
    ).filter((f) => f.agri_product_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_agri_product_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AgricultureTableFilterComposer
    extends Composer<_$AppDatabase, $AgricultureTable> {
  $$AgricultureTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get agriculture_id => $composableBuilder(
    column: $table.agriculture_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AgriProductsTableFilterComposer get agri_product_id {
    final $$AgriProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.agri_product_id,
      referencedTable: $db.agriProducts,
      getReferencedColumn: (t) => t.agri_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgriProductsTableFilterComposer(
            $db: $db,
            $table: $db.agriProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AgricultureTableOrderingComposer
    extends Composer<_$AppDatabase, $AgricultureTable> {
  $$AgricultureTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get agriculture_id => $composableBuilder(
    column: $table.agriculture_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AgriProductsTableOrderingComposer get agri_product_id {
    final $$AgriProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.agri_product_id,
      referencedTable: $db.agriProducts,
      getReferencedColumn: (t) => t.agri_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgriProductsTableOrderingComposer(
            $db: $db,
            $table: $db.agriProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AgricultureTableAnnotationComposer
    extends Composer<_$AppDatabase, $AgricultureTable> {
  $$AgricultureTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get agriculture_id => $composableBuilder(
    column: $table.agriculture_id,
    builder: (column) => column,
  );

  GeneratedColumn<double> get area_ha =>
      $composableBuilder(column: $table.area_ha, builder: (column) => column);

  GeneratedColumn<double> get volume_kg =>
      $composableBuilder(column: $table.volume_kg, builder: (column) => column);

  GeneratedColumn<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => column,
  );

  GeneratedColumn<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AgriProductsTableAnnotationComposer get agri_product_id {
    final $$AgriProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.agri_product_id,
      referencedTable: $db.agriProducts,
      getReferencedColumn: (t) => t.agri_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AgriProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.agriProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AgricultureTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AgricultureTable,
          AgricultureData,
          $$AgricultureTableFilterComposer,
          $$AgricultureTableOrderingComposer,
          $$AgricultureTableAnnotationComposer,
          $$AgricultureTableCreateCompanionBuilder,
          $$AgricultureTableUpdateCompanionBuilder,
          (AgricultureData, $$AgricultureTableReferences),
          AgricultureData,
          PrefetchHooks Function({bool person_id, bool agri_product_id})
        > {
  $$AgricultureTableTableManager(_$AppDatabase db, $AgricultureTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$AgricultureTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$AgricultureTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$AgricultureTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> agriculture_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int?> agri_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> farmer_count = const Value.absent(),
              }) => AgricultureCompanion(
                agriculture_id: agriculture_id,
                person_id: person_id,
                agri_product_id: agri_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                farmer_count: farmer_count,
              ),
          createCompanionCallback:
              ({
                Value<int> agriculture_id = const Value.absent(),
                required int person_id,
                Value<int?> agri_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> farmer_count = const Value.absent(),
              }) => AgricultureCompanion.insert(
                agriculture_id: agriculture_id,
                person_id: person_id,
                agri_product_id: agri_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                farmer_count: farmer_count,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$AgricultureTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            agri_product_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$AgricultureTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$AgricultureTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (agri_product_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.agri_product_id,
                            referencedTable: $$AgricultureTableReferences
                                ._agri_product_idTable(db),
                            referencedColumn:
                                $$AgricultureTableReferences
                                    ._agri_product_idTable(db)
                                    .agri_product_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AgricultureTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AgricultureTable,
      AgricultureData,
      $$AgricultureTableFilterComposer,
      $$AgricultureTableOrderingComposer,
      $$AgricultureTableAnnotationComposer,
      $$AgricultureTableCreateCompanionBuilder,
      $$AgricultureTableUpdateCompanionBuilder,
      (AgricultureData, $$AgricultureTableReferences),
      AgricultureData,
      PrefetchHooks Function({bool person_id, bool agri_product_id})
    >;
typedef $$LivestockProductsTableCreateCompanionBuilder =
    LivestockProductsCompanion Function({
      Value<int> livestock_product_id,
      required String name,
    });
typedef $$LivestockProductsTableUpdateCompanionBuilder =
    LivestockProductsCompanion Function({
      Value<int> livestock_product_id,
      Value<String> name,
    });

final class $$LivestockProductsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $LivestockProductsTable,
          LivestockProductData
        > {
  $$LivestockProductsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$LivestockTable, List<LivestockData>>
  _livestockRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.livestock,
    aliasName: $_aliasNameGenerator(
      db.livestockProducts.livestock_product_id,
      db.livestock.livestock_product_id,
    ),
  );

  $$LivestockTableProcessedTableManager get livestockRefs {
    final manager = $$LivestockTableTableManager($_db, $_db.livestock).filter(
      (f) => f.livestock_product_id.livestock_product_id.sqlEquals(
        $_itemColumn<int>('livestock_product_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(_livestockRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$LivestockProductsTableFilterComposer
    extends Composer<_$AppDatabase, $LivestockProductsTable> {
  $$LivestockProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get livestock_product_id => $composableBuilder(
    column: $table.livestock_product_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> livestockRefs(
    Expression<bool> Function($$LivestockTableFilterComposer f) f,
  ) {
    final $$LivestockTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.livestock_product_id,
      referencedTable: $db.livestock,
      getReferencedColumn: (t) => t.livestock_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockTableFilterComposer(
            $db: $db,
            $table: $db.livestock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LivestockProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $LivestockProductsTable> {
  $$LivestockProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get livestock_product_id => $composableBuilder(
    column: $table.livestock_product_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$LivestockProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LivestockProductsTable> {
  $$LivestockProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get livestock_product_id => $composableBuilder(
    column: $table.livestock_product_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  Expression<T> livestockRefs<T extends Object>(
    Expression<T> Function($$LivestockTableAnnotationComposer a) f,
  ) {
    final $$LivestockTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.livestock_product_id,
      referencedTable: $db.livestock,
      getReferencedColumn: (t) => t.livestock_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockTableAnnotationComposer(
            $db: $db,
            $table: $db.livestock,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LivestockProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LivestockProductsTable,
          LivestockProductData,
          $$LivestockProductsTableFilterComposer,
          $$LivestockProductsTableOrderingComposer,
          $$LivestockProductsTableAnnotationComposer,
          $$LivestockProductsTableCreateCompanionBuilder,
          $$LivestockProductsTableUpdateCompanionBuilder,
          (LivestockProductData, $$LivestockProductsTableReferences),
          LivestockProductData,
          PrefetchHooks Function({bool livestockRefs})
        > {
  $$LivestockProductsTableTableManager(
    _$AppDatabase db,
    $LivestockProductsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$LivestockProductsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$LivestockProductsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$LivestockProductsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> livestock_product_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => LivestockProductsCompanion(
                livestock_product_id: livestock_product_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> livestock_product_id = const Value.absent(),
                required String name,
              }) => LivestockProductsCompanion.insert(
                livestock_product_id: livestock_product_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$LivestockProductsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({livestockRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (livestockRefs) db.livestock],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (livestockRefs)
                    await $_getPrefetchedData<
                      LivestockProductData,
                      $LivestockProductsTable,
                      LivestockData
                    >(
                      currentTable: table,
                      referencedTable: $$LivestockProductsTableReferences
                          ._livestockRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$LivestockProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).livestockRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) =>
                                e.livestock_product_id ==
                                item.livestock_product_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$LivestockProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LivestockProductsTable,
      LivestockProductData,
      $$LivestockProductsTableFilterComposer,
      $$LivestockProductsTableOrderingComposer,
      $$LivestockProductsTableAnnotationComposer,
      $$LivestockProductsTableCreateCompanionBuilder,
      $$LivestockProductsTableUpdateCompanionBuilder,
      (LivestockProductData, $$LivestockProductsTableReferences),
      LivestockProductData,
      PrefetchHooks Function({bool livestockRefs})
    >;
typedef $$LivestockTableCreateCompanionBuilder =
    LivestockCompanion Function({
      Value<int> livestock_id,
      required int person_id,
      Value<int?> livestock_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> farmer_count,
    });
typedef $$LivestockTableUpdateCompanionBuilder =
    LivestockCompanion Function({
      Value<int> livestock_id,
      Value<int> person_id,
      Value<int?> livestock_product_id,
      Value<double?> area_ha,
      Value<double?> volume_kg,
      Value<int?> production_value,
      Value<int?> farmer_count,
    });

final class $$LivestockTableReferences
    extends BaseReferences<_$AppDatabase, $LivestockTable, LivestockData> {
  $$LivestockTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.livestock.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $LivestockProductsTable _livestock_product_idTable(_$AppDatabase db) =>
      db.livestockProducts.createAlias(
        $_aliasNameGenerator(
          db.livestock.livestock_product_id,
          db.livestockProducts.livestock_product_id,
        ),
      );

  $$LivestockProductsTableProcessedTableManager? get livestock_product_id {
    final $_column = $_itemColumn<int>('livestock_product_id');
    if ($_column == null) return null;
    final manager = $$LivestockProductsTableTableManager(
      $_db,
      $_db.livestockProducts,
    ).filter((f) => f.livestock_product_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(
      _livestock_product_idTable($_db),
    );
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$LivestockTableFilterComposer
    extends Composer<_$AppDatabase, $LivestockTable> {
  $$LivestockTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get livestock_id => $composableBuilder(
    column: $table.livestock_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LivestockProductsTableFilterComposer get livestock_product_id {
    final $$LivestockProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.livestock_product_id,
      referencedTable: $db.livestockProducts,
      getReferencedColumn: (t) => t.livestock_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockProductsTableFilterComposer(
            $db: $db,
            $table: $db.livestockProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LivestockTableOrderingComposer
    extends Composer<_$AppDatabase, $LivestockTable> {
  $$LivestockTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get livestock_id => $composableBuilder(
    column: $table.livestock_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get area_ha => $composableBuilder(
    column: $table.area_ha,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get volume_kg => $composableBuilder(
    column: $table.volume_kg,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LivestockProductsTableOrderingComposer get livestock_product_id {
    final $$LivestockProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.livestock_product_id,
      referencedTable: $db.livestockProducts,
      getReferencedColumn: (t) => t.livestock_product_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LivestockProductsTableOrderingComposer(
            $db: $db,
            $table: $db.livestockProducts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LivestockTableAnnotationComposer
    extends Composer<_$AppDatabase, $LivestockTable> {
  $$LivestockTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get livestock_id => $composableBuilder(
    column: $table.livestock_id,
    builder: (column) => column,
  );

  GeneratedColumn<double> get area_ha =>
      $composableBuilder(column: $table.area_ha, builder: (column) => column);

  GeneratedColumn<double> get volume_kg =>
      $composableBuilder(column: $table.volume_kg, builder: (column) => column);

  GeneratedColumn<int> get production_value => $composableBuilder(
    column: $table.production_value,
    builder: (column) => column,
  );

  GeneratedColumn<int> get farmer_count => $composableBuilder(
    column: $table.farmer_count,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LivestockProductsTableAnnotationComposer get livestock_product_id {
    final $$LivestockProductsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.livestock_product_id,
          referencedTable: $db.livestockProducts,
          getReferencedColumn: (t) => t.livestock_product_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$LivestockProductsTableAnnotationComposer(
                $db: $db,
                $table: $db.livestockProducts,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }
}

class $$LivestockTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LivestockTable,
          LivestockData,
          $$LivestockTableFilterComposer,
          $$LivestockTableOrderingComposer,
          $$LivestockTableAnnotationComposer,
          $$LivestockTableCreateCompanionBuilder,
          $$LivestockTableUpdateCompanionBuilder,
          (LivestockData, $$LivestockTableReferences),
          LivestockData,
          PrefetchHooks Function({bool person_id, bool livestock_product_id})
        > {
  $$LivestockTableTableManager(_$AppDatabase db, $LivestockTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$LivestockTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$LivestockTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$LivestockTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> livestock_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int?> livestock_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> farmer_count = const Value.absent(),
              }) => LivestockCompanion(
                livestock_id: livestock_id,
                person_id: person_id,
                livestock_product_id: livestock_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                farmer_count: farmer_count,
              ),
          createCompanionCallback:
              ({
                Value<int> livestock_id = const Value.absent(),
                required int person_id,
                Value<int?> livestock_product_id = const Value.absent(),
                Value<double?> area_ha = const Value.absent(),
                Value<double?> volume_kg = const Value.absent(),
                Value<int?> production_value = const Value.absent(),
                Value<int?> farmer_count = const Value.absent(),
              }) => LivestockCompanion.insert(
                livestock_id: livestock_id,
                person_id: person_id,
                livestock_product_id: livestock_product_id,
                area_ha: area_ha,
                volume_kg: volume_kg,
                production_value: production_value,
                farmer_count: farmer_count,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$LivestockTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            livestock_product_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$LivestockTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$LivestockTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (livestock_product_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.livestock_product_id,
                            referencedTable: $$LivestockTableReferences
                                ._livestock_product_idTable(db),
                            referencedColumn:
                                $$LivestockTableReferences
                                    ._livestock_product_idTable(db)
                                    .livestock_product_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$LivestockTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LivestockTable,
      LivestockData,
      $$LivestockTableFilterComposer,
      $$LivestockTableOrderingComposer,
      $$LivestockTableAnnotationComposer,
      $$LivestockTableCreateCompanionBuilder,
      $$LivestockTableUpdateCompanionBuilder,
      (LivestockData, $$LivestockTableReferences),
      LivestockData,
      PrefetchHooks Function({bool person_id, bool livestock_product_id})
    >;
typedef $$QuestionsTableCreateCompanionBuilder =
    QuestionsCompanion Function({
      Value<int> question_id,
      required String question,
    });
typedef $$QuestionsTableUpdateCompanionBuilder =
    QuestionsCompanion Function({
      Value<int> question_id,
      Value<String> question,
    });

final class $$QuestionsTableReferences
    extends BaseReferences<_$AppDatabase, $QuestionsTable, QuestionData> {
  $$QuestionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$QuestionChoicesTable, List<QustionChoiceData>>
  _questionChoicesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.questionChoices,
    aliasName: $_aliasNameGenerator(
      db.questions.question_id,
      db.questionChoices.question_id,
    ),
  );

  $$QuestionChoicesTableProcessedTableManager get questionChoicesRefs {
    final manager = $$QuestionChoicesTableTableManager(
      $_db,
      $_db.questionChoices,
    ).filter(
      (f) => f.question_id.question_id.sqlEquals(
        $_itemColumn<int>('question_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _questionChoicesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $HouseholdResponsesTable,
    List<HouseholdResponseData>
  >
  _householdResponsesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.householdResponses,
        aliasName: $_aliasNameGenerator(
          db.questions.question_id,
          db.householdResponses.question_id,
        ),
      );

  $$HouseholdResponsesTableProcessedTableManager get householdResponsesRefs {
    final manager = $$HouseholdResponsesTableTableManager(
      $_db,
      $_db.householdResponses,
    ).filter(
      (f) => f.question_id.question_id.sqlEquals(
        $_itemColumn<int>('question_id')!,
      ),
    );

    final cache = $_typedResult.readTableOrNull(
      _householdResponsesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$QuestionsTableFilterComposer
    extends Composer<_$AppDatabase, $QuestionsTable> {
  $$QuestionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get question_id => $composableBuilder(
    column: $table.question_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get question => $composableBuilder(
    column: $table.question,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> questionChoicesRefs(
    Expression<bool> Function($$QuestionChoicesTableFilterComposer f) f,
  ) {
    final $$QuestionChoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questionChoices,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionChoicesTableFilterComposer(
            $db: $db,
            $table: $db.questionChoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> householdResponsesRefs(
    Expression<bool> Function($$HouseholdResponsesTableFilterComposer f) f,
  ) {
    final $$HouseholdResponsesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.householdResponses,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdResponsesTableFilterComposer(
            $db: $db,
            $table: $db.householdResponses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuestionsTableOrderingComposer
    extends Composer<_$AppDatabase, $QuestionsTable> {
  $$QuestionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get question_id => $composableBuilder(
    column: $table.question_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get question => $composableBuilder(
    column: $table.question,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$QuestionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $QuestionsTable> {
  $$QuestionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get question_id => $composableBuilder(
    column: $table.question_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get question =>
      $composableBuilder(column: $table.question, builder: (column) => column);

  Expression<T> questionChoicesRefs<T extends Object>(
    Expression<T> Function($$QuestionChoicesTableAnnotationComposer a) f,
  ) {
    final $$QuestionChoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questionChoices,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionChoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.questionChoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> householdResponsesRefs<T extends Object>(
    Expression<T> Function($$HouseholdResponsesTableAnnotationComposer a) f,
  ) {
    final $$HouseholdResponsesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.question_id,
          referencedTable: $db.householdResponses,
          getReferencedColumn: (t) => t.question_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdResponsesTableAnnotationComposer(
                $db: $db,
                $table: $db.householdResponses,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$QuestionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $QuestionsTable,
          QuestionData,
          $$QuestionsTableFilterComposer,
          $$QuestionsTableOrderingComposer,
          $$QuestionsTableAnnotationComposer,
          $$QuestionsTableCreateCompanionBuilder,
          $$QuestionsTableUpdateCompanionBuilder,
          (QuestionData, $$QuestionsTableReferences),
          QuestionData,
          PrefetchHooks Function({
            bool questionChoicesRefs,
            bool householdResponsesRefs,
          })
        > {
  $$QuestionsTableTableManager(_$AppDatabase db, $QuestionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$QuestionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$QuestionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$QuestionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> question_id = const Value.absent(),
                Value<String> question = const Value.absent(),
              }) => QuestionsCompanion(
                question_id: question_id,
                question: question,
              ),
          createCompanionCallback:
              ({
                Value<int> question_id = const Value.absent(),
                required String question,
              }) => QuestionsCompanion.insert(
                question_id: question_id,
                question: question,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$QuestionsTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            questionChoicesRefs = false,
            householdResponsesRefs = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (questionChoicesRefs) db.questionChoices,
                if (householdResponsesRefs) db.householdResponses,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (questionChoicesRefs)
                    await $_getPrefetchedData<
                      QuestionData,
                      $QuestionsTable,
                      QustionChoiceData
                    >(
                      currentTable: table,
                      referencedTable: $$QuestionsTableReferences
                          ._questionChoicesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$QuestionsTableReferences(
                                db,
                                table,
                                p0,
                              ).questionChoicesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.question_id == item.question_id,
                          ),
                      typedResults: items,
                    ),
                  if (householdResponsesRefs)
                    await $_getPrefetchedData<
                      QuestionData,
                      $QuestionsTable,
                      HouseholdResponseData
                    >(
                      currentTable: table,
                      referencedTable: $$QuestionsTableReferences
                          ._householdResponsesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$QuestionsTableReferences(
                                db,
                                table,
                                p0,
                              ).householdResponsesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.question_id == item.question_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$QuestionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $QuestionsTable,
      QuestionData,
      $$QuestionsTableFilterComposer,
      $$QuestionsTableOrderingComposer,
      $$QuestionsTableAnnotationComposer,
      $$QuestionsTableCreateCompanionBuilder,
      $$QuestionsTableUpdateCompanionBuilder,
      (QuestionData, $$QuestionsTableReferences),
      QuestionData,
      PrefetchHooks Function({
        bool questionChoicesRefs,
        bool householdResponsesRefs,
      })
    >;
typedef $$QuestionChoicesTableCreateCompanionBuilder =
    QuestionChoicesCompanion Function({
      Value<int> choice_id,
      required String choice,
      required int question_id,
    });
typedef $$QuestionChoicesTableUpdateCompanionBuilder =
    QuestionChoicesCompanion Function({
      Value<int> choice_id,
      Value<String> choice,
      Value<int> question_id,
    });

final class $$QuestionChoicesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $QuestionChoicesTable,
          QustionChoiceData
        > {
  $$QuestionChoicesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $QuestionsTable _question_idTable(_$AppDatabase db) =>
      db.questions.createAlias(
        $_aliasNameGenerator(
          db.questionChoices.question_id,
          db.questions.question_id,
        ),
      );

  $$QuestionsTableProcessedTableManager get question_id {
    final $_column = $_itemColumn<int>('question_id')!;

    final manager = $$QuestionsTableTableManager(
      $_db,
      $_db.questions,
    ).filter((f) => f.question_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_question_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $HouseholdResponsesTable,
    List<HouseholdResponseData>
  >
  _householdResponsesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.householdResponses,
        aliasName: $_aliasNameGenerator(
          db.questionChoices.choice_id,
          db.householdResponses.choice_id,
        ),
      );

  $$HouseholdResponsesTableProcessedTableManager get householdResponsesRefs {
    final manager = $$HouseholdResponsesTableTableManager(
      $_db,
      $_db.householdResponses,
    ).filter(
      (f) => f.choice_id.choice_id.sqlEquals($_itemColumn<int>('choice_id')!),
    );

    final cache = $_typedResult.readTableOrNull(
      _householdResponsesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$QuestionChoicesTableFilterComposer
    extends Composer<_$AppDatabase, $QuestionChoicesTable> {
  $$QuestionChoicesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get choice_id => $composableBuilder(
    column: $table.choice_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get choice => $composableBuilder(
    column: $table.choice,
    builder: (column) => ColumnFilters(column),
  );

  $$QuestionsTableFilterComposer get question_id {
    final $$QuestionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableFilterComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> householdResponsesRefs(
    Expression<bool> Function($$HouseholdResponsesTableFilterComposer f) f,
  ) {
    final $$HouseholdResponsesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.choice_id,
      referencedTable: $db.householdResponses,
      getReferencedColumn: (t) => t.choice_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HouseholdResponsesTableFilterComposer(
            $db: $db,
            $table: $db.householdResponses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$QuestionChoicesTableOrderingComposer
    extends Composer<_$AppDatabase, $QuestionChoicesTable> {
  $$QuestionChoicesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get choice_id => $composableBuilder(
    column: $table.choice_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get choice => $composableBuilder(
    column: $table.choice,
    builder: (column) => ColumnOrderings(column),
  );

  $$QuestionsTableOrderingComposer get question_id {
    final $$QuestionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableOrderingComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$QuestionChoicesTableAnnotationComposer
    extends Composer<_$AppDatabase, $QuestionChoicesTable> {
  $$QuestionChoicesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get choice_id =>
      $composableBuilder(column: $table.choice_id, builder: (column) => column);

  GeneratedColumn<String> get choice =>
      $composableBuilder(column: $table.choice, builder: (column) => column);

  $$QuestionsTableAnnotationComposer get question_id {
    final $$QuestionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableAnnotationComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> householdResponsesRefs<T extends Object>(
    Expression<T> Function($$HouseholdResponsesTableAnnotationComposer a) f,
  ) {
    final $$HouseholdResponsesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.choice_id,
          referencedTable: $db.householdResponses,
          getReferencedColumn: (t) => t.choice_id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$HouseholdResponsesTableAnnotationComposer(
                $db: $db,
                $table: $db.householdResponses,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$QuestionChoicesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $QuestionChoicesTable,
          QustionChoiceData,
          $$QuestionChoicesTableFilterComposer,
          $$QuestionChoicesTableOrderingComposer,
          $$QuestionChoicesTableAnnotationComposer,
          $$QuestionChoicesTableCreateCompanionBuilder,
          $$QuestionChoicesTableUpdateCompanionBuilder,
          (QustionChoiceData, $$QuestionChoicesTableReferences),
          QustionChoiceData,
          PrefetchHooks Function({
            bool question_id,
            bool householdResponsesRefs,
          })
        > {
  $$QuestionChoicesTableTableManager(
    _$AppDatabase db,
    $QuestionChoicesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$QuestionChoicesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$QuestionChoicesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$QuestionChoicesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> choice_id = const Value.absent(),
                Value<String> choice = const Value.absent(),
                Value<int> question_id = const Value.absent(),
              }) => QuestionChoicesCompanion(
                choice_id: choice_id,
                choice: choice,
                question_id: question_id,
              ),
          createCompanionCallback:
              ({
                Value<int> choice_id = const Value.absent(),
                required String choice,
                required int question_id,
              }) => QuestionChoicesCompanion.insert(
                choice_id: choice_id,
                choice: choice,
                question_id: question_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$QuestionChoicesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            question_id = false,
            householdResponsesRefs = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (householdResponsesRefs) db.householdResponses,
              ],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (question_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.question_id,
                            referencedTable: $$QuestionChoicesTableReferences
                                ._question_idTable(db),
                            referencedColumn:
                                $$QuestionChoicesTableReferences
                                    ._question_idTable(db)
                                    .question_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (householdResponsesRefs)
                    await $_getPrefetchedData<
                      QustionChoiceData,
                      $QuestionChoicesTable,
                      HouseholdResponseData
                    >(
                      currentTable: table,
                      referencedTable: $$QuestionChoicesTableReferences
                          ._householdResponsesRefsTable(db),
                      managerFromTypedResult:
                          (p0) =>
                              $$QuestionChoicesTableReferences(
                                db,
                                table,
                                p0,
                              ).householdResponsesRefs,
                      referencedItemsForCurrentItem:
                          (item, referencedItems) => referencedItems.where(
                            (e) => e.choice_id == item.choice_id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$QuestionChoicesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $QuestionChoicesTable,
      QustionChoiceData,
      $$QuestionChoicesTableFilterComposer,
      $$QuestionChoicesTableOrderingComposer,
      $$QuestionChoicesTableAnnotationComposer,
      $$QuestionChoicesTableCreateCompanionBuilder,
      $$QuestionChoicesTableUpdateCompanionBuilder,
      (QustionChoiceData, $$QuestionChoicesTableReferences),
      QustionChoiceData,
      PrefetchHooks Function({bool question_id, bool householdResponsesRefs})
    >;
typedef $$HouseholdResponsesTableCreateCompanionBuilder =
    HouseholdResponsesCompanion Function({
      Value<int> response_id,
      required int choice_id,
      required int question_id,
    });
typedef $$HouseholdResponsesTableUpdateCompanionBuilder =
    HouseholdResponsesCompanion Function({
      Value<int> response_id,
      Value<int> choice_id,
      Value<int> question_id,
    });

final class $$HouseholdResponsesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $HouseholdResponsesTable,
          HouseholdResponseData
        > {
  $$HouseholdResponsesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $QuestionChoicesTable _choice_idTable(_$AppDatabase db) =>
      db.questionChoices.createAlias(
        $_aliasNameGenerator(
          db.householdResponses.choice_id,
          db.questionChoices.choice_id,
        ),
      );

  $$QuestionChoicesTableProcessedTableManager get choice_id {
    final $_column = $_itemColumn<int>('choice_id')!;

    final manager = $$QuestionChoicesTableTableManager(
      $_db,
      $_db.questionChoices,
    ).filter((f) => f.choice_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_choice_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $QuestionsTable _question_idTable(_$AppDatabase db) =>
      db.questions.createAlias(
        $_aliasNameGenerator(
          db.householdResponses.question_id,
          db.questions.question_id,
        ),
      );

  $$QuestionsTableProcessedTableManager get question_id {
    final $_column = $_itemColumn<int>('question_id')!;

    final manager = $$QuestionsTableTableManager(
      $_db,
      $_db.questions,
    ).filter((f) => f.question_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_question_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$HouseholdResponsesTableFilterComposer
    extends Composer<_$AppDatabase, $HouseholdResponsesTable> {
  $$HouseholdResponsesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get response_id => $composableBuilder(
    column: $table.response_id,
    builder: (column) => ColumnFilters(column),
  );

  $$QuestionChoicesTableFilterComposer get choice_id {
    final $$QuestionChoicesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.choice_id,
      referencedTable: $db.questionChoices,
      getReferencedColumn: (t) => t.choice_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionChoicesTableFilterComposer(
            $db: $db,
            $table: $db.questionChoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuestionsTableFilterComposer get question_id {
    final $$QuestionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableFilterComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdResponsesTableOrderingComposer
    extends Composer<_$AppDatabase, $HouseholdResponsesTable> {
  $$HouseholdResponsesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get response_id => $composableBuilder(
    column: $table.response_id,
    builder: (column) => ColumnOrderings(column),
  );

  $$QuestionChoicesTableOrderingComposer get choice_id {
    final $$QuestionChoicesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.choice_id,
      referencedTable: $db.questionChoices,
      getReferencedColumn: (t) => t.choice_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionChoicesTableOrderingComposer(
            $db: $db,
            $table: $db.questionChoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuestionsTableOrderingComposer get question_id {
    final $$QuestionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableOrderingComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdResponsesTableAnnotationComposer
    extends Composer<_$AppDatabase, $HouseholdResponsesTable> {
  $$HouseholdResponsesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get response_id => $composableBuilder(
    column: $table.response_id,
    builder: (column) => column,
  );

  $$QuestionChoicesTableAnnotationComposer get choice_id {
    final $$QuestionChoicesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.choice_id,
      referencedTable: $db.questionChoices,
      getReferencedColumn: (t) => t.choice_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionChoicesTableAnnotationComposer(
            $db: $db,
            $table: $db.questionChoices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$QuestionsTableAnnotationComposer get question_id {
    final $$QuestionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.question_id,
      referencedTable: $db.questions,
      getReferencedColumn: (t) => t.question_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$QuestionsTableAnnotationComposer(
            $db: $db,
            $table: $db.questions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HouseholdResponsesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HouseholdResponsesTable,
          HouseholdResponseData,
          $$HouseholdResponsesTableFilterComposer,
          $$HouseholdResponsesTableOrderingComposer,
          $$HouseholdResponsesTableAnnotationComposer,
          $$HouseholdResponsesTableCreateCompanionBuilder,
          $$HouseholdResponsesTableUpdateCompanionBuilder,
          (HouseholdResponseData, $$HouseholdResponsesTableReferences),
          HouseholdResponseData,
          PrefetchHooks Function({bool choice_id, bool question_id})
        > {
  $$HouseholdResponsesTableTableManager(
    _$AppDatabase db,
    $HouseholdResponsesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$HouseholdResponsesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$HouseholdResponsesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$HouseholdResponsesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> response_id = const Value.absent(),
                Value<int> choice_id = const Value.absent(),
                Value<int> question_id = const Value.absent(),
              }) => HouseholdResponsesCompanion(
                response_id: response_id,
                choice_id: choice_id,
                question_id: question_id,
              ),
          createCompanionCallback:
              ({
                Value<int> response_id = const Value.absent(),
                required int choice_id,
                required int question_id,
              }) => HouseholdResponsesCompanion.insert(
                response_id: response_id,
                choice_id: choice_id,
                question_id: question_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$HouseholdResponsesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({choice_id = false, question_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (choice_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.choice_id,
                            referencedTable: $$HouseholdResponsesTableReferences
                                ._choice_idTable(db),
                            referencedColumn:
                                $$HouseholdResponsesTableReferences
                                    ._choice_idTable(db)
                                    .choice_id,
                          )
                          as T;
                }
                if (question_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.question_id,
                            referencedTable: $$HouseholdResponsesTableReferences
                                ._question_idTable(db),
                            referencedColumn:
                                $$HouseholdResponsesTableReferences
                                    ._question_idTable(db)
                                    .question_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$HouseholdResponsesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HouseholdResponsesTable,
      HouseholdResponseData,
      $$HouseholdResponsesTableFilterComposer,
      $$HouseholdResponsesTableOrderingComposer,
      $$HouseholdResponsesTableAnnotationComposer,
      $$HouseholdResponsesTableCreateCompanionBuilder,
      $$HouseholdResponsesTableUpdateCompanionBuilder,
      (HouseholdResponseData, $$HouseholdResponsesTableReferences),
      HouseholdResponseData,
      PrefetchHooks Function({bool choice_id, bool question_id})
    >;
typedef $$FamilyPlansTableCreateCompanionBuilder =
    FamilyPlansCompanion Function({
      Value<int> family_plan_id,
      required int person_id,
      Value<int?> fp_method_id,
      Value<int?> fp_source_id,
    });
typedef $$FamilyPlansTableUpdateCompanionBuilder =
    FamilyPlansCompanion Function({
      Value<int> family_plan_id,
      Value<int> person_id,
      Value<int?> fp_method_id,
      Value<int?> fp_source_id,
    });

final class $$FamilyPlansTableReferences
    extends BaseReferences<_$AppDatabase, $FamilyPlansTable, FamilyPlanData> {
  $$FamilyPlansTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.familyPlans.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FpMethodsTable _fp_method_idTable(_$AppDatabase db) =>
      db.fpMethods.createAlias(
        $_aliasNameGenerator(
          db.familyPlans.fp_method_id,
          db.fpMethods.fp_method_id,
        ),
      );

  $$FpMethodsTableProcessedTableManager? get fp_method_id {
    final $_column = $_itemColumn<int>('fp_method_id');
    if ($_column == null) return null;
    final manager = $$FpMethodsTableTableManager(
      $_db,
      $_db.fpMethods,
    ).filter((f) => f.fp_method_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_fp_method_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FpSourcesTable _fp_source_idTable(_$AppDatabase db) =>
      db.fpSources.createAlias(
        $_aliasNameGenerator(
          db.familyPlans.fp_source_id,
          db.fpSources.fp_source_id,
        ),
      );

  $$FpSourcesTableProcessedTableManager? get fp_source_id {
    final $_column = $_itemColumn<int>('fp_source_id');
    if ($_column == null) return null;
    final manager = $$FpSourcesTableTableManager(
      $_db,
      $_db.fpSources,
    ).filter((f) => f.fp_source_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_fp_source_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FamilyPlansTableFilterComposer
    extends Composer<_$AppDatabase, $FamilyPlansTable> {
  $$FamilyPlansTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get family_plan_id => $composableBuilder(
    column: $table.family_plan_id,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpMethodsTableFilterComposer get fp_method_id {
    final $$FpMethodsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_method_id,
      referencedTable: $db.fpMethods,
      getReferencedColumn: (t) => t.fp_method_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpMethodsTableFilterComposer(
            $db: $db,
            $table: $db.fpMethods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpSourcesTableFilterComposer get fp_source_id {
    final $$FpSourcesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_source_id,
      referencedTable: $db.fpSources,
      getReferencedColumn: (t) => t.fp_source_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpSourcesTableFilterComposer(
            $db: $db,
            $table: $db.fpSources,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyPlansTableOrderingComposer
    extends Composer<_$AppDatabase, $FamilyPlansTable> {
  $$FamilyPlansTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get family_plan_id => $composableBuilder(
    column: $table.family_plan_id,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpMethodsTableOrderingComposer get fp_method_id {
    final $$FpMethodsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_method_id,
      referencedTable: $db.fpMethods,
      getReferencedColumn: (t) => t.fp_method_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpMethodsTableOrderingComposer(
            $db: $db,
            $table: $db.fpMethods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpSourcesTableOrderingComposer get fp_source_id {
    final $$FpSourcesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_source_id,
      referencedTable: $db.fpSources,
      getReferencedColumn: (t) => t.fp_source_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpSourcesTableOrderingComposer(
            $db: $db,
            $table: $db.fpSources,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyPlansTableAnnotationComposer
    extends Composer<_$AppDatabase, $FamilyPlansTable> {
  $$FamilyPlansTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get family_plan_id => $composableBuilder(
    column: $table.family_plan_id,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpMethodsTableAnnotationComposer get fp_method_id {
    final $$FpMethodsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_method_id,
      referencedTable: $db.fpMethods,
      getReferencedColumn: (t) => t.fp_method_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpMethodsTableAnnotationComposer(
            $db: $db,
            $table: $db.fpMethods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FpSourcesTableAnnotationComposer get fp_source_id {
    final $$FpSourcesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fp_source_id,
      referencedTable: $db.fpSources,
      getReferencedColumn: (t) => t.fp_source_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FpSourcesTableAnnotationComposer(
            $db: $db,
            $table: $db.fpSources,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyPlansTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FamilyPlansTable,
          FamilyPlanData,
          $$FamilyPlansTableFilterComposer,
          $$FamilyPlansTableOrderingComposer,
          $$FamilyPlansTableAnnotationComposer,
          $$FamilyPlansTableCreateCompanionBuilder,
          $$FamilyPlansTableUpdateCompanionBuilder,
          (FamilyPlanData, $$FamilyPlansTableReferences),
          FamilyPlanData,
          PrefetchHooks Function({
            bool person_id,
            bool fp_method_id,
            bool fp_source_id,
          })
        > {
  $$FamilyPlansTableTableManager(_$AppDatabase db, $FamilyPlansTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$FamilyPlansTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$FamilyPlansTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$FamilyPlansTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> family_plan_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<int?> fp_method_id = const Value.absent(),
                Value<int?> fp_source_id = const Value.absent(),
              }) => FamilyPlansCompanion(
                family_plan_id: family_plan_id,
                person_id: person_id,
                fp_method_id: fp_method_id,
                fp_source_id: fp_source_id,
              ),
          createCompanionCallback:
              ({
                Value<int> family_plan_id = const Value.absent(),
                required int person_id,
                Value<int?> fp_method_id = const Value.absent(),
                Value<int?> fp_source_id = const Value.absent(),
              }) => FamilyPlansCompanion.insert(
                family_plan_id: family_plan_id,
                person_id: person_id,
                fp_method_id: fp_method_id,
                fp_source_id: fp_source_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$FamilyPlansTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            fp_method_id = false,
            fp_source_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$FamilyPlansTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$FamilyPlansTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (fp_method_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.fp_method_id,
                            referencedTable: $$FamilyPlansTableReferences
                                ._fp_method_idTable(db),
                            referencedColumn:
                                $$FamilyPlansTableReferences
                                    ._fp_method_idTable(db)
                                    .fp_method_id,
                          )
                          as T;
                }
                if (fp_source_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.fp_source_id,
                            referencedTable: $$FamilyPlansTableReferences
                                ._fp_source_idTable(db),
                            referencedColumn:
                                $$FamilyPlansTableReferences
                                    ._fp_source_idTable(db)
                                    .fp_source_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FamilyPlansTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FamilyPlansTable,
      FamilyPlanData,
      $$FamilyPlansTableFilterComposer,
      $$FamilyPlansTableOrderingComposer,
      $$FamilyPlansTableAnnotationComposer,
      $$FamilyPlansTableCreateCompanionBuilder,
      $$FamilyPlansTableUpdateCompanionBuilder,
      (FamilyPlanData, $$FamilyPlansTableReferences),
      FamilyPlanData,
      PrefetchHooks Function({
        bool person_id,
        bool fp_method_id,
        bool fp_source_id,
      })
    >;
typedef $$MaternalInfosTableCreateCompanionBuilder =
    MaternalInfosCompanion Function({
      Value<int> maternal_info_id,
      required int person_id,
      Value<bool?> pregnant,
      Value<bool?> lactating,
      Value<int?> living_children_num,
      Value<bool?> fp_intention,
    });
typedef $$MaternalInfosTableUpdateCompanionBuilder =
    MaternalInfosCompanion Function({
      Value<int> maternal_info_id,
      Value<int> person_id,
      Value<bool?> pregnant,
      Value<bool?> lactating,
      Value<int?> living_children_num,
      Value<bool?> fp_intention,
    });

final class $$MaternalInfosTableReferences
    extends
        BaseReferences<_$AppDatabase, $MaternalInfosTable, MaternalInfoData> {
  $$MaternalInfosTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.maternalInfos.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$MaternalInfosTableFilterComposer
    extends Composer<_$AppDatabase, $MaternalInfosTable> {
  $$MaternalInfosTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get maternal_info_id => $composableBuilder(
    column: $table.maternal_info_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get pregnant => $composableBuilder(
    column: $table.pregnant,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get lactating => $composableBuilder(
    column: $table.lactating,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get living_children_num => $composableBuilder(
    column: $table.living_children_num,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get fp_intention => $composableBuilder(
    column: $table.fp_intention,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MaternalInfosTableOrderingComposer
    extends Composer<_$AppDatabase, $MaternalInfosTable> {
  $$MaternalInfosTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get maternal_info_id => $composableBuilder(
    column: $table.maternal_info_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get pregnant => $composableBuilder(
    column: $table.pregnant,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get lactating => $composableBuilder(
    column: $table.lactating,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get living_children_num => $composableBuilder(
    column: $table.living_children_num,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get fp_intention => $composableBuilder(
    column: $table.fp_intention,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MaternalInfosTableAnnotationComposer
    extends Composer<_$AppDatabase, $MaternalInfosTable> {
  $$MaternalInfosTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get maternal_info_id => $composableBuilder(
    column: $table.maternal_info_id,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get pregnant =>
      $composableBuilder(column: $table.pregnant, builder: (column) => column);

  GeneratedColumn<bool> get lactating =>
      $composableBuilder(column: $table.lactating, builder: (column) => column);

  GeneratedColumn<int> get living_children_num => $composableBuilder(
    column: $table.living_children_num,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get fp_intention => $composableBuilder(
    column: $table.fp_intention,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$MaternalInfosTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MaternalInfosTable,
          MaternalInfoData,
          $$MaternalInfosTableFilterComposer,
          $$MaternalInfosTableOrderingComposer,
          $$MaternalInfosTableAnnotationComposer,
          $$MaternalInfosTableCreateCompanionBuilder,
          $$MaternalInfosTableUpdateCompanionBuilder,
          (MaternalInfoData, $$MaternalInfosTableReferences),
          MaternalInfoData,
          PrefetchHooks Function({bool person_id})
        > {
  $$MaternalInfosTableTableManager(_$AppDatabase db, $MaternalInfosTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$MaternalInfosTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () =>
                  $$MaternalInfosTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () => $$MaternalInfosTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> maternal_info_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<bool?> pregnant = const Value.absent(),
                Value<bool?> lactating = const Value.absent(),
                Value<int?> living_children_num = const Value.absent(),
                Value<bool?> fp_intention = const Value.absent(),
              }) => MaternalInfosCompanion(
                maternal_info_id: maternal_info_id,
                person_id: person_id,
                pregnant: pregnant,
                lactating: lactating,
                living_children_num: living_children_num,
                fp_intention: fp_intention,
              ),
          createCompanionCallback:
              ({
                Value<int> maternal_info_id = const Value.absent(),
                required int person_id,
                Value<bool?> pregnant = const Value.absent(),
                Value<bool?> lactating = const Value.absent(),
                Value<int?> living_children_num = const Value.absent(),
                Value<bool?> fp_intention = const Value.absent(),
              }) => MaternalInfosCompanion.insert(
                maternal_info_id: maternal_info_id,
                person_id: person_id,
                pregnant: pregnant,
                lactating: lactating,
                living_children_num: living_children_num,
                fp_intention: fp_intention,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$MaternalInfosTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$MaternalInfosTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$MaternalInfosTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$MaternalInfosTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MaternalInfosTable,
      MaternalInfoData,
      $$MaternalInfosTableFilterComposer,
      $$MaternalInfosTableOrderingComposer,
      $$MaternalInfosTableAnnotationComposer,
      $$MaternalInfosTableCreateCompanionBuilder,
      $$MaternalInfosTableUpdateCompanionBuilder,
      (MaternalInfoData, $$MaternalInfosTableReferences),
      MaternalInfoData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$VisitedFacilitiesTableCreateCompanionBuilder =
    VisitedFacilitiesCompanion Function({
      Value<int> visited_facility_id,
      required int person_id,
      required String name,
      Value<DateTime?> date,
      Value<int?> visit_reason_id,
    });
typedef $$VisitedFacilitiesTableUpdateCompanionBuilder =
    VisitedFacilitiesCompanion Function({
      Value<int> visited_facility_id,
      Value<int> person_id,
      Value<String> name,
      Value<DateTime?> date,
      Value<int?> visit_reason_id,
    });

final class $$VisitedFacilitiesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $VisitedFacilitiesTable,
          VisitedFacilityData
        > {
  $$VisitedFacilitiesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.visitedFacilities.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $VisitReasonsTable _visit_reason_idTable(_$AppDatabase db) =>
      db.visitReasons.createAlias(
        $_aliasNameGenerator(
          db.visitedFacilities.visit_reason_id,
          db.visitReasons.visit_reason_id,
        ),
      );

  $$VisitReasonsTableProcessedTableManager? get visit_reason_id {
    final $_column = $_itemColumn<int>('visit_reason_id');
    if ($_column == null) return null;
    final manager = $$VisitReasonsTableTableManager(
      $_db,
      $_db.visitReasons,
    ).filter((f) => f.visit_reason_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_visit_reason_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$VisitedFacilitiesTableFilterComposer
    extends Composer<_$AppDatabase, $VisitedFacilitiesTable> {
  $$VisitedFacilitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get visited_facility_id => $composableBuilder(
    column: $table.visited_facility_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$VisitReasonsTableFilterComposer get visit_reason_id {
    final $$VisitReasonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.visit_reason_id,
      referencedTable: $db.visitReasons,
      getReferencedColumn: (t) => t.visit_reason_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VisitReasonsTableFilterComposer(
            $db: $db,
            $table: $db.visitReasons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VisitedFacilitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $VisitedFacilitiesTable> {
  $$VisitedFacilitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get visited_facility_id => $composableBuilder(
    column: $table.visited_facility_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$VisitReasonsTableOrderingComposer get visit_reason_id {
    final $$VisitReasonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.visit_reason_id,
      referencedTable: $db.visitReasons,
      getReferencedColumn: (t) => t.visit_reason_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VisitReasonsTableOrderingComposer(
            $db: $db,
            $table: $db.visitReasons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VisitedFacilitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VisitedFacilitiesTable> {
  $$VisitedFacilitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get visited_facility_id => $composableBuilder(
    column: $table.visited_facility_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$VisitReasonsTableAnnotationComposer get visit_reason_id {
    final $$VisitReasonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.visit_reason_id,
      referencedTable: $db.visitReasons,
      getReferencedColumn: (t) => t.visit_reason_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$VisitReasonsTableAnnotationComposer(
            $db: $db,
            $table: $db.visitReasons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$VisitedFacilitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $VisitedFacilitiesTable,
          VisitedFacilityData,
          $$VisitedFacilitiesTableFilterComposer,
          $$VisitedFacilitiesTableOrderingComposer,
          $$VisitedFacilitiesTableAnnotationComposer,
          $$VisitedFacilitiesTableCreateCompanionBuilder,
          $$VisitedFacilitiesTableUpdateCompanionBuilder,
          (VisitedFacilityData, $$VisitedFacilitiesTableReferences),
          VisitedFacilityData,
          PrefetchHooks Function({bool person_id, bool visit_reason_id})
        > {
  $$VisitedFacilitiesTableTableManager(
    _$AppDatabase db,
    $VisitedFacilitiesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$VisitedFacilitiesTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer:
              () => $$VisitedFacilitiesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$VisitedFacilitiesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> visited_facility_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<DateTime?> date = const Value.absent(),
                Value<int?> visit_reason_id = const Value.absent(),
              }) => VisitedFacilitiesCompanion(
                visited_facility_id: visited_facility_id,
                person_id: person_id,
                name: name,
                date: date,
                visit_reason_id: visit_reason_id,
              ),
          createCompanionCallback:
              ({
                Value<int> visited_facility_id = const Value.absent(),
                required int person_id,
                required String name,
                Value<DateTime?> date = const Value.absent(),
                Value<int?> visit_reason_id = const Value.absent(),
              }) => VisitedFacilitiesCompanion.insert(
                visited_facility_id: visited_facility_id,
                person_id: person_id,
                name: name,
                date: date,
                visit_reason_id: visit_reason_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$VisitedFacilitiesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            visit_reason_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$VisitedFacilitiesTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$VisitedFacilitiesTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (visit_reason_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.visit_reason_id,
                            referencedTable: $$VisitedFacilitiesTableReferences
                                ._visit_reason_idTable(db),
                            referencedColumn:
                                $$VisitedFacilitiesTableReferences
                                    ._visit_reason_idTable(db)
                                    .visit_reason_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$VisitedFacilitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $VisitedFacilitiesTable,
      VisitedFacilityData,
      $$VisitedFacilitiesTableFilterComposer,
      $$VisitedFacilitiesTableOrderingComposer,
      $$VisitedFacilitiesTableAnnotationComposer,
      $$VisitedFacilitiesTableCreateCompanionBuilder,
      $$VisitedFacilitiesTableUpdateCompanionBuilder,
      (VisitedFacilityData, $$VisitedFacilitiesTableReferences),
      VisitedFacilityData,
      PrefetchHooks Function({bool person_id, bool visit_reason_id})
    >;
typedef $$HealthInsurancesTableCreateCompanionBuilder =
    HealthInsurancesCompanion Function({
      Value<int> health_insurance_id,
      required int person_id,
      required String name,
    });
typedef $$HealthInsurancesTableUpdateCompanionBuilder =
    HealthInsurancesCompanion Function({
      Value<int> health_insurance_id,
      Value<int> person_id,
      Value<String> name,
    });

final class $$HealthInsurancesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $HealthInsurancesTable,
          HealthInsuranceData
        > {
  $$HealthInsurancesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(
          db.healthInsurances.person_id,
          db.persons.person_id,
        ),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$HealthInsurancesTableFilterComposer
    extends Composer<_$AppDatabase, $HealthInsurancesTable> {
  $$HealthInsurancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get health_insurance_id => $composableBuilder(
    column: $table.health_insurance_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HealthInsurancesTableOrderingComposer
    extends Composer<_$AppDatabase, $HealthInsurancesTable> {
  $$HealthInsurancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get health_insurance_id => $composableBuilder(
    column: $table.health_insurance_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HealthInsurancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $HealthInsurancesTable> {
  $$HealthInsurancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get health_insurance_id => $composableBuilder(
    column: $table.health_insurance_id,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HealthInsurancesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HealthInsurancesTable,
          HealthInsuranceData,
          $$HealthInsurancesTableFilterComposer,
          $$HealthInsurancesTableOrderingComposer,
          $$HealthInsurancesTableAnnotationComposer,
          $$HealthInsurancesTableCreateCompanionBuilder,
          $$HealthInsurancesTableUpdateCompanionBuilder,
          (HealthInsuranceData, $$HealthInsurancesTableReferences),
          HealthInsuranceData,
          PrefetchHooks Function({bool person_id})
        > {
  $$HealthInsurancesTableTableManager(
    _$AppDatabase db,
    $HealthInsurancesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () =>
                  $$HealthInsurancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$HealthInsurancesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer:
              () => $$HealthInsurancesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> health_insurance_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<String> name = const Value.absent(),
              }) => HealthInsurancesCompanion(
                health_insurance_id: health_insurance_id,
                person_id: person_id,
                name: name,
              ),
          createCompanionCallback:
              ({
                Value<int> health_insurance_id = const Value.absent(),
                required int person_id,
                required String name,
              }) => HealthInsurancesCompanion.insert(
                health_insurance_id: health_insurance_id,
                person_id: person_id,
                name: name,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$HealthInsurancesTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({person_id = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$HealthInsurancesTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$HealthInsurancesTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$HealthInsurancesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HealthInsurancesTable,
      HealthInsuranceData,
      $$HealthInsurancesTableFilterComposer,
      $$HealthInsurancesTableOrderingComposer,
      $$HealthInsurancesTableAnnotationComposer,
      $$HealthInsurancesTableCreateCompanionBuilder,
      $$HealthInsurancesTableUpdateCompanionBuilder,
      (HealthInsuranceData, $$HealthInsurancesTableReferences),
      HealthInsuranceData,
      PrefetchHooks Function({bool person_id})
    >;
typedef $$NewbornInfosTableCreateCompanionBuilder =
    NewbornInfosCompanion Function({
      Value<int> newborn_info_id,
      required int person_id,
      Value<bool?> immunization,
      Value<int?> delivery_place_id,
      Value<int?> assisted_person_id,
    });
typedef $$NewbornInfosTableUpdateCompanionBuilder =
    NewbornInfosCompanion Function({
      Value<int> newborn_info_id,
      Value<int> person_id,
      Value<bool?> immunization,
      Value<int?> delivery_place_id,
      Value<int?> assisted_person_id,
    });

final class $$NewbornInfosTableReferences
    extends BaseReferences<_$AppDatabase, $NewbornInfosTable, NewbornInfoData> {
  $$NewbornInfosTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PersonsTable _person_idTable(_$AppDatabase db) =>
      db.persons.createAlias(
        $_aliasNameGenerator(db.newbornInfos.person_id, db.persons.person_id),
      );

  $$PersonsTableProcessedTableManager get person_id {
    final $_column = $_itemColumn<int>('person_id')!;

    final manager = $$PersonsTableTableManager(
      $_db,
      $_db.persons,
    ).filter((f) => f.person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $DeliveryPlacesTable _delivery_place_idTable(_$AppDatabase db) =>
      db.deliveryPlaces.createAlias(
        $_aliasNameGenerator(
          db.newbornInfos.delivery_place_id,
          db.deliveryPlaces.delivery_place_id,
        ),
      );

  $$DeliveryPlacesTableProcessedTableManager? get delivery_place_id {
    final $_column = $_itemColumn<int>('delivery_place_id');
    if ($_column == null) return null;
    final manager = $$DeliveryPlacesTableTableManager(
      $_db,
      $_db.deliveryPlaces,
    ).filter((f) => f.delivery_place_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_delivery_place_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $AssistedPersonsTable _assisted_person_idTable(_$AppDatabase db) =>
      db.assistedPersons.createAlias(
        $_aliasNameGenerator(
          db.newbornInfos.assisted_person_id,
          db.assistedPersons.assisted_person_id,
        ),
      );

  $$AssistedPersonsTableProcessedTableManager? get assisted_person_id {
    final $_column = $_itemColumn<int>('assisted_person_id');
    if ($_column == null) return null;
    final manager = $$AssistedPersonsTableTableManager(
      $_db,
      $_db.assistedPersons,
    ).filter((f) => f.assisted_person_id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_assisted_person_idTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$NewbornInfosTableFilterComposer
    extends Composer<_$AppDatabase, $NewbornInfosTable> {
  $$NewbornInfosTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get newborn_info_id => $composableBuilder(
    column: $table.newborn_info_id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get immunization => $composableBuilder(
    column: $table.immunization,
    builder: (column) => ColumnFilters(column),
  );

  $$PersonsTableFilterComposer get person_id {
    final $$PersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableFilterComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DeliveryPlacesTableFilterComposer get delivery_place_id {
    final $$DeliveryPlacesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.delivery_place_id,
      referencedTable: $db.deliveryPlaces,
      getReferencedColumn: (t) => t.delivery_place_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DeliveryPlacesTableFilterComposer(
            $db: $db,
            $table: $db.deliveryPlaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AssistedPersonsTableFilterComposer get assisted_person_id {
    final $$AssistedPersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assisted_person_id,
      referencedTable: $db.assistedPersons,
      getReferencedColumn: (t) => t.assisted_person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AssistedPersonsTableFilterComposer(
            $db: $db,
            $table: $db.assistedPersons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NewbornInfosTableOrderingComposer
    extends Composer<_$AppDatabase, $NewbornInfosTable> {
  $$NewbornInfosTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get newborn_info_id => $composableBuilder(
    column: $table.newborn_info_id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get immunization => $composableBuilder(
    column: $table.immunization,
    builder: (column) => ColumnOrderings(column),
  );

  $$PersonsTableOrderingComposer get person_id {
    final $$PersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableOrderingComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DeliveryPlacesTableOrderingComposer get delivery_place_id {
    final $$DeliveryPlacesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.delivery_place_id,
      referencedTable: $db.deliveryPlaces,
      getReferencedColumn: (t) => t.delivery_place_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DeliveryPlacesTableOrderingComposer(
            $db: $db,
            $table: $db.deliveryPlaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AssistedPersonsTableOrderingComposer get assisted_person_id {
    final $$AssistedPersonsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assisted_person_id,
      referencedTable: $db.assistedPersons,
      getReferencedColumn: (t) => t.assisted_person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AssistedPersonsTableOrderingComposer(
            $db: $db,
            $table: $db.assistedPersons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NewbornInfosTableAnnotationComposer
    extends Composer<_$AppDatabase, $NewbornInfosTable> {
  $$NewbornInfosTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get newborn_info_id => $composableBuilder(
    column: $table.newborn_info_id,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get immunization => $composableBuilder(
    column: $table.immunization,
    builder: (column) => column,
  );

  $$PersonsTableAnnotationComposer get person_id {
    final $$PersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.person_id,
      referencedTable: $db.persons,
      getReferencedColumn: (t) => t.person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.persons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$DeliveryPlacesTableAnnotationComposer get delivery_place_id {
    final $$DeliveryPlacesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.delivery_place_id,
      referencedTable: $db.deliveryPlaces,
      getReferencedColumn: (t) => t.delivery_place_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$DeliveryPlacesTableAnnotationComposer(
            $db: $db,
            $table: $db.deliveryPlaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AssistedPersonsTableAnnotationComposer get assisted_person_id {
    final $$AssistedPersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assisted_person_id,
      referencedTable: $db.assistedPersons,
      getReferencedColumn: (t) => t.assisted_person_id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AssistedPersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.assistedPersons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NewbornInfosTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $NewbornInfosTable,
          NewbornInfoData,
          $$NewbornInfosTableFilterComposer,
          $$NewbornInfosTableOrderingComposer,
          $$NewbornInfosTableAnnotationComposer,
          $$NewbornInfosTableCreateCompanionBuilder,
          $$NewbornInfosTableUpdateCompanionBuilder,
          (NewbornInfoData, $$NewbornInfosTableReferences),
          NewbornInfoData,
          PrefetchHooks Function({
            bool person_id,
            bool delivery_place_id,
            bool assisted_person_id,
          })
        > {
  $$NewbornInfosTableTableManager(_$AppDatabase db, $NewbornInfosTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer:
              () => $$NewbornInfosTableFilterComposer($db: db, $table: table),
          createOrderingComposer:
              () => $$NewbornInfosTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer:
              () =>
                  $$NewbornInfosTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> newborn_info_id = const Value.absent(),
                Value<int> person_id = const Value.absent(),
                Value<bool?> immunization = const Value.absent(),
                Value<int?> delivery_place_id = const Value.absent(),
                Value<int?> assisted_person_id = const Value.absent(),
              }) => NewbornInfosCompanion(
                newborn_info_id: newborn_info_id,
                person_id: person_id,
                immunization: immunization,
                delivery_place_id: delivery_place_id,
                assisted_person_id: assisted_person_id,
              ),
          createCompanionCallback:
              ({
                Value<int> newborn_info_id = const Value.absent(),
                required int person_id,
                Value<bool?> immunization = const Value.absent(),
                Value<int?> delivery_place_id = const Value.absent(),
                Value<int?> assisted_person_id = const Value.absent(),
              }) => NewbornInfosCompanion.insert(
                newborn_info_id: newborn_info_id,
                person_id: person_id,
                immunization: immunization,
                delivery_place_id: delivery_place_id,
                assisted_person_id: assisted_person_id,
              ),
          withReferenceMapper:
              (p0) =>
                  p0
                      .map(
                        (e) => (
                          e.readTable(table),
                          $$NewbornInfosTableReferences(db, table, e),
                        ),
                      )
                      .toList(),
          prefetchHooksCallback: ({
            person_id = false,
            delivery_place_id = false,
            assisted_person_id = false,
          }) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                T extends TableManagerState<
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic,
                  dynamic
                >
              >(state) {
                if (person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.person_id,
                            referencedTable: $$NewbornInfosTableReferences
                                ._person_idTable(db),
                            referencedColumn:
                                $$NewbornInfosTableReferences
                                    ._person_idTable(db)
                                    .person_id,
                          )
                          as T;
                }
                if (delivery_place_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.delivery_place_id,
                            referencedTable: $$NewbornInfosTableReferences
                                ._delivery_place_idTable(db),
                            referencedColumn:
                                $$NewbornInfosTableReferences
                                    ._delivery_place_idTable(db)
                                    .delivery_place_id,
                          )
                          as T;
                }
                if (assisted_person_id) {
                  state =
                      state.withJoin(
                            currentTable: table,
                            currentColumn: table.assisted_person_id,
                            referencedTable: $$NewbornInfosTableReferences
                                ._assisted_person_idTable(db),
                            referencedColumn:
                                $$NewbornInfosTableReferences
                                    ._assisted_person_idTable(db)
                                    .assisted_person_id,
                          )
                          as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$NewbornInfosTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $NewbornInfosTable,
      NewbornInfoData,
      $$NewbornInfosTableFilterComposer,
      $$NewbornInfosTableOrderingComposer,
      $$NewbornInfosTableAnnotationComposer,
      $$NewbornInfosTableCreateCompanionBuilder,
      $$NewbornInfosTableUpdateCompanionBuilder,
      (NewbornInfoData, $$NewbornInfosTableReferences),
      NewbornInfoData,
      PrefetchHooks Function({
        bool person_id,
        bool delivery_place_id,
        bool assisted_person_id,
      })
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$ReligionsTableTableManager get religions =>
      $$ReligionsTableTableManager(_db, _db.religions);
  $$NationalitiesTableTableManager get nationalities =>
      $$NationalitiesTableTableManager(_db, _db.nationalities);
  $$EthnicitiesTableTableManager get ethnicities =>
      $$EthnicitiesTableTableManager(_db, _db.ethnicities);
  $$BloodTypesTableTableManager get bloodTypes =>
      $$BloodTypesTableTableManager(_db, _db.bloodTypes);
  $$AddressesTableTableManager get addresses =>
      $$AddressesTableTableManager(_db, _db.addresses);
  $$BuildingTypesTableTableManager get buildingTypes =>
      $$BuildingTypesTableTableManager(_db, _db.buildingTypes);
  $$HouseholdsTableTableManager get households =>
      $$HouseholdsTableTableManager(_db, _db.households);
  $$MonthlyIncomesTableTableManager get monthlyIncomes =>
      $$MonthlyIncomesTableTableManager(_db, _db.monthlyIncomes);
  $$DailyIncomesTableTableManager get dailyIncomes =>
      $$DailyIncomesTableTableManager(_db, _db.dailyIncomes);
  $$EducationTableTableManager get education =>
      $$EducationTableTableManager(_db, _db.education);
  $$PersonsTableTableManager get persons =>
      $$PersonsTableTableManager(_db, _db.persons);
  $$OccupationsTableTableManager get occupations =>
      $$OccupationsTableTableManager(_db, _db.occupations);
  $$EmailsTableTableManager get emails =>
      $$EmailsTableTableManager(_db, _db.emails);
  $$PhoneNumbersTableTableManager get phoneNumbers =>
      $$PhoneNumbersTableTableManager(_db, _db.phoneNumbers);
  $$GadgetsTableTableManager get gadgets =>
      $$GadgetsTableTableManager(_db, _db.gadgets);
  $$GovermentProgramsTableTableManager get govermentPrograms =>
      $$GovermentProgramsTableTableManager(_db, _db.govermentPrograms);
  $$VoterRegistriesTableTableManager get voterRegistries =>
      $$VoterRegistriesTableTableManager(_db, _db.voterRegistries);
  $$RegisteredSeniorsTableTableManager get registeredSeniors =>
      $$RegisteredSeniorsTableTableManager(_db, _db.registeredSeniors);
  $$DisabilitiesTableTableManager get disabilities =>
      $$DisabilitiesTableTableManager(_db, _db.disabilities);
  $$EnrolledTableTableManager get enrolled =>
      $$EnrolledTableTableManager(_db, _db.enrolled);
  $$CTCRecordsTableTableManager get cTCRecords =>
      $$CTCRecordsTableTableManager(_db, _db.cTCRecords);
  $$BrgyHistoriesTableTableManager get brgyHistories =>
      $$BrgyHistoriesTableTableManager(_db, _db.brgyHistories);
  $$MigrantTransientsTableTableManager get migrantTransients =>
      $$MigrantTransientsTableTableManager(_db, _db.migrantTransients);
  $$RelationshipTypesTableTableManager get relationshipTypes =>
      $$RelationshipTypesTableTableManager(_db, _db.relationshipTypes);
  $$HouseholdRelationshipsTableTableManager get householdRelationships =>
      $$HouseholdRelationshipsTableTableManager(
        _db,
        _db.householdRelationships,
      );
  $$ServicesTableTableManager get services =>
      $$ServicesTableTableManager(_db, _db.services);
  $$PrimaryNeedsTableTableManager get primaryNeeds =>
      $$PrimaryNeedsTableTableManager(_db, _db.primaryNeeds);
  $$FemaleMortalitiesTableTableManager get femaleMortalities =>
      $$FemaleMortalitiesTableTableManager(_db, _db.femaleMortalities);
  $$ChildMortalitiesTableTableManager get childMortalities =>
      $$ChildMortalitiesTableTableManager(_db, _db.childMortalities);
  $$FutureResidenciesTableTableManager get futureResidencies =>
      $$FutureResidenciesTableTableManager(_db, _db.futureResidencies);
  $$DeliveryPlacesTableTableManager get deliveryPlaces =>
      $$DeliveryPlacesTableTableManager(_db, _db.deliveryPlaces);
  $$AssistedPersonsTableTableManager get assistedPersons =>
      $$AssistedPersonsTableTableManager(_db, _db.assistedPersons);
  $$VisitReasonsTableTableManager get visitReasons =>
      $$VisitReasonsTableTableManager(_db, _db.visitReasons);
  $$FpSourcesTableTableManager get fpSources =>
      $$FpSourcesTableTableManager(_db, _db.fpSources);
  $$FpMethodsTableTableManager get fpMethods =>
      $$FpMethodsTableTableManager(_db, _db.fpMethods);
  $$FishingProductsTableTableManager get fishingProducts =>
      $$FishingProductsTableTableManager(_db, _db.fishingProducts);
  $$FishingTableTableManager get fishing =>
      $$FishingTableTableManager(_db, _db.fishing);
  $$AgriProductsTableTableManager get agriProducts =>
      $$AgriProductsTableTableManager(_db, _db.agriProducts);
  $$AgricultureTableTableManager get agriculture =>
      $$AgricultureTableTableManager(_db, _db.agriculture);
  $$LivestockProductsTableTableManager get livestockProducts =>
      $$LivestockProductsTableTableManager(_db, _db.livestockProducts);
  $$LivestockTableTableManager get livestock =>
      $$LivestockTableTableManager(_db, _db.livestock);
  $$QuestionsTableTableManager get questions =>
      $$QuestionsTableTableManager(_db, _db.questions);
  $$QuestionChoicesTableTableManager get questionChoices =>
      $$QuestionChoicesTableTableManager(_db, _db.questionChoices);
  $$HouseholdResponsesTableTableManager get householdResponses =>
      $$HouseholdResponsesTableTableManager(_db, _db.householdResponses);
  $$FamilyPlansTableTableManager get familyPlans =>
      $$FamilyPlansTableTableManager(_db, _db.familyPlans);
  $$MaternalInfosTableTableManager get maternalInfos =>
      $$MaternalInfosTableTableManager(_db, _db.maternalInfos);
  $$VisitedFacilitiesTableTableManager get visitedFacilities =>
      $$VisitedFacilitiesTableTableManager(_db, _db.visitedFacilities);
  $$HealthInsurancesTableTableManager get healthInsurances =>
      $$HealthInsurancesTableTableManager(_db, _db.healthInsurances);
  $$NewbornInfosTableTableManager get newbornInfos =>
      $$NewbornInfosTableTableManager(_db, _db.newbornInfos);
}
